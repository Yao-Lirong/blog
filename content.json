{"meta":{"title":"Yao Lirong's Blog","subtitle":null,"description":null,"author":"Yao","url":"http://yao-lirong.github.io","root":"/"},"pages":[{"title":"肥肠抱歉，出错了","date":"2021-09-24T03:43:50.606Z","updated":"2021-09-24T03:43:50.606Z","comments":true,"path":"404.html","permalink":"http://yao-lirong.github.io/404.html","excerpt":"","text":""},{"title":"Hello, World","date":"2019-06-27T04:00:00.000Z","updated":"2021-09-24T03:35:55.409Z","comments":true,"path":"about/index.html","permalink":"http://yao-lirong.github.io/about/index.html","excerpt":"","text":"Cornell CS ‘2023 Credits Favicon - Concentric Rinds by M.C. Escher Homepage - Encounter by M.C. Escher About Me page - Day and Night by M.C. Escher"}],"posts":[{"title":"2022 网络日志","slug":"2022-12-31-2022-网络日志","date":"2022-12-31T05:00:00.000Z","updated":"2022-04-09T05:31:04.657Z","comments":true,"path":"2022-12-31-2022-网络日志/","link":"","permalink":"http://yao-lirong.github.io/2022-12-31-2022-%E7%BD%91%E7%BB%9C%E6%97%A5%E5%BF%97/","excerpt":"ToolsVSCode Users can now type @lang:languageId in the Settings editor search box to view and edit all settings that can be configured for the language with ID languageId. This way, users can view language-specific settings, also known as language overrides.","text":"ToolsVSCode Users can now type @lang:languageId in the Settings editor search box to view and edit all settings that can be configured for the language with ID languageId. This way, users can view language-specific settings, also known as language overrides. TalksQuote How to Stop Worrying and Learn to Love the Internet - Douglas Adams, also collected in The Salmon of Doubt everything that’s already in the world when you’re born is just normal anything that gets invented between then and before you turn thirty is incredibly exciting and creative and with any luck you can make a career out of it anything that gets invented after you’re thirty is against the natural order of things and the beginning of the end of civilization as we know it until it’s been around for about ten years when it gradually turns out to be alright really. Why Vivaldi will never create ThinkCoin When you strip away the hype, these virtual currencies have very real repercussions for people, society, and the environment. By creating our own cryptocurrency or supporting cryptocurrency-related features in the browser, we would be helping our users to participate in what is at best a gamble and at worst a scam. It would be unethical, plain and simple.","categories":[],"tags":[]},{"title":"视频编辑 (FFmpeg DaVinci)","slug":"2022-04-09-视频编辑-(FFmpeg-DaVinci)","date":"2022-04-09T04:00:00.000Z","updated":"2022-04-09T05:42:02.727Z","comments":true,"path":"2022-04-09-视频编辑-(FFmpeg-DaVinci)/","link":"","permalink":"http://yao-lirong.github.io/2022-04-09-%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%91-(FFmpeg-DaVinci)/","excerpt":"主要记录 FFmpeg 和 DaVinci 的常见用法","text":"主要记录 FFmpeg 和 DaVinci 的常见用法 FFmpeg FFmpeg 合并 flv: 12for f in *.flv; do echo &quot;file &#x27;$f&#x27;&quot; &gt;&gt; mylist.txt; doneffmpeg -f concat -i mylist.txt -c copy output.flv 更详细的官方文档在这里。具体地来看，我们这里用的是 concat demuxer, 这项协议支持不同的容器格式，甚至是本身不支持 concat 操作的容器格式的合并 (参考 stackoverflow 答案) FFmpeg 转换格式: 12345# stream copy all streamsffmpeg -i input -map 0 -c copy output.mp4 # re-encode the video to H.264 and stream copy the audioffmpeg -i input.ts -c:v libx264 -c:a copy output.mp4 FFmpeg 批处理转换格式: 12345#!/bin/bashfor i in *.avi;do ffmpeg -i &quot;$i&quot; -c:v libx265 -c:a copy X265_&quot;$i&quot;done Extract Audio from Video 1ffmpeg -i input.mp4 -vn -acodec copy output-audio.aac FFmpeg查看媒体信息: 使用 ffprobe DaVinci Import and Bake Subtitles in DaVinci","categories":[],"tags":[]},{"title":"2021 网络日志","slug":"2021-12-31-2021-网络日志","date":"2021-12-31T05:00:00.000Z","updated":"2022-04-09T05:57:08.583Z","comments":true,"path":"2021-12-31-2021-网络日志/","link":"","permalink":"http://yao-lirong.github.io/2021-12-31-2021-%E7%BD%91%E7%BB%9C%E6%97%A5%E5%BF%97/","excerpt":"开始学习阮一峰记录自己看到的有意思的文章和收集有用的工具的第一个整年","text":"开始学习阮一峰记录自己看到的有意思的文章和收集有用的工具的第一个整年 工具的使用 VScode根据不同语言设置不同tab代表的空格个数 在LINUX系统下使用SSH登陆上路由器: 注意可以使用flagfox看一眼路由器的IP address到底是什么，username就是登陆路由器使用的用户名，如果两个都填写正确是不会出现 “port XX refused connection”这种情况的 1ssh &lt;username&gt;@&lt;IP_address&gt; 批量合成bilibili的m4s缓存文件为MP4格式 禁用Windows Terminal多行粘贴的警告 apt vs apt-get: 简单来说，apt是更新的集合版的 apt-get，应该尽量使用 apt 为日文文档添加振り仮名的word宏 CodeBlocks 运行问题解决: ld.exe: cannot open output file … : Permission denied Convert HTML back to Markdown with Pandoc: pandoc -f html --wrap=none -t markdown -o test.md &lt;filename&gt;. Experiment with --wrap=none/preserve/auto to choose the best. Github 今年对于 Windows 变为强制需要 token，且只有 HTTPS 才能使用 Token Capture Group in Regex: When matching a pattern, use parenthesis (some_pattern_you_try_to_match) to define a capture group. (Two references: succinct, more detailed) Zotero 在论文对应原始网页直接使用浏览器插件获取的信息最全，如果没有对这么全面的信息的要求，可以在 Google Scholar 页面选择 Cite -&gt; Refman (Refman 比 Endnote 格式获取信息更多一些) 涨技术知识 The intuition behind Shannon’s Entropy BT术语的解释 协议混乱的 USB-C What is SSH Port Forwarding and how does it work: 图示写的特别好 混迹于互联网 大眼仔旭, 落尘之木, 423down Adobe 大神破解版 by vposy, 天极下载 PC 软件历史版本, apkdownload(比 apkpure 全) 伊朗PC软件破解, from 胡萝卜周 网站推荐 折腾 Pot+LAV+madVR配置教程: 使用 Icaros 显示多种视频文件缩略图 禁用Win10自动更新:configure automatic updates 板块 Disable Firefox Auto-Update: Go to about:policies to check flags that could be set. Create a policies.json, create a directory called distribution where the EXE is located, and place the json file there on Windows. 在五种不同系统上部署Rime并同步 Web Annotation Tools: diigo: 超了最高容量了 weava: 正在用 beanote: 可以试试，记录保存在本地，无云端服务 additor, Hypothesis: 重点并不在自己的服务保存，而是在协作，想等他们一阵子看看发展效果，结果最近又用了一次还是不好用 值得纪念的新闻 优秀的付费新闻资讯：FT中文网，财新网，财经网， 能处的日本新闻：日本经济新闻, 朝日新闻, 赞叹｜锤子手机未必最好，但他们的设计师都值得致敬 （现在的社会）不是为了人的发展，而是人为了这些东西而发展，反过来了。这些钢筋水泥，一些数据华丽的办公楼，一些冰冷的没有什么价值的东西，已经成为了人追求的全部了。 – “躺平学大师”：一个好的社会是可上可下的","categories":[],"tags":[]},{"title":"Intro to SQL","slug":"2021-09-16-Intro-to-SQL","date":"2021-09-16T04:00:00.000Z","updated":"2021-09-20T23:39:28.509Z","comments":true,"path":"2021-09-16-Intro-to-SQL/","link":"","permalink":"http://yao-lirong.github.io/2021-09-16-Intro-to-SQL/","excerpt":"提交实习申请后发来个小测验，给我做崩溃了，第一个要我做这种级别的SQL，我最多也就会个 select from where，超纲过于严重，只能回头补习","text":"提交实习申请后发来个小测验，给我做崩溃了，第一个要我做这种级别的SQL，我最多也就会个 select from where，超纲过于严重，只能回头补习 Data Type 名称 类型 说明 INT 整型 4字节整数类型，范围约+/-21亿 BIGINT 长整型 8字节整数类型，范围约+/-922亿亿 REAL 浮点型 4字节浮点数，范围约+/-1038 DOUBLE 浮点型 8字节浮点数，范围约+/-10308 DECIMAL(M,N) 高精度小数 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算 CHAR(N) 定长字符串 存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串 VARCHAR(N) 变长字符串 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串 BOOLEAN 布尔类型 存储True或者False DATE 日期类型 存储日期，例如，2018-06-22 TIME 时间类型 存储时间，例如，12:20:59 DATETIME 日期和时间类型 存储日期+时间，例如，2018-06-22 12:20:59 Table Constraints Constraint Description PRIMARY KEY This means that the values in this column are unique, and each value can be used to identify a single row in this table. AUTOINCREMENT For integer values, this means that the value is automatically filled in and incremented with each row insertion. Not supported in all databases. UNIQUE This means that the values in this column have to be unique, so you can’t insert another row with the same value in this column as another row in the table. Differs from the PRIMARY KEY in that it doesn’t have to be a key for a row in the table. NOT NULL This means that the inserted value can not be NULL. CHECK (expression) This allows you to run a more complex expression to test whether the values inserted are valid. For example, you can check that values are positive, or greater than a specific size, or start with a certain prefix, etc. FOREIGN KEY This is a consistency check which ensures that each value in this column corresponds to another value in a column in another table. For example, if there are two tables, one listing all Employees by ID, and another listing their payroll information, the FOREIGN KEY can ensure that every row in the payroll table corresponds to a valid employee in the master Employee list. Table StructureForeign KeyA foreign key is a field (or collection of fields) in one table, that refers to the primary key in another table. The foreign key constraint prevents invalid data from being inserted into the foreign key column, because it has to be one of the values contained in the parent table. 1234ALTER TABLE students ADD CONSTRAINT fk_class_id -- name the constraintFOREIGN KEY (class_id) -- use class_id column in students as FKREFERENCES classes (id); -- links to id in table classes Deleting the constraint won’t delete the column used as FK. 12ALTER TABLE studentsDROP FOREIGN KEY fk_class_id; IndexingWe can index frequently accessed columns to speed up querying. Indexes are based on hash, so the more spread out the data in index columns are, the better indexing performs. 索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如gender列，大约一半的记录值是M，另一半是F，因此，对该列创建索引就没有意义。 12345ALTER TABLE studentsADD INDEX idx_score (score); -- indexing named as idx_score; it indexes column score ALTER TABLE studentsADD INDEX idx_name_score (name, score); -- create a two-column indexing of name and score UniqueAdd a UNIQUE constraint to make sure the uniqueness of student’s name (Assume no two students have the same name). 12ALTER TABLE studentsADD CONSTRAINT uni_name UNIQUE (name); Querying Table注意字符串用的都是单引号 &#39; &#39;. Conditionals =: equal &lt;&gt;: not equal LIKE: case insensitive exact string comparison; % is wildcard. &#39;ab%&#39; matches ‘ab’，’abc’，’abcd’ _ is “appeared once”. LIKE &quot;ab_&quot; matches “abc”, but not “ab” or “abcd” BETWEEN … AND …: number is within range of two values (inclusive). e.g. col_name BETWEEN 1.5 AND 10.5 IN (…): number exists in a list. e.g. col_name IN (2, 4, 6) NOT …: to negate a predicate 12345678-- sometimes we don&#x27;t need FROM-- this is usually used to test connection to data baseSELECT 1SELECT 100 + 200SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender = &#x27;M&#x27;;SELECT * FROM students WHERE (NOT class_id &lt;&gt; 2) AND score LIKE &#x27;8%&#x27; ; Projections12-- rename column score as pointsSELECT id, score points, name FROM students; OrdersQuery results are usually ordered by PK. If we want to change the order, we can 1234567891011-- order by score (default in ascending order 正序)SELECT id, name, score FROM students ORDER BY score;-- order by score and gender (descending score and ascending id)SELECT id, name, score FROM students ORDER BY score DESC, id;-- together with WHERESELECT id, name, gender, scoreFROM studentsWHERE class_id = 1ORDER BY score DESC; Partial ResultsQuery result is sometimes in huge amount. In this case, we only want to show part of the result. 1234567-- show only 3 resultSELECT id, name, gender, score FROM students ORDER BY score DESCLIMIT 3;-- show only 3 result, starting from the 7th.SELECT id, name, gender, score FROM students ORDER BY score DESCLIMIT 3 OFFSET 6; Groups12345-- return #records in TABLE students, and name it numSELECT COUNT(*) num FROM students;-- return #records whose gender is &#x27;M&#x27;, and name the result &quot;boys&quot;SELECT COUNT(*) boys FROM students WHERE gender = &#x27;M&#x27;; 和 COUNT 类似的还有以下函数： 函数 说明 SUM 计算某一列的合计值，该列必须为数值类型 AVG 计算某一列的平均值，该列必须为数值类型 MAX 计算某一列的最大值，如果是字符串类型则返回排序最后的字符 MIN 计算某一列的最小值，如果是字符串类型则返回排序最前的字符 其中，如果 WHERE 条件没有匹配到任何行，COUNT()会返回0，而SUM()、AVG()、MAX()和MIN()会返回NULL。 分完组后，我们不能再用 WHERE 对组进行筛选，以组为级别进行筛选需要 HAVING. 12345678910111213-- 按照 class_id 分组(class_id=1, 2, 3, ... 各一组)， 分别返回每一组的总记录数SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;-- 分完组后，SELECT class_id, COUNT(*) num FROM students GROUP BY class_id HAVING COUNT(*) &gt; 36;-- 对于像 name 这种在一个组内并不是相同的值，会返回 NULL / 报错-- 因此对于聚合查询，我们只能放入聚合查询的 col 名或者一些其他的聚合函数SELECT name, class_id, COUNT(*) num FROM students GROUP BY class_id;-- 查询每个班级男女分别的平均分SELECT class_id, gender, AVG(score) FROM students GROUP BY gender, class_id ORDER BY class_id, gender; Multiple TablesWhen you select from more than one table, database will return the Cartesian product of the results. 12345SELECT s.id sid, s.name, s.gender, s.score, c.id cid, c.name cnameFROM students s, classes cWHERE s.gender = &#x27;M&#x27; AND c.id = 1; Join与前文的 Multiple Tables 不同的是，Multiple Tables 把所有结果先调出来再根据结果进行筛选，效率很慢；而我们的 JOIN 可以 INNER JOIN只返回同时存在于两张表的行数据。比如students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件s.class_id = c.id返回的结果集仅包含1，2，3。 RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。 LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加class_id=5，由于classes表并不存在id=5的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的class_name是NULL： FULL OUTER JOIN，它会把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL： 12345678-- Join 指令模板SELECT ... FROM tableA ??? JOIN tableB ON tableA.column1 = tableB.column2;-- 上文使用的例子对应的指令SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.scoreFROM students sFULL OUTER JOIN classes cON s.class_id = c.id; NullAn alternative to NULL values in your database is to have data-type appropriate default values, like 0 for numerical data, empty strings for text data, etc. But if your database needs to store incomplete data, then NULL values can be appropriate if the default values will skew later analysis (for example, when taking averages of numerical data). 123-- select all non-null valuesSELECT column, another_column, … FROM mytableWHERE column_name IS/IS NOT NULL Operating on RowsInsertWhen we insert something into the table, we don’t have to specify value of the primary key column. Because the primary key is automatically calculated by the database. 12345678INSERT INTO table_name (col1, col2, ...) VALUES (v1, v2, ...) (v1, v2, ...);INSERT INTO students (class_id, name, gender, score) VALUES (1, &#x27;大宝&#x27;, &#x27;M&#x27;, 87), (2, &#x27;二宝&#x27;, &#x27;M&#x27;, 81); UpdateWe can update a record in the table. 1234567891011UPDATE table_name SET col1=v1, col2=v2, ... WHERE ...;-- update a single recordUPDATE students SET name=&#x27;大牛&#x27;, score=66 WHERE id=1;-- update multiple recordsUPDATE students SET name=&#x27;小牛&#x27;, score=77 WHERE id&gt;=5 AND id&lt;=7;-- add 10 points to all scores below 80UPDATE students SET score=score+10 WHERE score&lt;80; Delete1234DELETE FROM table_name WHERE ...;-- delete multiple records DELETE FROM students WHERE id&gt;=5 AND id&lt;=7; Operating on TableCreate Table1234567891011121314CREATE TABLE IF NOT EXISTS table_name ( column_name *DataType* *TableConstraint* DEFAULT *default_value*, another_column_name *DataType* *TableConstraint* DEFAULT *default_value*, … );Movies table schemaCREATE TABLE movies ( id INTEGER PRIMARY KEY, title TEXT, director TEXT, year INTEGER); Alter Table1234567891011-- add a column to tableALTER TABLE mytable ADD column *DataType* *OptionalTableConstraint* DEFAULT default_value;-- remove a column from tableALTER TABLE mytableDROP column_to_be_deleted;-- renaming the tableALTER TABLE mytableRENAME TO new_table_name; Delete Table1DROP TABLE IF EXISTS mytable; OthersView12345create view current_demographic_dim(current_demographic_key, current_salary_range, current_age_range)asselect demographic_key, salary_range, age_rangefrom SAMPLES.DEMOGRAPHIC_DIM; 实用SQL语句Reference 廖雪峰的SQL教程 SQLBolt","categories":[],"tags":[]},{"title":"Introduction to C","slug":"2021-08-31-Introduction-to-C","date":"2021-08-31T04:00:00.000Z","updated":"2021-09-27T23:42:12.019Z","comments":true,"path":"2021-08-31-Introduction-to-C/","link":"","permalink":"http://yao-lirong.github.io/2021-08-31-Introduction-to-C/","excerpt":"大概是写这么多年 C(++) 以来第一次正式学 C (虽然其实在康奈尔学过一遍C++)","text":"大概是写这么多年 C(++) 以来第一次正式学 C (虽然其实在康奈尔学过一遍C++) Compiling C Program12345# compile hello.c and name the executable as default (a.out)gcc hello.c# compile hello.c and name the output executable &quot;sayhello&quot;gcc hello.c -o sayhello We usually write return 0, this exit code 0 means EXIT_SUCCESS. Prototype Definition prototype - declare a function (write down its name) definition - define a function (write down its content) .h stand for “header” and it contains prototype of function .c stand for “code” and it contains definition of function Complex &amp; Custom Data Typesstruct12345struct rect_t &#123; int left; ... &#125;; struct rect_t myRect; typedefThe keyword typedef allows a programmer to create a new type. 12struct _rect_t &#123; ... &#125;;typedef struct _rect_t rect_t; Now we can create instance of the new type: (Note how this is different from a struct instance declaration) 123rect_t myRect;myRect.left = 1;... Strings char *strstr(const char *haystack, const char *needle): finds the first occurrence of the substring needle in the string haystack. sprintf(char *str, const char *format, ...): “prints out” formatted output to a string str, but instead of really printing them out, sprintf buffers the output to the string.(sprintf(str, &quot;Pi = %f&quot;, 3.14); will set str to be Pi = 3.14) Dynamic Memory AllocationConsider the following program: 1234int * initArray(int howLarge) &#123; int myArray[howLarge]; for (int i = 0; i &lt; howLarge; i++) myArray[i] = i; return myArray; &#125; We cannot do this because the space allocated to myArray is only inside the scope of initArray and will be freed once we exit this function. So what we want is dynamic memory allocation so the memory will be allocated at a dynamic heap instead of the call stack. 123int *p = malloc(6 * sizeof(int)); // memory allocationp = realloc(p, 12 * sizeof(int)); // re-allocationfree(p); We can then rewrite the above function as: 1234int * initArray(int howLarge) &#123; int *myArray = malloc(howLarge * sizeof(int)); for (int i = 0; i &lt; howLarge; i++) myArray[i] = i; return myArray; &#125; Note the following when you use free: 12345678// you cannot free something on the stackint x = 3; int *p = &amp;x;free(p); // early termination// free can only be used to free address returned by mallocint *p = malloc(4*sizeof(int));p++;free(p); // early termination Debugging C in VSCode Install the extension “GDB Debugger - Beyond” Replace what’s in launch.json - configurations with the following codes: 123456789&quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;by-gdb&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Launch(gdb)&quot;, &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;, &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot; &#125;]","categories":[],"tags":[]},{"title":"更新archer主题 / 迁移Hexo博客","slug":"2021-08-29-更新archer主题--迁移Hexo博客","date":"2021-08-29T04:00:00.000Z","updated":"2021-08-31T21:56:08.304Z","comments":true,"path":"2021-08-29-更新archer主题--迁移Hexo博客/","link":"","permalink":"http://yao-lirong.github.io/2021-08-29-%E6%9B%B4%E6%96%B0archer%E4%B8%BB%E9%A2%98--%E8%BF%81%E7%A7%BBHexo%E5%8D%9A%E5%AE%A2/","excerpt":"重要文件不多，全在下面列出来了，记得把它们迁移好就行","text":"重要文件不多，全在下面列出来了，记得把它们迁移好就行 123456789101112. # 「Hexo 根目录」├── source # 博客源文件├── themes│ └── archer # 「Archer 主题目录」│ ├── source # 渲染用源文件│ ├── assets│ └── favicon.ico # 网站缩略图标│ ├── avatar # 显示人物头像│ ├── intro # 网页头图│ └── _config.yml # Archer 主题配置文件│└── _config.yml # Hexo 配置文件 另外别忘记执行以下命令，安装必要插件 123npm install hexo-generator-json-content --savenpm install hexo-wordcount --savenpm install hexo-generator-feed --save 因为求职季我把 关于页 推特 副标题 还有康米的头图 全换下来了，找完工作了再放上去","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"http://yao-lirong.github.io/tags/Logistics/"}]},{"title":"Install and Configure Aria2 on WSL","slug":"2021-06-28-Install-and-Configure-Aria2-on-Linux","date":"2021-06-28T04:00:00.000Z","updated":"2021-08-29T20:52:58.670Z","comments":true,"path":"2021-06-28-Install-and-Configure-Aria2-on-Linux/","link":"","permalink":"http://yao-lirong.github.io/2021-06-28-Install-and-Configure-Aria2-on-Linux/","excerpt":"","text":"Tutorial Install Aria2c: sudo apt install aria2c and a web-based GUI: AriaNg Create configuration files: 123mkdir ~/.aria2touch ~/.aria2/aria2.session #用于保存日志touch ~/.aria2/aria2.conf #创建配置文件 A template for “aria2.conf” can be downloaded from aria2c.com. You should change the dir field to be download path, change input-file and save-session to be the path of aria2.session. aria2.conf doesn’t support environment variable, so everything is at best written in absolute path. Run Aria2c with this configuration: aria2c --conf-path=/home/&lt;username&gt;/.aria2/aria2.conf. It will remember this as its configuration file and use it to start the service from now on. We can also add argument -D so Aria2c runs as daemon in the background. (Since the aria2c’s default configure file path is in ~/.aria2/, we don’t really need the --conf-path argument; but use it to specify a conf path if you put it somewhere else) 设置 aria2c 开机自动启动：编写脚本 myStartUp.sh 并放入 /etc/init.d/. (Remember to change its privilege to everyone) 12345#!/bin/bash#Short-Description: My Startup Servicesaria2c -D --conf-path=/home/&lt;username&gt;/.aria2/aria2.conf More on Start Service on WSL startup, refer to this answer CautionOn WSL, when you start aria2 service the first time, note: (full command means the above command with --conf-path, but since our conf path is the same as default path, we can take ) use the full command aria2c --conf-path=/home/&lt;username&gt;/.aria2/aria2.conf and don’t start it in the background with -D. start it immediately after Windows is booted, before you open anything else or tweak anything Anything else than this full command or use this full command some time after Windows boot could cause problem. The problem is showing “Exception: [SocketCore.cc:312] errorCode=1 Failed to bind a socket, cause: Permission denied” even though no process is using port 6800. The reason for this problem is not clear. After staring aria2 once with the full command, we can shut it down and then start it in the background with aria2c -D --conf-path=/home/&lt;username&gt;/.config/aria2/aria2.conf. Now everything will work fine. Reference Linux中配置Aria2 RPC Server linux设置开机自启动 WSL 服务自动启动的正确方法","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"http://yao-lirong.github.io/tags/Logistics/"},{"name":"Linux","slug":"Linux","permalink":"http://yao-lirong.github.io/tags/Linux/"}]},{"title":"On Intelligence","slug":"2021-06-23-On-Intelligence","date":"2021-06-23T04:00:00.000Z","updated":"2021-08-29T20:52:51.031Z","comments":true,"path":"2021-06-23-On-Intelligence/","link":"","permalink":"http://yao-lirong.github.io/2021-06-23-On-Intelligence/","excerpt":"Complexity is a symptom of confusion, not a cause.","text":"Complexity is a symptom of confusion, not a cause. 1 Artificial Intelligence 计算机学界的主流观点：不需要学习大脑 此观点的起始：Turing Test，即让人们认为它是智能，产生 intelligent behavior 更重要 the Chinese Room: 在中文屋中智能没有产生，作者认为 Understanding cannot be measured by external behavior; it is instead an internal metric of how the brain remembers things and uses its memories to make predictions. 但绝大多数的所谓”AI”和这里的中文屋和这一定义无任何相似之处 2 Neural Networks一些可能已经过时的观点： Neural Network 没有考虑 feedback 和 time changing inputs Cognitive Scientist 虽然想记录大脑中的 feedback，但是迫于现有技术(fMRI)只能记录脑内活动的位置，无法记录连续的变化 3 The Human Brain Mind is the creation of the cells in the brain. The cortex is extremely flexible and that the inputs to the brain are just patterns. It doesn’t matter where the patterns come from; as long as they correlate over time in consistent ways, the brain can make sense of them. Function Hierarchy: 脑的每个功能部分都被划为 hierarchy，以输入的视觉为例 V1 (primary sensory areas): rawest, most basic level V2, V4, IT: concerned with more specialized or more abstract aspects association area: receive inputs from more than one sense 虽然是一个 hierarchy，但是实际上当我们从低层走向高层的过程中，information always flows in the opposite direction as well, and with more projections feeding back down the hierarchy than up. Uniformity of Cortex Parts: Mountcastle found that parts of cortex performing different function is very similar in appearance and structure. From there, he argues that all regions of the cortex are performing the same operation. The thing that makes the vision area visual and the motor area motoric is how the regions of cortex are connected to each other and to other parts of the central nervous system. Plasticity of Cortex: 我们发现如果大脑某个部分损坏，另一个部分可以接管它原先的人物，这佐证了 Mountcastle 的观点。另有一个 Thought Experiment：假设我们的大脑并不具有如此的可塑性，那么这就意味着我们的某个大脑部位是专门用来学习中文汉字的，但是对于生物进化来说，汉字进化地太快了，大脑根本不可能适应地这么快（或者外国人也可以迅速学中文亦能佐证这一观点） Similarity of Inputs into Brain: 不管视觉听觉还是什么输入，真正进了人体都是 Action Potentials. They are all the same - just patterns. 也用来佐证 Mountcastle 的观点。There are spatial and and temporal patterns: Spatial Patterns: coincident patterns in time; they are created when multiple receptors in the same sense organ are stimulated simultaneously Temporal Patterns: patterns entering your sensory organs are constantly changing over time 进一步给出了关于以上两点的例子：认为同时做出反应的假手是自己的手 / 镜头连舌头上的压感接收器，用舌头看东西 4 Memory 驳斥人脑比计算机更快，计算力更高 -&gt; 人脑能做到比计算机快是因为运行原理根本不同 -&gt; 引出本章主旨: the brain doesn’t “compute” the answers to problems; it retrieves the answers from memory. Four attributes of neocortical memory that are fundamentally different from computer memory: The neocortex stores sequences of patterns -&gt; predictions of future events The neocortex recalls patterns auto-associatively -&gt; recall memories appropriate for prediction The neocortex stores patterns in an invariant form -&gt; apply knowledge of past to new situations that are similar but not identical The neocortex stores patterns in a hierarchy. 接下来我们将详细介绍前三个特征并在第6章介绍最后一个特征 “阶层” Sequential Pattern: story is stored in your head in a sequential fashion and can only be recalled in the same sequence. You can’t remember the entire story at once. 一个有趣的观点: Truly random thoughts don’t exist. Memory recall almost always follows a pathway of association. Self-Associativity: The memory system can recall complete patterns when given only partial or distorted inputs. This is a result of Hebbian Learning: Firing together Wires together, so when only a part of the cell is activated, the whole group of cells will be activated. Invariant Representation: 人脑不是CD或硬盘，we don’t remember or recall things with complete fidelity. Instead, the brain remembers the important relationships in the world, independent of the details. 我们常用视觉来举例子：some set of the cells in the face recognition area remain active as long as your friend’s face is anywhere in your field of vision, regardless of its size, position, orientation, scale, and expression. This stability of cell firing is an invariant representation. 小引子导入下一章：下一章的主旨是人脑的主要功能就是 make predictions using memories，but given that the cortex stores invariant information, how can it make specific predictions? It combines knowledge of the invariant structure with the most recent details. 5 A New Framework of Intelligence Prediction is not just one of the things your brain does. It is the primary function of the neocortex, and the foundation of intelligence. The cortex is an organ of prediction. 这是作者本书中最基本的观点，也就是他所说的新的智能框架 (Memory-Prediction Framework of Intelligence) 。具体地来解释 Prediction 这个概念：Your brain makes low-level sensory predictions about what it expects to see, hear, and feel at every given moment, and it does so in parallel. All regions of your neocortex are simultaneously trying to predict what their next experience will be. “Prediction” means that the neurons involved in sensing your door become active in advance of them actually receiving sensory input. When the sensory input does arrive, it is compared with what was expected. Correct predictions result in understanding. Incorrect predictions result in confusion and prompt you to pay attention. 不局限于 sensory input，motor output 在我们的大脑中也是和 sensory input一样的 pattern, so neocortex can also remembers what behavior (pattern) leads to what sensory input (patter) and we can direct behavior to satisfy its predictions. 作者举了很多关于 prediction 的例子（预知乐曲的旋律，朋友的样子，你妈下一句话会说什么…）其中最有意思的例子应该是 “filling in”，即我们原来了解过的人脑的 “自动补全” 功能：人眼虽然有盲点但我们视觉没有盲点，自动将三个角补全成三角形，描绘出被树遮挡的大楼的样子，等等。Your visual cortex is drawing on memories of similar patterns and is making a continuous stream of predictions that fill in for any missing input. Behavior Cortex Intelligence 之间到底是个什么关系？ 从进化历程来看，cortex 起到什么作用？我们为什么要进化出 Cortex: in the beginning, the cortex served to make more efficient use of existing behaviors, not to create entirely new behaviors. 但是后来在进化过程中有了 new behavior？ Reptile: Keen senses and well-developed brains endowed them with complex behavior, but relatively rigid Mammals: Neocortex covering the old brain (reptile brain) Now sensory patterns are simultaneously fed into the neocortex and the old brain. The recalled memory is compared with the sensory input stream. It both “fills in” the current input and predicts what will be seen next. Humans: large front part of cortex for high-level planning and thought, so it could store more sophisticated types of memories and make predictions based on complex relationships motor cortex makes more connections with our muscles so cortex usurps motor control from other parts of the brain (old brain) and now the cortex can direct behavior to satisfy its predictions. 本部分也反驳了第一章中所谓的人工智能学者的 behavior determines intelligence 观点：早在 reptile 时期，动物就有了生存本能的 behavior，但是直到 cortex 出现，它们才有了 intelligence。而 cortex 的核心功能就是 prediction. To make predictions of future events, your neocortex has to store sequences of patterns. To recall the appropriate memories, it has to retrieve patterns by their similarity to past patterns (auto-associative recall). And, finally, memories have to be stored in an invariant form so that the knowledge of past events can be applied to new situations that are similar but not identical to the past. How the physical cortex accomplishes these tasks, plus a fuller exploration of its hierarchy, is the subject of the next chapter. 6 How the Cortex Works invariant representation: Light receptors in retina concentrate in fovea and sparse out in periphery, so retinal image relayed onto V1 is highly distorted. However, we don’t perceive any retinal pattern change at all. This is a result of invariant representation. In the course of spanning four cortical stages from retina to IT: cells in retina and V2 are rapidly changing, spatially specific, tiny-feature recognition cells. When we go to IT region, something magical happens and the cells become constantly firing, spatially nonspecific, object recognition cells. (They now fire when seeing a face, no matter it’s on the left or on the right) Integrating the Senses: 我们到现在为止都是讨论同一类型输入预测同一类型结果，实际上 association area 使得我们也可以预测其他类型的结果，比如视觉输入用来预测听觉，嗅觉等等的结果，亦可以用来指导动作 A New View of V1: 前文的模型有两个问题：仅当到了 IT 这一层时，我们奇迹般地获得了 invariant representation；大脑中大部分区域都是像 association area 一样得到多个输入，但我们的模型中好像 V2 只有 V1 一个输入，V4 只有 V2 一个。 To answer these questions, we propose a new model: V1, V2, V4 are not single cortical regions. Rather, each is a collection of many smaller subregions. V1 has largest number of little cortical areas. V2 has fewer, but larger subregions, each connecting to a number of V1’s subregions. Same for V4 and we have a single IT which has a bird’s eye view of the entire visual world. Now the job of any cortical region is to find out how its inputs are related, to memorize the sequence of correlations between them, and to use this memory to predict how the inputs will behave in the future. We can say each region of cortex forms invariant representation drawn from the input areas hierarchically below it. A Model of the World: 作者认为世界中 Every object is composed of a collection of smaller objects, and most objects are part of larger objects. In an analogous way, memories are stored in the hierarchical structure of the cortex. Time really matters and information flowing into the brain arrives as a sequence of patterns. 对于每个 cortical region，它识别出来这个 sequence，将其抽象成一个 name - a constant pattern of cell firing，并将这个名字发给他的上级。所以我们也可以说大脑存储的是 Sequence of Sequences. By collapsing predictable sequences into “named objects” at each region in our hierarchy, we achieve more and more stability the higher we go. This creates invariant representations. Sequences of Sequences: Two processes are at the essence of learning. Assume we are sorting out colored papers. bottom-up classification: deciding what color this paper is top-down sequence recognition: deciding which sequence are we reading in Notice these two processes help each other. 1. If you know the most likely sequence for this series of inputs, you will use this knowledge to decide how to classify the ambiguous input. 2. recognizing any sequence would be impossible if you hadn’t first classified each piece of paper. When we have finally recognized a color sequence, say “red red blue green”, we just pass this name to the next higher region; just like the colors to this region, the name is just a pattern to be combined with other inputs, classified, and then put into yet a higher-order sequence. The next higher up region doesn’t have to know what it means. What a Region of Cortex Looks Like: 我们说过每个 cortical region 有六层 (six layers 从上到下分别为 L1, L2, …, L6 不要跟视觉的 V1 V4 搞混) 但我们一般不把每一层看做人脑的基本单位，而是把 columns running perpendicular to the layer 看做 basic unit of computation in the cortex. 作者认为它是 basic unit of prediction. 我们接下来讨论 How cortical regions communicate with each other 共有三种方法： Upward Flow: Converge inputs from lower regions goes to the input layer of the next region through axons Downward Flow: Axons in layer 1 spread over long distances, so information flowing down the hierarchy from one column has the potential to activate many columns in the regions below it. Lateral Flow: L1 给 L4,5 发指令运动，L4,5 收到指令的同时，不仅向下给肌肉发放运动信号，也把这个消息告诉 thalamus，thalamus 过一会后会把这个消息重新传回给 L1。其中 thalamus 收到来自许多不同 L4, L5 的信息，然后再把这些信息一起返回给所有 L1 ，这样本 column 就知道知道周围其他人现在收到的信息。Column not only knows the sequence name (downward flow from above), but also where we are within the sequence (activity from other columns) How a Region of Cortex Works - The Details: How does a cortical region classifies inputs? It’s too complicated, we assume it does How does it learn sequences of patterns? Input from lower region -&gt; layer 4 fires -&gt; layers 2,3,5 fire -&gt; layer 1 fires to tell the region up some input has come. Fire together Wire together, so 2,3,5,1 wire together. 2,3,5 now can fire without a layer 4 input, so they learn to “anticipate” when they should fire based on firing of 1. Half of input to layer 1 comes from layer 5 in neighboring columns. This information represents what was happening moments before. It represents columns that were active prior to your column becoming active. The other half of the input to layer 1 comes from layer 6 cells in hierarchically higher regions. This information is more stationary. It represents the name of the sequence you are currently experiencing. Combining these two information, a prediction/sequence is formed. How does it form a constant “name” for a sequence? constant names = constant input to the next region during learned sequences = need to turn off the output of the layer 2 and layer 3 cells when a column predicts its activity, or, alternately, to make these cells active when the column can’t predict its activity. Layer 2 cell represent the name of the sequence and they stay on when we are within the sequence. Layer 3b cell represents don’t fire when our column successfully predicts its input but do fire when it doesn’t predict its activity. How does it make specific predictions? If you expect a fifth (prediction / invariant representation) and hear a D (specific input). In layer 2 we fire all intervals of fifth. In layer 4 we fire all intervals starting with D. The intersection between the two is our specific prediction. Flowing Up and Flowing Down: 上层给下层 prediction 当下层得到的输入与 prediction 不符 (unexpected)，我们将此特征传导给更上一层，直到 some higher region can interpret it as part of its normal sequence of events. That higher region generates a new prediction and propagates it down Can Feedback Really Do that? Feedback synapses are all far away from cell’s body, so it’s doubted whether the feedback currents can really make a difference. 但是新研究发现离得远的 synapse 可能有其他特殊的效果（并不确切证实） How the Cortex Learns: 比如我们有1,2,3层，一开始单个文字在第3层，随着我们持续学习和不断练习单个文字移到了第2层，相对的，我们在第3层习得短语这个 pattern。This ensures that we free up the top for learning more subtle, more complex relationships. 这也是我们变得更熟练的原因。 The Hippocampus: 我们常认为海马体是生成新记忆的中心，在作者的模型中，Hippocampus is the top region of neocortex. 我们刚刚说 unexpected input 被传输给上层，so if something gets to the top of the cortical pyramid, it is the information that can’t be understood by previous experience, the input that is truly new and unexpected. That’s what stored in Hippocampus, but it won’t be stored forever. It’s either transferred down to the cortex (长期记忆) or eventually lost (遗忘) 所谓人在壮中年时对”新事物”的记忆没有那么好实际上是因为这些”新”的东西实际上早已在以前的生活中出现过，所以人对第一次记忆特别深刻，对之后的类似事物就没那么好记性。（它竟然和 How the Cortex Learns 这很扯的一节联起来了） An Alternative Path up the Hierarchy: 这里要介绍的是从 Layer5 -&gt; thalamus 的路径。这条路径可开可关，它要么被上层激活打开，要么被下层的 unexpected input 激活。我们认为这条路径代表注意力，两种开启方式分别对应主动关注(pay attention)，以及因为奇怪的现象而被动关注 (attention is caught) Closing Thoughts: 分享了作者从零想结构写代码最后竟然能跑的例子，但是相对的如果别人只给你看一堆代码结构规划，你可能会怀疑这东西到底能不能跑，类比到脑结构中，怀疑的原因是 it is because our intuitive sense of the capacity of the cortex and the power of its hierarchical structure is inadequate. 7 Consciousness and Creativity Animals and Human Intelligence: Memory and Prediction are the core of “Intelligence” and they are used by all livings. There is just a continuum of methods and sophistication in how they do it. One-cell animal: They used DNA as the medium for memory. Individuals could not learn and adapt within their lifetimes. They could only pass on the DNA-based memory of the world to their offspring through their genes. Modifiable Nervous System: An individual could now learn about the structure of its world and adapt its behavior accordingly within its lifetime. But an individual still could not communicate this knowledge to its offspring other than by direct observation. Neocortex was also created at this time. Human Intelligence: It begins with the invention of language and the expansion of our large neocortex. The more important is language. We humans can learn a lot of the structure of the world within our lifetimes, and we can effectively communicate this to many other humans via language. What is Creativity? Recall that we make predictions by combining the invariant memory recall of what should happen next with the details pertaining to this moment in time. All cortical predictions are predictions by analogy. We are being creative when our memory-prediction system operates at a higher level of abstraction, when it makes uncommon predictions, using uncommon analogies. 注意 GEB 中也提到说 analogy 是智慧的核心 What is Consciousness? 有人认为 consciousness/mind 在身体之外，但是实际上它就在脑中。Your thoughts, which are located in the brain, are physically separate from the body and the rest of the world. Mind is independent of body, but not of brain. 8 The Future of Intelligence Because I have been immersed in the neuroscience and computer fields for over two decades, perhaps my brain has built a high-level model of how technological and scientific change occurs, and that model predicts rapid progress. Now is the turning point. General Direction of Intelligent Machine: Our intelligent machine may have a set of senses that differ from a human’s. attachto these senses a hierarchical memory system that works on the same principles as the cortex. We will then have to train the memory system much as we teach children. Over repetitive training sessions, our intelligent machine will build a model of its world as seen through its senses. The intelligent machine must learn via observation of its world. Once our intelligent machine has created a model of its world, it can then see analogies to past experiences, make predictions of future events. 这个智能机器的整体运作方法和大脑相同，但是它并不需要与大脑长得相似或得到和大脑相同的输入，它只需要复合结构的，能够用来作“预测”的输入即可。What makes it intelligent is that it can understand and interact with its world via a hierarchical memory model and can think about its world in a way analogous to how you and I think about our world. Ethical Problems? No. The strongest applications of intelligent machines will be where the human intellect has difficulty, areas in which our senses are inadequate, or in activities we find boring. In general, these activities have little emotional content. In the following areas, Intelligent Machines will exceed we humans: Speed: Transistor switch is much faster than human brain’s electrical signals. Capacity: we can add capacity to machine’s mind by doing the followings (these are also what we do in DL/ML) Adding depth to the hierarchy will lead to deeper understanding: the ability to see higher-order patterns. Enlarging the capacity within regions will allow the machine to remember more details, or perceive with greater acuity. Adding new senses and sensory hierarchies permits the device to construct better models of the world Replicability: we humans learn knowledge and form our own model of the world rather slowly. However, an intelligent machine need not undergo this long learning curve, since chips and other storage can be replicated endlessly and the contents transferred easily. Sensory Systems: Input patterns to the machine don’t have to be analogous to animal senses, or even to derive from the real world at all. In fact, the author suspects that out inability to tackle issue may be related to a mismatch between the human senses and the physical phenomena we want to understand. Intelligent machines can have custom senses moresensitive than our own, or senses that are distributed, or senses for very small phenomena. They might think in three, four, or more dimensions. Appendix: The Thousand Brain TheoryNotes from Microsoft Research - The Thousand Brains Theory by Jeff Hawkins Local Cortical CircuitInside a local cortical circuit, neurons are organized in layers. Most connections go vertically across the layers; limited connections go horizontally within layer. Recent find: all layers have a motor output. So it’s always sensorimotor input, no pure sensory input. Vernon Mountcastle: neocortex is remarkably uniform in appearance and structure because they are actually performing the same basic intrinsic function. A cortical column is the unit of replication. If you understand one of it, you understand the whole brain. Layer 2,3 - object Layer 4 - main input layer Layer 6 - location relative to the object L6 sends information to L4, L4 processes these information with its own other input. Over time it forms a representation of what the object itself is in layer L2,3. On top of that, if we have multiple cortical involved (imagine multiple fingers touching the cup instead of only one), we can instantly build a mental image of the cup by the connections across cortical units happened in L2,3. This is like a voting mechanism where each finger has a guess of its feeling and they settle what the object really is by talking to each other. Building a Reference MapA reference map is the sense of relative location as we are touching the cup Contrast to the classical view, the vast majority of connections between cortical regions are not hieratical at all. Hypothesis: the grid cells in entorhinal cortex also exist in every cortical column of every neocortex region. They don’t create reference frames for location but reference frames for the objects we interact (the cup). In the classical view, we have a hierarchy in our neocortex. The real structure is similar, 但我们并不是 杯柄 -&gt; 杯身 -&gt; 整个杯子 这种真正的阶梯式建模，而是每个“层级”都形成一个自己的杯子模型，这些模型并不相同. This model allows all models to “vote”. Everyone tries to guess what’s going on.","categories":[],"tags":[{"name":"Reading","slug":"Reading","permalink":"http://yao-lirong.github.io/tags/Reading/"}]},{"title":"Introduction to TensorFlow 1.x","slug":"2021-05-28-Introduction-to-TensorFlow-1.x","date":"2021-05-28T04:00:00.000Z","updated":"2021-09-04T22:15:58.360Z","comments":true,"path":"2021-05-28-Introduction-to-TensorFlow-1.x/","link":"","permalink":"http://yao-lirong.github.io/2021-05-28-Introduction-to-TensorFlow-1.x/","excerpt":"海尔实习期间记录下的 TensorFlow 笔记","text":"海尔实习期间记录下的 TensorFlow 笔记 Basic Notion Graph: often refers to Computation Graph, which describes how to compute the output Eager execution: evaluates operations immediately, without building graphs Enabling eager execution changes how TensorFlow operations behave—now they immediately evaluate and return their values to Python. tf.Tensorobjects reference concrete values instead of symbolic handles to nodes in a computational graph. Since there isn’t a computational graph to build and run later in a session, it’s easy to inspect results using print() or a debugger. Evaluating, printing, and checking tensor values does not break the flow for computing gradients. Operation: 图中的节点, takes Tensor object as input, and produces Tensor objects as output Tensor: multi-dimensional arrays with a uniform type (called dtype), 包含一个 n 维的数组或列表. 一个静态类型 rank, 和 一个 shape. It does not hold the values of that operation’s output, but instead provides a means of computing those values. It is a symbolic handle of input/output of Operation. 图上操作间传递的数据都是 Tensor: A Tensor can be passed as an input to another Operation. This builds a dataflow connection between operations, which enables TensorFlow to execute an entire Graph that represents a large, multi-step computation. Session: launch the computation of a graph InteractiveSession: a better graph runner that allows you to compute each operation step by step instead of only giving out the final result, as in Session 12345678910# Build a dataflow graph.a = tf.constant([[1.0, 2.0], [3.0, 4.0]])b = tf.constant([[1.0, 1.0], [0.0, 1.0]])c = tf.matmul(a, b)# Construct a `Session` to execute the graph.sess = tf.compat.v1.Session()# Execute the graph and store the value that `e` represents in `result`.result = sess.run(e) a, b, c are Tensor here. c = tf.matmul(a, b) creates an Operation of type “MatMul” (Matrix Multiplication) that takes tensors a and b as input, and produces c as output. Variable: represent shared, persistent state your program manipulates (parameters of the model) it is a tf.Tensor whose value can be changed by running ops on it Placeholder: a tensor whose value will later be fed. Operations on Tensors tf.reduce_xxx(t, axis=i): If we have a tensor t of dimension $d_1 \\times d_2 \\times … \\times d_n $, apply r = reduce_xxx(t, axis = i), Each entry along axis i will be collapsed into a single entry, so r will have dimension $d_1 \\times d_2 \\times … d_{i-1} \\times d_{i+1} … \\times d_n $: 1234567891011121314151617a=np.random.randint(1,10,(2,3,4))&#x27;&#x27;&#x27;2 arrays of dimension 3 X 4[[[8 5 7 1] [9 7 2 2] [7 7 4 6]] [[7 7 8 4] [7 4 3 6] [5 3 2 8]]]&#x27;&#x27;&#x27;sess = tf.Session()with sess.as_default(): r = (tf.reduce_sum(a, axis=1)).eval() # reduce along axis of length 3&#x27;&#x27;&#x27;[[24 19 13 9] [19 14 13 18]]&#x27;&#x27;&#x27; tf.reshape(t, list): Reorder all the elements in t so that we have a new dimension in r: $d_1’ = list[0], d_2’ = list[1], …$ If we have $d’_i = -1$ as one of the dimension, $d_i’ = \\frac{d_1 \\times d_2 \\times … \\times d_n}{list[0] \\times list[1]\\times…list[i-1]\\times list[i+1] … \\times list[n-1]} $, so 1r = tf.reshape(a, [-1,2,2]).eval() # r will havee shape (6, 2, 2) tf.concat([t1, t2, ...], axis = i): pile all the arrays along axis i. These arrays must have the same length along the other axis. In the result, only the length along axis i will increase, the length of other axis remain the same. tf.tile(t, [m1,m2,...]): multiple axis i with mi, so the result tensor dimension is $(d_1\\times m_1, d_2\\times m_2, …)$ Debug with Tensorboard tf.summary: Follow the official guide tf.estimator: Specify model_dir when initializing your estimator. Everything about the trained model will be stored in this directory, including event files logging training process. Reference Utility Sometimes we encounter module &#39;tensorflow&#39; has no attribute ... because TensorFlow changed/refactored its function name. We can use this list to manually update all changed names or directly use this script.","categories":[],"tags":[]},{"title":"Tsinghua DSA 作业总结 (3)","slug":"2021-02-11-Tsinghua-DSA-作业总结-(3)","date":"2021-02-11T05:00:00.000Z","updated":"2021-02-10T19:55:00.443Z","comments":true,"path":"2021-02-11-Tsinghua-DSA-作业总结-(3)/","link":"","permalink":"http://yao-lirong.github.io/2021-02-11-Tsinghua-DSA-%E4%BD%9C%E4%B8%9A%E6%80%BB%E7%BB%93-(3)/","excerpt":"CST数据结构（2020秋）PA3","text":"CST数据结构（2020秋）PA3 3.1 Not Found算法要找二进制字符串 A 中最短的未出现过的子串 B，我们先考虑一个比较长的子串，其长度为 24。 注意到 A 的长度最长为 16777216 = 2^24。因为还要掐头去尾，所以 A 中长度为 24 的子串的总数必定小于 2^24 个，而长度为 24 的字符串总共有 2^24 种，所以 A 中必定有某个长度为 24 的字符串是不存在的。 我们用 bitmap 边读入，边记录下所有出现过的长为 24 的子串。这个 bitmap 只存长度为 24 的子串，我们叫它 bitmap24。读入完成后，注意到任何一个在 A 中出现的长为 23 的子串必定是某一 24 子串掐头或去尾得到的，于是我们遍历所有在 24 子串，对他们掐头去尾，将得到的两个结果存入 bitmap23 中，如此做直到 bitmap1 存完。 最后我们从长度 24 开始遍历，找到第一个长度 n 使得所有长度为 n 的子串都在 A 中出现了，那么所要找的“最短未出现子串” B 必然有长度 n+1，我们只需要再遍历一遍 bitmap(n+1) 找到第一个不存在的字符串即可 细节 读入字符串的时候当总长度达到 24 以后，我们就要读一个新的弃一个旧的，因为根据题目分析 B 最长也就是 24 一个 int 是 4 byte = 32 bit = 2^5 bit，所以 bitmap24 需要 $2^{24}/2^5 = 2^{19}$ 个 int，bitmap1 … bitmap 5 各自仅需 1个 int 因为我们是将二进制字符串用 int 方式存在 bitmap 中，如果这个字符串有 leading 0s, 它们在输出时会被忽略掉，所以我们需要根据 bitmap-n 这个长度 n 来补全 leading 0s 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;// int_size[i] is the number of ints needed to store all strings of length iconst int int_size[25] = &#123; 1, // there should be no bitmap for string of length 0, // but we give it 1 to make the whole program consistent 1, 1, 1, 1, 1, // 2^1 2^2 2^3 2^4 2^5 each only needs one int 2, 4, 8, 16, 32, // 2^6, ... 10 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288 &#125;;// ones[i] is 2^i - 1const int ones[25] = &#123; 0, 1, 3, 7, 15, 31, 63, 127, 255, 511, //10 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, //20 1048575, 2097151, 4194303, 8388607, 16777215&#125;;// bitmap[i] is the bitmap for binary strings of length iunsigned int *bitmap[25];// make our bitmap contain a binary string x of length nvoid setbit(int n, unsigned int x);// returns true if our bitmap contains a binary string x of length nbool checkbit(int n, unsigned int x);// print a binary string x of length nvoid print_binary(int n, unsigned int x);int main()&#123; for (int i = 0; i &lt;= 24; i++) &#123; bitmap[i] = new unsigned int[int_size[i]]; for (int j = 0; j &lt; int_size[i]; j++) bitmap[i][j] = 0; &#125; // n is the total number of characters we read in // s is the string at our sliding window // c is the character we just read in // input is 0 if c is &#x27;0&#x27;, is 1 if c is &#x27;1&#x27; unsigned int n = 0, s = 0, input = 0; char c = getchar(); n = 1; // read till nothing more to read or the string is 24 char long for (; c!=&#x27;\\n&#x27; &amp;&amp; n&lt;24; c = getchar()) &#123; input = c - &#x27;0&#x27;; s = (s &lt;&lt; 1) | input; n += 1; &#125; // n is the number of characters read in, including the line feed // n-1 is the actual length of s setbit(n-1, s); // we probably halted because n==24, so we read in 24 valid 0 1 characters // If so, there can be more to be read, so we try to read more but keep the string at 24 characters long // skip this loop if the string is finished with a space for (; c!=&#x27;\\n&#x27;; c = getchar()) &#123; input = c - &#x27;0&#x27;; s = (s &lt;&lt; 1) | input; s = s &amp; 0xFFFFFF; // keeps only the first 24 characters setbit(24, s); n += 1; &#125; n -= 1; // n is the number of characters read in, including the line feed // delete 1 to obtain the actual string length // len is the length of answer string // ans is the binary string in int representation // full is true if all the strings of length i is in our bitmap unsigned int len = 0, ans = 0; bool full = false; for (int i = n&gt;24 ? 24 : n; i&gt;0 &amp;&amp; !full; i--) &#123; full = true; // we assume this level is full for (int j = 0; j &lt; ones[i] + 1; j++) &#123; // iterate all strings 0 ~ 2^i if (checkbit(i, j)) &#123; // percolate down to its substring setbit(i - 1, j &gt;&gt; 1); setbit(i - 1, j &amp; ones[i - 1]); &#125; else if (full) &#123; // current substring doesn&#x27;t exist, and all the previous substrings do exist // so this is the FIRST substring that doesn&#x27;t exist ans = j; len = i; full = false; &#125; &#125; &#125; print_binary(len, ans);&#125;void setbit(int n, unsigned int x) &#123; // x%32 就是存储 x 的 bit，即从左向右 x%32 个位置的那个 bit // 但由于计算机中存储数是从右向左存的，我们需要让 1 从右端开始移动 ( 31- x%32 ) 个位置才可以 // 这样我们得到一个第 x%32 为1，其他位为 0 的二进制数，通过 or 与原 bitmap 储值合并 // bitmap[x/32] |= (1&lt;&lt;(31 - x%32)); bitmap[n][x&gt;&gt;5] |= (1&lt;&lt;(31 - x&amp;31));&#125;;bool checkbit(int n, unsigned int x) &#123; // bitmap[x/32] &amp; (1&lt;&lt;(31 - x%32)) is determined solely by the x%32 bit of this int chunk // If that bit is 0, the whole expression is 0 // If that bit is 1, the whole expression is greater than 1 and thus evaluate to true // return bitmap[x/32] &amp; (1&lt;&lt;(31 - x%32)); return bitmap[n][x&gt;&gt;5] &amp; (1&lt;&lt;(31 - x&amp;31));&#125;void print_binary(int n, unsigned int x) &#123; // int 是从右往左存的，且我们只能访问最右边的 least-significant digit // 我们要从左往右打印，只能将从右向左的每个 bit 顺序存起来再倒序打印 int ans[25]; int m = 0; while (x != 0) &#123; ans[m] = x &amp; 1; x = x &gt;&gt; 1; m++; &#125; // 补全 leading 0s for (int i = m; i &lt; n; i++) &#123; ans[i] = 0; &#125; for (int i = n - 1; i &gt;= 0; i--) &#123; printf(&quot;%d&quot;,ans[i]); &#125; printf(&quot;\\n&quot;);&#125; 复杂度分析读入长度为 n 的字符串，耗时 O(n) 如果 n &gt;24 则从 bitmap24 开始遍历，如果 n&lt;=24 则从 bitmap(n) 开始遍历，耗时 $O(2^{min(24,n)})$ 当 n 达到 2^24 级别时，整体复杂度还是 O(n) Reference 用C++实现bitmap 3.3 Kth算法题目要求找出 a,b,c 三个数组对应的三元数对中和为第 k 大的那个三元数对，观察到如果 a,b,c 是有序数对，那么必有 a[i]+b[j]+c[k] &lt; a[i+1]+b[j]+c[k], a[i]+b[j]+c[k] &lt; a[i]+b[j+1]+c[k], a[i]+b[j]+c[k] &lt; a[i]+b[j]+c[k+1]. 于是，我们维护一个优先队列，每次出队 (i,j,k) 就入队 (i+1,j,k) (i,j+1,k) (i,j,k+1)。如此做 k 次，出队的就是我们要找的三元对。我们现在将“找第 k 大”转变成了一个三维图的遍历问题。 实现中要注意的是不能让同一个点多次入队，我们可以开一个 vis 数组，但是每个数组最多有 500000 个元素，三维 vis 数组空间绝对不够。于是我们想一种遍历顺序，使得每个点只被遍历一次。首先考虑最简单的一维，单个的 x 轴，就是不停地遍历下一个而已 i, i+1, i+2, ... ；扩展到二维其实就是多个一维情况，我们通过 (0,j), (1,j), ... (i-1,j) 到达 (i,j) 那我们如何到达 (0,j) 呢？通过 (0,0) 的一维扩张，也就是说，当 x 轴为 0 时，我们既向 x 方向扩张，也向 y 方向扩张，而当 x 轴不为 0 时，我们只向 x 方向扩张。 对于三维情况，想象 x,y,z 正方向为右，前，下。则在任意时刻，我们都向 x 扩张；仅当 x=0 时，我们向 y 方向扩张；仅当 x=0 且 y=0 时，我们向 z 方向扩张。并且由于我们根据优先级选取每一次的扩张边界，我们一定也是优先级最高的先被找到。 细节 Heap 的实现：sink 时首先判断孩子存不存在（孩子坐标与元素总数比较）如果左孩子存在且“右孩子不存在，或左孩子优先级比右孩子高”，则与左孩子互换；如果右孩子存在且右孩子优先级更高，则与右孩子互换 三维的遍历顺序：尝试向 y 方向扩张时，如果 x!=0，跳过此次扩张；尝试向 z 方向扩张时，如果 x!=0 || y!=0，跳过此次扩张 数组的排序：在本题提供接口中，我们无法直接访问数组 a,b,c 中的元素，所以我们自己开另外三个数组 s,u,t 其中 s[i] 表示 a 中第 i 大的元素所对应在 a 中的位置。即 s,u,t 存 1…n， 代表 a,b,c 中的下标。为取得 s，我们使用 sort(s,n) 但比较器用的却是 a 的比较器 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &quot;kth.h&quot;#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int N = 500007, K = 2000003;int dir[3][3] = &#123; &#123;1,0,0&#125;, &#123;0,1,0&#125;, &#123;0,0,1&#125; &#125;;// sort x-axis by only comparing sums along x-axisint sortx_cmp(const void* a, const void* b) &#123; if (compare(*(int*)a, 1, 1, *(int*)b, 1, 1) == 1) return -1; else if (compare(*(int*)b, 1, 1, *(int*)a, 1, 1) == 1) return 1; else return 0;&#125;int sorty_cmp(const void* a, const void* b) &#123; if (compare(1, *(int*)a, 1, 1, *(int*)b, 1) == 1) return -1; else if (compare(1, *(int*)b, 1, 1, *(int*)a, 1) == 1) return 1; else return 0;&#125;int sortz_cmp(const void* a, const void* b) &#123; if (compare(1, 1, *(int*)a, 1, 1, *(int*)b) == 1) return -1; else if (compare(1, 1, *(int*)b, 1, 1, *(int*)a) == 1) return 1; else return 0;&#125;struct triple &#123; int x, y, z; triple() &#123; x = 0; y = 0; z = 0; &#125;; triple(int a, int b, int c) &#123; x = a; y = b; z = c; &#125; triple(const triple&amp; from) &#123; this-&gt;x = from.x; this-&gt;y = from.y; this-&gt;z = from.z; &#125;&#125;;// myPQ is my priority queuetriple myPQ[K*2];const triple INF = triple(10e7, 10e7, 10e7);// a, b, c is the array given in problem int a[N], b[N], c[N];inline bool operator&lt;(const triple&amp; t1, const triple&amp; t2) &#123; return compare(a[t1.x], b[t1.y], c[t1.z], a[t2.x], b[t2.y], c[t2.z]);&#125;inline bool operator&gt;(const triple&amp; t1, const triple&amp; t2) &#123; return compare(a[t2.x], b[t2.y], c[t2.z], a[t1.x], b[t1.y], c[t1.z]);&#125;// refactorred PQ that only uses strictly greater/lesser to be consistent with compare functionclass PriorityQueue &#123; int n = 0; triple* a = myPQ;public: void add(triple x) &#123; a[++n] = x; swim(n); &#125; triple extract() &#123; if (n == 0) throw &quot;Nothing to extract&quot;; triple result = a[1]; swap(a[1], a[n]); a[n--] = INF; sink(1); return result; &#125; bool isEmpty() &#123; return n == 0; &#125; void print() &#123; for (int i = 1; i &lt;= n; i++) &#123; printf(&quot;%d in heap: (%d, %d, %d)\\n&quot;, i, ::a[a[i].x], b[a[i].y], c[a[i].z]); &#125; &#125;private: void swim(int i) &#123; while (i &gt; 1 &amp;&amp; !(a[i / 2] &lt; a[i])) &#123; swap(a[i / 2], a[i]); i = i / 2; &#125; &#125; void sink(int i) &#123; int l = i * 2, r = i * 2 + 1; while ((l &lt;= n &amp;&amp; !(a[i] &lt; a[l])) || (r &lt;= n &amp;&amp; !(a[i] &lt; a[r]))) &#123; if (l &lt;= n &amp;&amp; (r &gt; n || !(a[l] &gt; a[r]))) &#123; // l is in the heap and (r is not in the heap, or l is the better choice compared to r) swap(a[i], a[l]); i = l; l = i * 2; r = i * 2 + 1; continue; &#125; else if (a[l] &gt; a[r] &amp;&amp; r &lt;= n) &#123; swap(a[i], a[r]); i = r; l = i * 2; r = i * 2 + 1; continue; &#125; else return; &#125; &#125;&#125;;void get_kth(int n, int k, int *x, int *y, int *z) &#123; for (int i = 0; i &lt;= n; i++) &#123; a[i] = b[i] = c[i] = i; &#125; qsort(a+1, n, sizeof(int), sortx_cmp); qsort(b+1, n, sizeof(int), sorty_cmp); qsort(c+1, n, sizeof(int), sortz_cmp); PriorityQueue q; q.add(triple(1, 1, 1)); for (int i = 1; i &lt; k; i++) &#123; // extract k-1 triples triple now = q.extract(); int nowx = now.x, nowy = now.y, nowz = now.z; for (int j = 0; j &lt; 3; j++) &#123; int nextx = nowx + dir[j][0], nexty = nowy + dir[j][1], nextz = nowz + dir[j][2]; if (nextx &gt; n || nexty &gt; n || nextz &gt; n) continue; if ((j == 1 &amp;&amp; nowx != 1) || (j == 2 &amp;&amp; (nowx != 1 || nowy != 1))) continue; q.add(triple(nextx, nexty, nextz)); &#125; &#125; triple result = q.extract(); *x = a[result.x]; *y = b[result.y]; *z = c[result.z];&#125; 复杂度分析共有三个数组，一个数组中有 n 个元素，找大小为 k 对的三元数对。首先对三个数组进行排序 O(nlogn)，每有一个数对出优先队列，就有最多三个入优先队列，共操作 k 次，每次操作 O(logk)，总共 O(klogk)。总时间 O(nlogn + klogk) 3.4 Component算法堆的合并 左偏树 题目的询问永远是某一联通分量中第 k 大的点的权值，k 是一个常数。第 k 大又可以看做前 k 个最大元素中最小的元素，即如果我们维护一个小根堆，使它恒有 k 个元素（n&lt;k 时输出 -1，n&gt;k 时弹出 n-k 次最小的元素）那么这 k 个元素必然是连通块中前 k 大的元素，堆顶元素就是我们的询问。 当加入的新边 (u,v) 联通两个不曾联通的连通块时，对应的两个堆必须合并。支持快速合并操作的优先队列，我们选择左式堆。(u,v) 将块联通，实际上是将其所在的堆合并起来，我们必须能够高效找到 (u,v) 所属哪个堆，即其所属堆的根是谁，使用并查集存储这个信息。 细节每个节点都有编号，我们不用传统的 class 建优先级队列，而直接用数组存每个点对应的信息，速度更快，访问更方便 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;iomanip&gt;using namespace std;const bool DEBUG = false;const int N = 1000007;int n, m, k, q;// We use a min-heap 小根堆 to store the points// delMax getMax refers to the &quot;max priority&quot; element, which has the smallest value// value[i] is the value of the point i// father[i] is the root of the heap i belongs to// lchild[i], rchild[i] is the left and right child of the point i in heap// npl[i] is the null-path-length of heap i// sze[i] is the size of heap iint value[N], father[N], lchild[N], rchild[N], npl[N], sze[N];// find(i) returns the root of the heap i belongs toinline int find(int x) &#123; return x == father[x] ? x : (father[x] = find(father[x]));&#125;// merge heap b into heap aint merge(int a, int b) &#123; if (a == 0) return b; if (b == 0) return a; if (value[a] &gt; value[b]) swap(a,b); rchild[a] = merge(rchild[a], b); father[rchild[a]] = find(a); if (lchild[a] == 0 || npl[lchild[a]] &lt; npl[rchild[a]]) &#123; int temp = lchild[a]; lchild[a] = rchild[a]; rchild[a] = temp; &#125; npl[a] = rchild[a] == 0 ? 1 : npl[rchild[a]] + 1; sze[a] = sze[lchild[a]] + sze[rchild[a]] + 1; return a;&#125;// getMax(x) returns the value of root of the heap x represents// Requires: x is the root of a heapint getMax(int x) &#123; // x is the root, root is the max, so we just return the value of x return value[x];&#125;// delMax(x) returns the new root after deleting root in heap x// Requires: x is the root of a heapint delMax(int x) &#123; int ans = value[x]; sze[x] -= 1; int new_root = merge(lchild[x], rchild[x]); father[new_root] = new_root; // new root is now a root, so its father is itself father[x] = new_root; // this deleted node, and all the nodes pointing to the deleted node should now point to the new root return ans;&#125;// deletes the Max element until this heap has no more than k elementsvoid prune(int x) &#123; if (sze[x] &lt;= k) return; delMax(find(x)); // needs to find(x) because delMax requires a root prune(find(x)); // after being deleted, x becomes a stranded point // prune must take in the new root of the heap&#125;// print all points and their informationvoid print() &#123; if (!DEBUG) return; cout &lt;&lt; &quot;# value Parent Lchild Rchild npl size &quot; &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; setw(2) &lt;&lt; i; cout &lt;&lt; setw(6) &lt;&lt; value[i]; cout &lt;&lt; setw(6) &lt;&lt; father[i]; cout &lt;&lt; setw(8) &lt;&lt; lchild[i]; cout &lt;&lt; setw(8) &lt;&lt; rchild[i]; cout &lt;&lt; setw(6) &lt;&lt; npl[i]; cout &lt;&lt; setw(6) &lt;&lt; sze[i]; cout &lt;&lt; endl; &#125;&#125;int main() &#123; scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;k, &amp;q); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, value + i); father[i] = i; lchild[i] = rchild[i] = npl[i] = 0; // points to null sze[i] = 1; &#125; sze[0] = 0; npl[0] = 0; father[0] = lchild[0] = rchild[0] = 10e9; for (int i = 1; i &lt;= m; i++) &#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); if (find(a) == find(b)) continue; // already connected, another edge doesn&#x27;t make a difference int merged = merge(find(a), find(b)); prune(merged); &#125; for (int i = 1; i &lt;= q; i++) &#123; int op, a, b; scanf(&quot;%d&quot;, &amp;op); if (op == 1) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); if (find(a) == find(b)) continue; int merged = merge(find(a), find(b)); prune(merged); &#125; else if (op == 2) &#123; scanf(&quot;%d&quot;, &amp;a); if (sze[find(a)] &lt; k) printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;, getMax(find(a))); &#125; &#125;&#125; 复杂度分析初始化后，每个点最多被入堆一次（所在连通块与他人联通），出堆一次（因为不属于前 k 大而被弹出堆）每次出入堆操作是两个左式堆的 merge，复杂度 O(logn)。共 n 个点，所以总体复杂度是 O(n logn) Reference 题解 P3377 【模板】左偏树(可并堆) 课程代码","categories":[],"tags":[{"name":"20FA","slug":"20FA","permalink":"http://yao-lirong.github.io/tags/20FA/"},{"name":"Tsinghua","slug":"Tsinghua","permalink":"http://yao-lirong.github.io/tags/Tsinghua/"}]},{"title":"Tsinghua DSA 作业总结 (2)","slug":"2021-02-10-Tsinghua-DSA-作业总结-(2)","date":"2021-02-10T05:00:00.000Z","updated":"2021-02-10T19:54:44.675Z","comments":true,"path":"2021-02-10-Tsinghua-DSA-作业总结-(2)/","link":"","permalink":"http://yao-lirong.github.io/2021-02-10-Tsinghua-DSA-%E4%BD%9C%E4%B8%9A%E6%80%BB%E7%BB%93-(2)/","excerpt":"CST数据结构（2020秋）PA2a","text":"CST数据结构（2020秋）PA2a 2-1 Build心得List -&gt; 编号存树 我用的是自己写的 List 存树，对于一个节点，它有一个指针指向包含它所有孩子的 List，并有 height size 存储该点的高度及子树规模，当发生节点移动时，递归地向上更新。但是这样的话每次更新时，必须遍历当前节点的所有孩子，才能确认是否需要更新该点的高度或子树规模，这样不符合题目中 “复杂度与 cost 成线性” 的要求。所以会TLE，解决方法是在每一个点都存一个它向后看能看到的最大子树高度以及它后面所有点的子树规模和，这样每次删除某一点时，只需要更新它前面兄弟的这两个值就好了，符合我们对 cost 的定义。 List 存还会发生 MLE 的问题。既然题目中已经给出每个店的序号，其实我们不需要用 List 存，只需要用多个数组存储相对应的信息（前后节点，父子节点，本书规模及高度，其向后看所有兄弟的最大高度和字数规模和）即可，这样也解决了我们一开始读入时需要自建邻接表的问题 2-4-2 Kidd算法线段树，离散化。 线段树的每个节点所代表的区间必须一闭一开（我的实现中是左闭右开的），如果是闭区间会使同一个点被储存在相邻的区间中两次。 线段树中每个节点要存两个东西：1. 本节点对应的区间被翻转的次数 2. 本节点所包含的上所有子区间（包括它自己）被翻转的次数。其中 2 通过 本节点被翻转的次数 * 本节点代表的区间的大小 + 两个孩子区间的所有子区间被翻转的次数 得来。 所以在每次查询时，如果只是单纯的相交，相交部分也在这个区间被当做一个整体翻转时所翻转了，所以我们计算出相交范围的大小，乘上此区间被翻转的次数；如果查询区间包含在当前区间里面（恰好是当前区间），我们只需要加上当前区间及其所有子区间被反转的次数就好了 代码离散化部分有严重错误，既然第一步就有错所以剩下的对不对咱其实也不知道。但是思路大概就这么个思路（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int sort_cmp (const void * a, const void * b) &#123; return ( *(int*)a - *(int*)b );&#125;const int N = 200003;// isQuery[i] is true if the ith operation is a query &#x27;Q&#x27;, is false if the ith operation is a flip &#x27;H&#x27;bool isQuery[N]; int interval[N][2];// a stores the unique discretized intervalint a[N*2], unique_num = 0;struct treeNode&#123; bool isNode = false; // true if this is a leaf in segment tree int l, r; // this node represents the interval [l,r) int v; // this node stores value v; this interval *only* has been flipped v times long long total; // the points in this interval and all its subintervals have been flipped total times&#125;st[(N*2)&lt;&lt;1];void build(int li, int ri, int x);void update(int li, int ri, int x);long long query(int li, int ri, int x);int bisearch(int li, int ri, int g);int original_to_discrete(int x);int discrete_to_original(int y);int temp[N*4];int main()&#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); cin.ignore(100,&#x27;\\n&#x27;); char o; int l, r; for(int i=0; i&lt;m; i++)&#123; scanf(&quot;%c%d%d&quot;, &amp;o, &amp;l, &amp;r); isQuery[i] = (o==&#x27;Q&#x27;); interval[i][0] = l; interval[i][1] = r; temp[i*4 + 0] = l; temp[i*4 + 1] = l+1; temp[i*4 + 2] = r; temp[i*4 + 3] = r+1; cin.ignore(100,&#x27;\\n&#x27;); &#125; qsort(temp, 4*m, sizeof(int), sort_cmp); a[unique_num++] = temp[0]; for(int i=1; i&lt;4*m; i++) &#123; if(temp[i]!=temp[i-1]) a[unique_num++] = temp[i]; &#125; build(0, unique_num, 0); for(int i=0; i&lt;m; i++)&#123; if(isQuery[i])&#123; cout&lt;&lt;query(original_to_discrete(interval[i][0]), original_to_discrete(interval[i][1]), 0)&lt;&lt;endl; &#125; else &#123; update(original_to_discrete(interval[i][0]), original_to_discrete(interval[i][1]), 0); &#125; &#125; return 0;&#125;// node x in s-tree represents the interval [li,ri)void build(int li, int ri, int x)&#123; st[x].isNode = true; st[x].l = li; st[x].r = ri; st[x].v = 0; //cout&lt;&lt;&quot;building node &quot;&lt;&lt;x&lt;&lt;&quot;represents [&quot;&lt;&lt;st[x].l&lt;&lt;&quot;, &quot;&lt;&lt;st[x].r&lt;&lt;&quot;)&quot;&lt;&lt;endl; if(li+1 != ri) &#123; int mid = (li+ri)/2; build(li,mid,(x&lt;&lt;1) + 1); build(mid,ri,(x&lt;&lt;1) + 2); &#125; return;&#125;// currently at s-tree node x, updating interval [li,ri]void update(int li, int ri, int x)&#123; int dis = discrete_to_original(st[x].r-1) - discrete_to_original(st[x].l) + 1; if(li&lt;=st[x].l &amp;&amp; ri&gt;=st[x].r-1)&#123; // interval(x) \\subseteq [li,ri] st[x].v += 1; st[x].total += dis; return; // we should immediately stop updating any children of this node, because that will do a duplicate update &#125; if(!st[(x&lt;&lt;1)+1].isNode) return; // if this is a leaf node, return if(st[(x&lt;&lt;1)+1].isNode &amp;&amp; li &lt;= st[(x&lt;&lt;1)+1].r-1)&#123; // intersects left child update(li, ri, (x&lt;&lt;1)+1); &#125; if(st[(x&lt;&lt;1)+2].isNode &amp;&amp; ri &gt;= st[(x&lt;&lt;1)+2].l)&#123; // intersects right child update(li, ri, (x&lt;&lt;1)+2); &#125; // &#x27;st[x].v * dis&#x27; is the number of flips caused by &quot;this&quot; interval being flipped // st[(x&lt;&lt;1)+1].total is the total number of flips this node&#x27;s left child has // st[(x&lt;&lt;1)+2].total is the total number of flips this node&#x27;s right child has st[x].total = st[x].v * dis + st[(x&lt;&lt;1)+1].total + st[(x&lt;&lt;1)+2].total; return;&#125;long long query(int li, int ri, int x)&#123; long long res = 0; if(li&lt;=st[x].l &amp;&amp; ri&gt;=st[x].r-1)&#123; // interval(x) \\subseteq [li,ri] res += st[x].total; return res; &#125; int dis = discrete_to_original(min(st[x].r-1, ri)) - discrete_to_original(max(st[x].l, li)) + 1; res += st[x].v * dis; if(st[(x&lt;&lt;1)+1].isNode &amp;&amp; li &lt;= st[(x&lt;&lt;1)+1].r-1)&#123; res += query(li, ri, (x&lt;&lt;1)+1); &#125; if(st[(x&lt;&lt;1)+2].isNode &amp;&amp; ri &gt;= st[(x&lt;&lt;1)+2].l)&#123; res += query(li, ri, (x&lt;&lt;1)+2); &#125; return res;&#125;int bisearch(int li, int ri, int g)&#123; int mid = 0; while(ri &gt; li+1)&#123; mid = (li+ri)&gt;&gt;1; if(a[mid]&lt;=g) li = mid; else ri = mid; &#125; return li;&#125;int discrete_to_original(int y)&#123; return a[y];&#125;int original_to_discrete(int x)&#123; return bisearch(0, unique_num, x);&#125; 2.7 Virus心得堆的 sink 的边界条件应该是 1234int l=i*2, r=i*2+1;while((l&lt;=n &amp;&amp; a[i]&gt;=a[l]) || (r&lt;=n &amp;&amp; a[i]&gt;=a[r]))&#123; ...&#125; 而不是 12345678int height(int x)&#123; if(x==0) return 1; int digit=0; while(x&gt;0) &#123;x=x&gt;&gt;1; digit++;&#125; return digit;&#125;while((a[i]&gt;=a[l]||a[i]&gt;=a[r])&amp;&amp;i&lt;pow(2,height(n)))&#123; ...&#125; 堆是一个完全二叉树 (Complete Binary Tree) 而不是一个完美二叉树 (Perfect Binary Tree) 代码仅展示了堆的实现部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788const int M=1000007;const int INF=10e7;const int N = 1007;struct point &#123; int id; // id = x*N + y int t; point(int x, int y, int ti) &#123; id = x*N + y; t = ti; &#125; point() &#123; id = 0; t = 0; &#125; point(int n) : point() &#123;&#125; point(const point &amp;from) &#123; this-&gt;id = from.id; this-&gt;t = from.t; &#125;&#125;;point myPQ[M];inline bool operator&lt;(const point &amp;p1, const point &amp;p2) &#123; return p1.t &lt; p2.t;&#125;inline bool operator&gt;(const point &amp;p1, const point &amp;p2) &#123; return p1.t &gt; p2.t;&#125;inline bool operator&lt;=(const point &amp;p1, const point &amp;p2) &#123; return p1.t &lt;= p2.t;&#125;inline bool operator&gt;=(const point &amp;p1, const point &amp;p2) &#123; return p1.t &gt;= p2.t;&#125;class PriorityQueue &#123; int n = 0; point *a = myPQ;public: void add(point x) &#123; a[++n] = x; swim(n); &#125; point extract() &#123; point result = a[1]; swap(a[1],a[n]); a[n--]=INF; sink(1); return result; &#125; bool isEmpty() &#123;return n == 0;&#125;private: void swim(int i) &#123; while(i&gt;1 &amp;&amp; a[i/2]&gt;=a[i])&#123; swap(a[i/2],a[i]); i = i/2; &#125; &#125; void sink(int i) &#123; int l=i*2, r=i*2+1; while((l&lt;=n &amp;&amp; a[i]&gt;=a[l]) || (r&lt;=n &amp;&amp; a[i]&gt;=a[r]))&#123; if(a[l]&lt;=a[r]&amp;&amp;l&lt;=n)&#123; swap(a[i],a[l]); i = l; l=i*2; r=i*2+1; continue; &#125; else if (a[l]&gt;a[r]&amp;&amp;r&lt;=n)&#123; swap(a[i],a[r]); i = r; l=i*2; r=i*2+1; continue; &#125; else return; &#125; &#125;&#125;;","categories":[],"tags":[{"name":"20FA","slug":"20FA","permalink":"http://yao-lirong.github.io/tags/20FA/"},{"name":"Tsinghua","slug":"Tsinghua","permalink":"http://yao-lirong.github.io/tags/Tsinghua/"}]},{"title":"Tsinghua DSA 作业总结 (1)","slug":"2021-02-09-Tsinghua-DSA-作业总结-(1)","date":"2021-02-09T05:00:00.000Z","updated":"2021-02-10T19:55:17.231Z","comments":true,"path":"2021-02-09-Tsinghua-DSA-作业总结-(1)/","link":"","permalink":"http://yao-lirong.github.io/2021-02-09-Tsinghua-DSA-%E4%BD%9C%E4%B8%9A%E6%80%BB%E7%BB%93-(1)/","excerpt":"CST数据结构（2020秋）PA1a","text":"CST数据结构（2020秋）PA1a 1-1 A*B Problem心得 每个数组存一位的话速度太慢过不了，必须压位 10e5 是 10 * 10^5 所以是 10^6 … 我们把一个大整数分成几块存在数组里的时候，如果这个数头上有0的话，0就会被忽略了（不压位的话没有这个问题，因为0也就是1位）比如4位4位存，100046000303025会变成[3025, 30, 460, 100]，直接输出会变成100460303025，明显不对，所以我们输出的时候要记得补全0 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;// N is the maximum number of digits of the input, M is the maximum number of digits of the productconst int N = 5007, M = 10023;// we multiply each 10000 together and store them in a single entry, 10e3 has 4 0s .const int ten = 10e3, d_ten = 4;// a is input A in e4 base, b is input B in e4 base, c is their product in e4 base.int a[N], b[N], c[M];// a_len is the number of entires in a needed to store input A, so it&#x27;s the digit needed to store A in e4 base; b_len is that for Bint a_len, b_len;// digit is a helper array we will need during multiplicationint digit[] = &#123;1,10,100,1000,10000&#125;;// inputA and inputB is A and B read in from streamchar inputA[N], inputB[N];// multiplies e4 base A and B together and store the result in Mvoid multiply();// returns the length of product in e4 baseint get_clen();// print padding zero in each entry of array C when outputting the resultvoid print_padding_zero(int,int);int main()&#123; int n = 0; scanf(&quot;%d&quot;,&amp;n); for (int i=0; i&lt;n; i++)&#123; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); memset(c,0,sizeof(c)); memset(inputA,0,sizeof(inputA)); memset(inputB,0,sizeof(inputB)); scanf(&quot;%s&quot;,inputA); int ina_len = strlen(inputA); a_len = (ina_len-1)/d_ten + 1; scanf(&quot;%s&quot;,inputB); int inb_len = strlen(inputB); b_len = (inb_len-1)/d_ten + 1; // store the number in reverse order and e4 baes in array a,b for (int i=ina_len-1; i&gt;=0;)&#123; int tostore = 0; for (int j=0; j&lt;d_ten &amp;&amp; i-j&gt;=0 ; j++)&#123; int ASCII = inputA[i-j] - &#x27;0&#x27;; tostore += ASCII*digit[j]; &#125; a[a_len-1 - i/d_ten] = tostore; i = i-d_ten; &#125; for (int i=inb_len-1; i&gt;=0;)&#123; int tostore = 0; for (int j=0; j&lt;d_ten &amp;&amp; i-j&gt;=0 ; j++)&#123; int ASCII = inputB[i-j] - &#x27;0&#x27;; tostore += ASCII*digit[j]; &#125; b[b_len-1 - i/d_ten] = tostore; i = i-d_ten; &#125; multiply(); int c_index = get_clen(); printf(&quot;%d&quot;, c[c_index]); for (int i=c_index-1; i&gt;=0; i--)&#123; print_padding_zero(c[i], ten/10); printf(&quot;%d&quot;, c[i]); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125;void multiply()&#123; for(int i=0; i&lt;a_len; i++)&#123; for(int j=0; j&lt;b_len; j++)&#123; int product = a[i] * b[j]; c[i+j] += product; c[i+j+1] += c[i+j] / ten; // carry over digit c[i+j] %= ten; // only stores e4 base number &#125; &#125;&#125;inline int get_clen()&#123; int n = a_len + b_len + 3; while (c[n]==0 &amp;&amp; n&gt;0) n--; return n;&#125;/** * Each entry in array C should store an e4 base number, but sometimes it stores a number smaller than that. * That&#x27;s because it ignores the leading 0s (leading 0s in reversely stored C) when in this case 00XX. * Example: 1004 0030 57 stored in C has form [57, 30, 1004], this function helps print out the first 00 in 0030 **/inline void print_padding_zero(int n, int digit)&#123; if (n&lt;digit) printf(&quot;0&quot;); if (digit == 10) return; print_padding_zero(n,digit/10);&#125; Reference 高精度乘法 高精度乘法的压位 1-3 Filename心得编辑距离，移动窗口节省空间 字符串的读入：一开始以为是 getline 的问题，读不进来字符串，实际上是因为仅用 scanf 读入3个整数后会留下一个换行符在 buffer 中。使用 cin.ignore(100,&#39;\\n&#39;) 删除换行符（忽略 100 个字符，或者忽略1个 &#39;\\n&#39;；忽略所有读入，直到总共忽略了 100 个字符，或者忽略了 1 个换行符） dp数组开到 $1001^2$ 会爆炸，改用滚动窗口，dp[0][j] 表示 $ x_1x_2…x_{i-1}$ 到 $y_1 y_2 … y_j$ （前一步）所需要的操作，dp[1][j] 表示 $ x_1x_2…x_{i-1}$ 到 $y_1 y_2 … y_j$ （这一步）所需要的操作。几个实现细节在注释中已标出 TLE: 第一感觉想的是在每次计算 $i, s.t. x_1x_2…x_i$ 变成 $y$ 所需要的操作后（即计算完成 dp[i][0...m]后），扫一遍数组，如果所有值都大于 k 的话，就停止查找。但是这样不会对数据规模有任何可观的缩减，因为如果说我们有长为 $10^5$ 的两个字符串，并且他们可以在 k 操作内互相转换（极端情况两个相同的字符串），我们仍然需要进行 $O(mn) = 10^5 \\times 10^5$ 次操作。 根据习题课的解决方法，其实当两个数组间的长度差超过 k 时就绝对不可能从一个转换成另一个了。所以，对于每个 $x$ 的子串 $x_1x_2…x_i$，我们只需要看 $y_{i-k} y_{i-k+1} … y_{i+k}$ 就可以了。当然还要注意 $i-k, i+k$别越界，所以实际上是看 $y_{min(1,i-k)} … y_{max(m,i+k)}$ 这个子序列 这个改动会造成一些 WA，直觉一下子想到是有可能在最后退出循环时，我们因为 k 的限制压根就没扫到 dp[n][m](= dp[1][m])。实际上问题差不多，是因为 dp[i][j] = min(dp[i-1][j], dp[i][(j-1)]) + 1; 这句话中 dp[0][j] 我们一开始全初始化为0，对于 dp[i][i+k] 这个位置，它的一种方案 dp[i-1][i+k] 永远不会被上一步更新到，因为上一步只更新 dp[i-1][(i-1)-k] ~ dp[i-1][(i-1)+k] 即 dp[i-1][i+k] 恒等于0，即 dp[i][i+k] 永远会采取 dp[i-1][i+k] 这一方案。将 dp[0][j] 初始化为 infinity 解决 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int N = 501007, Inf = 501; // Inf is &quot;effective infinite&quot; : k&lt;=500char a[N], b[N]; // a, b store the string x, yint dp[2][N]; // For each iteration i, dp[0] is equivalent to dp[i-1], dp[1] is equivalent to dp[i]int main()&#123; int n,m,k; //length of x, length of y, max number of operations scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); cin.ignore(100,&#x27;\\n&#x27;); cin.getline(a+1, n+1); cin.getline(b+1, m+1); // initialize dp[0][j] to be the operations needed to edit an empty string to y1y2...yj // initialize the rest of the array to be infinite for(int j=0;j&lt;=m;j++) dp[0][j] = j, dp[1][j] = Inf; for(int i=1; i&lt;=n; i++) &#123; // start from the 1st character // dp[0][0] represents dp[i-1][0] in an ordinary dp array // dp[i-1][0] represents the distance between x1x2...x_&#123;i-1&#125; to the empty string dp[0][0] = i-1; for(int j=max(1, i-k);j&lt;=min(m,i+k);j++)&#123; // only looks at y[i-k] to y[i+k] if(a[i]==b[j]) dp[1][j] = dp[0][(j-1)]; else dp[1][j] = min(dp[0][j], dp[1][(j-1)]) + 1; &#125; // &quot;previous&quot; of next iteration i+1 is current value from this iteration i for(int j=max(1, i-k);j&lt;=min(m,i+k);j++) dp[0][j] = dp[1][j]; &#125; printf(&quot;%d\\n&quot;, dp[1][m]&lt;=k ? dp[1][m] : -1); return 0;&#125; Reference C++ cin.ignore()的用法详解 C++ cin&gt;&gt; cin.get() cin.getline() 1.4 Risk心得Queap, 二分搜索 每次询问的时候，假设我们要看前 m 天，现在的 Queap 中存了 qsize 天，如果 qsize&gt;m 的话，我们存了一些没必要看的天，那么我们就需要把这些没必要的天给推出去，所以看出来我们需要推出 qsize-m 个没必要的天。然而我的实现在 dequeap 和 enqueap 时会实时更新 qsize 所以实际上 Queap 只会弹出大概一半的元素，会造成很大的问题。所以我们必须先记录 qsize-m 然后再更新 最后的T次询问是对已经有的数据，询问有多少在相应的区间内。我们这里可以使用排序后二分查找区间分界点的位置，而不是对于每个元素都看是在哪个区间内。这样可以大大缩短时间 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;// elements in queue/queap are the number of infections of previous days// size of queue/queap is the number of days we need to keep track of// Queue Nodestruct qNode &#123; long long value; qNode* next, * prev;&#125;;qNode *qHead = new qNode, * qTail = new qNode;// Queap Node; Invariant: node n in a queap [h...n...t] is the max element in interval in [h...n]struct pNode &#123; long long value, num; pNode* next, * prev;&#125;;pNode *pHead = new pNode, * pTail = new pNode;long long qsize = 0;// enqueue value v into Q;// update &quot;max value available&quot; in queap Pvoid enqueap(long long v) &#123; qNode* q = new qNode; pNode* p = new pNode; qsize += 1; q-&gt;value = v, q-&gt;next = qHead-&gt;next; q-&gt;prev = qHead; qHead-&gt;next-&gt;prev = q; qHead-&gt;next = q; pNode* i = pHead-&gt;next; int num = 0; while (i != pTail) &#123; if (v &gt;= i-&gt;value) &#123; num += i-&gt;num; i = i-&gt;next; delete i-&gt;prev;&#125; else break; &#125; // i is the first interval max greater than inserted value // replace everything between pHead and i with the newly inserted value if (num &gt; 0) &#123; p-&gt;value = v; p-&gt;num = num+1; p-&gt;next = i; p-&gt;prev = pHead; i-&gt;prev = p; pHead-&gt;next = p; &#125; else &#123; // num==0 says v &lt; pHead-&gt;next, insert p in between Head and Head-&gt;next p-&gt;value = v; p-&gt;num = 1; p-&gt;next = i; p-&gt;prev = pHead; i-&gt;prev = p; pHead-&gt;next = p; &#125; return;&#125;// dequeue one element from Q and from Pvoid dequeap() &#123; if (qsize &lt;=0) return; qsize -= 1; qNode *qDel = qTail-&gt;prev; qTail-&gt;prev = qTail-&gt;prev-&gt;prev; qTail-&gt;prev-&gt;next = qTail; delete qDel; pNode *pDel = pTail-&gt;prev; if (pDel-&gt;num &gt; 1) pDel-&gt;num--; //there is still element after deletion else if (pDel-&gt;num == 1)&#123; //only one element left, there will be 0 elements after this deletion, so let&#x27;s just delete this node altogether pTail-&gt;prev = pDel-&gt;prev; pDel-&gt;prev-&gt;next = pTail; delete pDel; &#125; else throw &quot;0 element in pNode error&quot;; // there is no element in the top node, which is not supposed to happen return;&#125;// returns the Max value in the Queap; returns 0 if Queap is emptyinline long long getMax() &#123; return qsize&gt;0 ? pTail-&gt;prev-&gt;value : 0;&#125;// print both queue and queap for debugging purposesvoid printQueue() &#123; qNode* q = new qNode; q = qHead-&gt;next; pNode* p = new pNode; p = pHead-&gt;next; cout&lt;&lt;&quot;printing out queue Q:&quot;&lt;&lt;endl; while (q != qTail) &#123; cout &lt;&lt; q-&gt;value &lt;&lt; &quot; &quot;; q = q-&gt;next; &#125; cout &lt;&lt; endl; cout&lt;&lt;&quot;printing out queap P:&quot;&lt;&lt;endl; while (p != pTail) &#123; long long v = p-&gt;value; for (int i = 0; i &lt; p-&gt;num; i++) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; p = p-&gt;next; &#125; cout &lt;&lt; endl;&#125;// cmp function for qsortinline int sort_cmp (const void * a, const void * b)&#123; return ( *(long long*)a - *(long long*)b );&#125;//returns the last element &lt;=g in [l,r]int bisearch(const long long a[], int l, int r, long long g) &#123; int mid = -1; while(l&lt;r) &#123; mid = (l+r)&gt;&gt;1; a[mid] &lt;= g ? l=mid+1 : r=mid; &#125; return l-1;&#125;long long observed[1000007]; int input[1000007];int main()&#123; // initializes Q and P qHead-&gt;next = qTail, qTail-&gt;prev = qHead; pHead-&gt;next = pTail, pTail-&gt;prev = pHead; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;input[i]); &#125; // For each day, we first check which day is the earliest day we have to keep track of // If there are some days we no longer have to keep track of, we dequeue them from the queap and queue // Then record the maximum infection number maintained by queap and enqueue the infection number of today for (int i = 0; i &lt; n; i++) &#123; long long m; scanf(&quot;%lld&quot;, &amp;m); long long num = qsize-m; for(long long j=0; j &lt; num; j++)&#123; dequeap(); &#125; observed[i] = getMax(); enqueap(input[i]); &#125; qsort(observed, n, sizeof(long long), sort_cmp); // There are T queries, always on already observed infection number // We only care about number of days in a certain range, not the date or any other information // Therefore, we can use binary search to get the number of days in this given range. int T; scanf(&quot;%d&quot;, &amp;T); for (int i=0; i&lt;T; i++)&#123; long long p,q; scanf(&quot;%lld%lld&quot;, &amp;p, &amp;q); int pnum = 0, qnum = 0; pnum = bisearch(observed,0,n,p-1) + 1; // &lt;p \\equiv &lt;=p-1; returns the index of the last element &lt;p, so there are index+1 elements qnum = bisearch(observed,0,n,q-1) - pnum + 1; // similarly, &lt;q \\equiv &lt;=q-1; bisearch(observed,0,n,q-1) - bisearch(observed,0,n,p-1) gives the number of elements in range [p,q) printf(&quot;%d %d\\n&quot;, pnum, qnum); &#125; return 0;&#125; Reference 双向链表(结构体+指针) 定义结构体变量及初始化; 结构体定义变量的三种方法 unsigned long long int scanf","categories":[],"tags":[{"name":"20FA","slug":"20FA","permalink":"http://yao-lirong.github.io/tags/20FA/"},{"name":"Tsinghua","slug":"Tsinghua","permalink":"http://yao-lirong.github.io/tags/Tsinghua/"}]},{"title":"Cornell/Tsinghua 20FA 总结","slug":"2021-01-11-CornellTsinghua-20FA-总结","date":"2021-01-11T05:00:00.000Z","updated":"2021-02-10T20:00:33.516Z","comments":true,"path":"2021-01-11-CornellTsinghua-20FA-总结/","link":"","permalink":"http://yao-lirong.github.io/2021-01-11-CornellTsinghua-20FA-%E6%80%BB%E7%BB%93/","excerpt":"CS4820 Intro Analysis of Algorithms I got to do all the stuff I want. … I’m actually one of the Ithaca’s firefighters now and on average we have a really big and nice fire each year so I got to work when that comes. – Dexter Kozen, 2020/12/16","text":"CS4820 Intro Analysis of Algorithms I got to do all the stuff I want. … I’m actually one of the Ithaca’s firefighters now and on average we have a really big and nice fire each year so I got to work when that comes. – Dexter Kozen, 2020/12/16 因为网课的原因不想上写代码的课，4820是我本学期上的唯一一节CS课，也是拿的第一个CS A+。但是总体来说 4820 和 3110 上到最后都没有 2112 和 2802 有一种我真的成长了的成就感，可能是因为 4820 覆盖的东西太多，导致知识间比较割裂，用来证明一个算法的技巧在另一个模块就用不太上了。 他们说什么上完 4820 对面试有帮助，我觉得这完全就是扯淡的，可能确实刷题的时候你更容易看出来这应该用什么算法了，但是这门课所有的编程训练只能说是非常初级（到连我都觉得不难的水平）课程重点还是在算法的分析和证明上，和证明题一对比，给的编程题真就跟过家家一样。最后一次作业复刻了 sxy 的壮举交成了 release，幸亏还有个编程题的 10 分保底，这次作业就拿了 10/30 分。但是由于前面作业考试都不错，而且去不了跨时差 Office Hour 导致我所有问题都在 Piazza 上问了，participation grade 特别高。xzy 在课程中问 participation grade 怎么算时发现了以后我才去看的，我的 Piazza 贡献是整个班的第二，人家第一是成天回答问题，我是成天什么都没搞懂在上面问问题。不过用 Kozen 的话说，这也是一种 “contribute to the intellectual content of the course” 方式。所以大概是因为极高的 participation grade 以及对 Kozen 的诚恳请求，老人家最后高抬贵手给我了个 A+ （不过要是没误交作业也是我应得的啦） 对于 Dexter Kozen，说实话感觉他的教学水平并不如 Myers 和 Halpern，有的时候基本上是完全照着课本来的，如果他是完全按照课本来的，那么一般看课本甚至比他讲得好；但是当他按照自己的证明方法讲的时候，他的方法又比书上的好理解很多…不过比下肯定是有余的，比其他几个我上过课但是没在这提名的叫兽好多了。而且 Dexter Kozen 还会在最后一节课给你弹吉他听，就这还要啥自行车？ 课程内容分布方面（可能不是 Kozen 而是书本的问题）分治和动态规划两章，我并不认为第一次接触这些概念的同学能听懂任何东西，分治直接给的是 FFT 和找平面中最近点的两个很变态的例子，动规直接是从多维动规开始讲的（书上是按维度顺序来的，这确实是Kozen一时兴起）网络流这一节 作为 Jon Kleinberg 和 Eva Tardos 的主场，讲得例子都非常有意思。 MATH4710 Basic Probability傻逼中的傻逼课，我不认为在上完这节课以后我对概率和统计的理解对比2802之后有任何进步。当时是为了打算春季上机器学习，所以即使知道这法国人讲得屎但也是顶着头上落屎的风险上的。没想到人家法国人这么实诚，你觉得我讲得屎，我就真就用实际行动证明老子讲得就是屎，你还拿他没办法，你说气不气？上这个法国人的课上到学期末，我甚至都不知道 Poisson 或者其他概率分布的图像长什么样，我对每一个分布的认知完全是割裂的，直到期末考试我还要一个个查提到的分布的 distribution function 到底是什么。每一次的作业和考试都在非常离谱的地方给我扣分，最后成绩也贼难看，完完全全地打击了我学习数学的信心，不如说整个康奈尔数学院的存在，除了少数几个教授以外，就是为了打击你学习数学的信心。整个院里面，除了研究做不出来所以只能折磨学生取乐的教授，还有研究做不出来而且本身实力就不行所以在读博期间必须兼职助教于是就也跟着虐待学生的变态博士生。不化简扣1分，你说100分满分，中位数 7,80 你扣也就算了，60满分中位数58的考试你因为不化简给我扣2分，而且让我化简的还是一个带了四项组合数的超恶心式子，你怎么不直接让我默写 π 的后1000位呢？ EAS1540 Introductory Oceanography大多数人强推的科学课，说实在话没什么意思。个人感觉不如 DEA1500（虽然是不一样的 distribution requirement）Gary Evans在我心里还是暂时的选修课之神的地位。大家都说这门科学课讲得东西简单（毕竟是连美国人都推荐的科学课）实际也确实如此，但是简单的部分他讲的我都会，顶多也就是高中地理高一水平；难的部分呢他说实话又没讲明白，而且 Bruce Monger 在整个学期都在不停的讲环保环保，所以来的没有 Gary 最后一课画龙点睛那样令人印象深刻，不过 Bruce Monger 的目标也达到了，现在我确实清楚地意识到如果 2030 和 2050 控温目标没达到的话，地球真的会灭亡。 INFO1998 Freshmen Team Projects (Intro to Machine Learning)没意思，教你怎么用 sklearn 库的课 CS2024 C++ Programming还是挺不错的，五六年以后，我终于第一次正式学习了C++这门语言，就是作业有些无聊。 CS4320 Introduction to Database Systems我drop了这门课 一门教数据库的课，开课两个礼拜竟然仍然没教学生们如何在你的电脑上安装数据库来使用基本的 SQL 指令；老师操着一口谁也听不懂的德国口音，让我梦回我托福水平只有80分的时候元素听托福听力的那个秋天；录像上传 youtube 公开，就好像除了你的学生以外谁还会闲着没事不去上CMU的数据库，来上您的课练习德语一样（但还是要赞扬一下这个老师公开上传，他实际上也将近几年的所有课程录像上传到了 Cornell VOD，只是我不清楚到底谁会去看讲得这么烂的课） 在清华认识的同学 Leo 竟然跟我说他最后这门课得了一个 A+，而他得 A+ 的诀窍就是自己原来接触过数据库，不去上课，作业发下来以后自己查找相关资料进行学习，也是非常离谱，不知道德国人发现原来他觉得做得不错的学生都是通过这种方式“做的不错”的会作何感想。 两年以来，我首次感觉到我的学费花得值，就是在这个动荡的2020年，Cornell 对它的中国学生说，你可以去清北上交中的一所学校进行你的线下秋季学期，其他的所谓 Ivy 和 Ivy+ 们，大气都不敢出一个，更别说去清北上交了。康奈尔牛逼！ 其实一开始我是录的上海交通大学，后来好像被补录的清华，有了TOP2，谁还会去上海一个不知名的小学校呢？ 30240184 数据结构 现在我们要来证明一下它的正确性……………为什么要证明呢？就好像你不能说自己是世界一流大学你就是了，你肯定得证明一下自己确实有匹配的实力才行 – 邓俊辉，于为什么要证明二分查找的正确性 这是一门神奇的课程，无论讲得概念是简单的链表还是难的线段树，都能让学生受益，邓俊辉老师是伟大的老师，他让我一个原来觉得线段树或kd树这种东西离我很远的人，感受到了原来我也能听明白这么复杂的数据结构。他也让我认识到，我校的 Nate Foster 真是个 cjb，ocaml 的红黑树实现不是因为 pattern matching 所以代码才那么少，是因为它使用的是 3-4 重构而不是传统的旋转，要是 C++ 写重构代码量也会大幅减少… 邓俊辉老师也鼓励了我，说不定我和清华的同学们实力差距没有我原来想象的那么巨大，我差的就是一堂这么好的课，一个全是学CS同学的宿舍，一个耐心认真的老师而已。清北和MIT是我心目中的圣地，我以为里面的人都是愿意穷其一生为全人类服务的人，我也以为我这次来之后，这个想法要么破碎要么印证，因为这门课，因为邓俊辉老师，我现在更倾向于说我的这个想法被印证了。 实际上上完这门课以后我对自己的认知更迷茫了，虽然 PA1 做的不是那么好（和清华同学比，自己的预期还是达到了的）PA2 因为康奈尔期末考，摔伤了腿，生病等等几乎没做，但咱 PA3 拿了满分啊，而且 PA3 是唯一一个真正有 TA 指导的的 Programming Assignment，其他的都是别的同学可以直接问他们班里宿舍里的信竞大佬，我只能闭门造车。四舍五入，我是不是要是有一定程度的帮助，和清华同学比一点也不差呢？说实话我来之前确实心里面有点这样想，毕竟清华的人虽然聪明，但是大部分人高中三年没任何编程经历，我虽然蠢，但是对自己CS还是比较有信心的。直到上完这门课，期末考试几乎都不会的情况下，我的心里还是抱有那么一丝丝希望：说不定咱和清华人比一点不差呢。说到这个，我和其他人说起清华这门课很难的时候，他们表现得竟然是惊讶而不是理所当然，他们竟然真的觉得康奈尔提供的教育足以让我们可以和清华人抗衡。看来在有自知之明这点上我还是比其他同学高一点的（ 选这门课还要感谢 cz，是他跟我说了这门课评价很好我才会去选，不然“数据结构”这种课我绝对觉得我都学得会了，懒得上。实际上我一开始不是在邓老师门下学习，一开始给国际交换生的名额只有另一个讲师的班了，但我第一节课去听了以后，她讲尾递归竟然说用到的空间会是 O(n)，其中 n 是调用次数。别的我不确定，但是 Myers 曾经明确地说过尾递归的好处就是可以重复地使用调用栈，如此一来不会有溢出（当然了说不定 Java 和 C++ 并不一样）于是下课以后我去询问为什么是 O(n) 和她讲了我的想法，她表现得挺不耐烦，然后我追着她出了教室，她一边开自行车的锁一边听我说话，最后就撂下一个 ”恩，那可能是这样吧“ 就走了。这个表现让我回忆起了我的高中班主任也是这样，说自己很喜欢学生，很喜欢教学，最后你去找她的时候她根本是漠不关心，虚伪的一B，幸亏我后来认识 Leo，知道了他（并不知道自己应该跟我一个班）一直在听邓老师的课，去听了以后真是一个天上一个地下。清华的同学们啊，你们都在清华了，为什么要折磨自己，不跟着邓老师学呢？ 上完这门课我也在想，是不是只有差的老师，没有差的学生？如果每个人都听邓老师的课，我很怀疑他们会听不懂（毕竟我都听懂了）可是其他大学的同学们并无法享受到这等待遇，只能逼着自己听讲那个讲得烂的。就好像 qsq 在北师大，或者我自己在康奈尔的经历完全一样，一个差的老师不仅帮不到学生，还会严重地打击一个人的自信心，让他深深地怀疑我到底喜不喜欢这个学科，这个学科到底适不适合我等等此类。 Logic, Computing, Games清华大学特聘教授，斯坦福大学名誉教授，什么什么很厉害的研究所的创始人 Johan van Benthem！来给你 上网课！ 而且这网课还是如果你想要问问题必须等老师一节课下课以后，你才能和助教举手示意说我有个问题，然后他会给你一个麦克风你才能问。学生没有任何直接联系教授的方法，必须通过助教，助教又一副爱答不理的样子，课程推荐阅读也没有，必要先修知识也不写，甚至连个 syllabus 都没得。教授的课讲得其实还不错，第一节课我感觉自己听到了前二十分钟，当我后面完全听不懂想要自己阅读材料寻求帮助时，发现这门课屁都不提供，也不知道是这个教授不上心，还是助教什么都不管只管向教授报告“一切安好”，或者是全清华的课都是这个德行，我反正上不下去这课了，也是很遗憾的，毕竟对方看起来真的是很有名的教授，比康奈尔的哲学院估计好不少呢… 话说后来我还去看了几节，发现人是越来越少，看到清华的同学们也退了我是很开心的，不过他们可能是因为听不懂英语退的吧？我也不知道 Introduction to Artificial Intelligence圆了一个自己“上叉院的课”的这一装逼梦，第一节课是个老头子，英语讲得也不很溜道但就是要说英语，第一节课啥也没讲就讲了讲AI的历史什么的，很是没意思。后来发现这个英语讲得不溜道，说话也不溜道的老头子是姚期智老先生…嘶，对不起 第二节课就开始有意思了，一上来就 reinforcement learning 的什么很厉害的人来讲很先进的 reinforcement learning，有意思是有意思，不过是局限于叉院同学们的有意思，我已经听不懂了，早早拜拜，听了一节课就行了 课堂上还有来自 Princeton 的同学们（看到她们 Gmail 右上角的校标确定的）我第二节课就不去了，不知道我们 Princeton 的小同学是什么时候不去的，还是她们都能听懂。不过你说她们有叉院同学的实力，我是绝对不信的。","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"20FA","slug":"20FA","permalink":"http://yao-lirong.github.io/tags/20FA/"},{"name":"Tsinghua","slug":"Tsinghua","permalink":"http://yao-lirong.github.io/tags/Tsinghua/"}]},{"title":"C++ 常见问题","slug":"2020-11-29-C++-常见问题","date":"2020-11-29T05:00:00.000Z","updated":"2021-11-21T04:30:33.213Z","comments":true,"path":"2020-11-29-C++-常见问题/","link":"","permalink":"http://yao-lirong.github.io/2020-11-29-C++-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"char ：1个字节 char*(即指针变量): 8个字节 short int : 2个字节 int： 4个字节 unsigned int : 4个字节 float: 4个字节 double: 8个字节 long: 8个字节 long long: 8个字节 unsigned long: 8个字节 I/O读入字符串可以用 scanf(&quot;%s&quot;) 或 getline() 读入字符且忽略空格可以用 scanf(&quot; %c&quot;)，注意 %c 前面的空格 C++ cin.ignore()的用法详解 C++ cin&gt;&gt; cin.get() cin.getline() unsigned long long int scanf 文件的读取及写入: 12freopen(&quot;myfile.txt&quot;,&quot;r&quot;,stdin);freopen (&quot;myfile.txt&quot;,&quot;w&quot;,stdout); STL的使用 为什么 std::vector 不支持 push_front？ 指针的使用 指针变量的传值和传址 C++ delete 和 delete []的区别 NULL和nullptr的区别 类与结构体的使用 C++中结构体与类的区别（struct与class的区别） 定义结构体变量及初始化; 结构体定义变量的三种方法 C++构造函数什么时候会被调用 C++中如何声明两个递归调用的类 String Split a String: strtok: Reference 1, Reference 2 123456789char str[] =&quot;- This, a sample string.&quot;;char * pch;pch = strtok (str,&quot; ,.-&quot;);while (pch != NULL)&#123; printf (&quot;%s\\n&quot;,pch); // Note to use NULL the next time you call strtok pch = strtok (NULL, &quot; ,.-&quot;);&#125; Convert a char array to integer: sscanf(s, &quot;%i&quot;, &amp;imm) automatically detects whether s is an decimal 142 or a hex 0xa2c (Note the 0x before a hex number is necessary) 123char myarray[5] = &#123;&#x27;-&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;\\0&#x27;&#125;;int i;sscanf(myarray, &quot;%d&quot;, &amp;i); Read in both hex and dec number: scanf(&quot;%i&quot;, ) Strings in C (char arrays) end with a terminating null-character &#39;\\0&#39; 其它问题 switch statement gives “a label can only be part of a statement…”: switch 后要加分号 ; 12345switch (option) &#123; case &#x27;a&#x27;: ; ... case &#x27;b&#x27;: ; ... &#125;","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"http://yao-lirong.github.io/tags/Logistics/"},{"name":"C++","slug":"C","permalink":"http://yao-lirong.github.io/tags/C/"}]},{"title":"Python 常见问题","slug":"2020-11-29-Python-常见问题","date":"2020-11-29T05:00:00.000Z","updated":"2022-04-01T04:22:41.470Z","comments":true,"path":"2020-11-29-Python-常见问题/","link":"","permalink":"http://yao-lirong.github.io/2020-11-29-Python-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"python 整型与二进制数值的相互转换 pyhton 的异或与 Hamming Distance Python之正则表达式——查找 Python类型强制转换 multi-line statements: 123total = item_one + \\ item_two + \\ item_three List Find Median of List in Python: statistics.median(list) Union of two lists: to remove all repetitions, use res = list(set().union(lst1, lst2, lst3, ...)) concatenate two lists: lst1 + lst2 Hash a list: you cannot hash a list, because list is mutable. You can only hash immutable objects. Therefore, to hash a list, you first convert it to a tuple: hash(tuple([1,2,3])). Dict Sort a dictionary: dct= dict(sorted(dct.items(), key=lambda item:item[0])) to sort by keys; change to item[1] to sort by values. Remove an item from dict by key: dct.pop(your_key) Function Access &amp; Change global variable in local functions: you can access global variable in local functions without any other keywords. However, if you want to change the global variable in your local function. You will have to use the global keyword. By using a global keyword, you can either create a global variable in a local function, or link back to a global variable already created. 1234567x = &quot;h&quot;def myfunc(): global x x = &quot;fantastic&quot;myfunc() Multiple number of arguments to a function: 123def foo(a, b, c, *others): print(a, b, c) print(&quot;And all the rest are &quot;, list(others)) Class print a class like Java’s toString : 12345class Test: def __repr__(self): # what to display when looked at in an interactive prompt return &quot;Test()&quot; def __str__(self): # what to print when called print(Test) return &quot;member of Test&quot; Self-defined comparator: 12345678910111213class CustomNumber: def __init__(self, value): self.value = value def __lt__(self, obj): &quot;&quot;&quot;self &lt; obj&quot;&quot;&quot; return self.value &lt; obj.value def __le__(self, obj): &quot;&quot;&quot;self &lt;= obj&quot;&quot;&quot; def __eq__(self, obj): &quot;&quot;&quot;self == obj&quot;&quot;&quot; def __ne__(self, obj): &quot;&quot;&quot;self != obj&quot;&quot;&quot; def __gt__(self, obj): &quot;&quot;&quot;self &gt; obj&quot;&quot;&quot; def __ge__(self, obj): &quot;&quot;&quot;self &gt;= obj&quot;&quot;&quot; hash on a custom object: 12345678class Emp: def __init__(self, emp_name, id): self.emp_name = emp_name self.id = id def __hash__(self): # when you want to get the hash, use hash(instance_of_custom_object) return hash((self.emp_name, self.id)) Local variable in a class: Elements outside the __init__ method are static elements; they belong to the class. Elements inside the __init__ method are elements of the object (self); they don’t belong to the class. 1234class MyClass: static_elem = 123 # static def __init__(self): self.object_elem = 456 # specific to eacy instance ExceptionSelf-specified exception: 123456789101112class MyCustomError(Exception): def __init__(self, *args): if args: self.message = args[0] else: self.message = None def __str__(self): if self.message: return &#x27;MyCustomError, &#123;0&#125; &#x27;.format(self.message) else: return &#x27;MyCustomError has been raised&#x27; String convert string to int: int(s) How to remove the leading and trailing spaces in Python: my_string.strip() 合并一个 String List: &quot;&quot;.join(str_lst) advanced split with re : re.split(&quot;split_on_what_in_regex&quot;, str) Extract characters from a string: &quot;&quot;.join(re.findall(&quot;[a-zA-Z]+&quot;, str)) Data Structures Queue: Python 用的不是 enqueue dequeue，而是 put get 1234import queueq = queue.Queue()q.put(s)v = q.get() Priority Queue: 12from queue import priorityQueueq = PriorityQueue() 函数式编程 python的filter基本用法: lst = list(filter(func, lst)), dct = dict(filter(func, dct)) python3中map()函数用法: map(func, list) Python reduce() 函数 IO 读入多行文件: lines = file1.readlines() 123456789file_path = os.getcwd() + &quot;\\\\&quot; + file_namef = open(file_path, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;)lines = f.readlines()f = open(file_path, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;)f.write(string)f.writelines(lst_of_strs)f.close() 写入csv文件的几种方法 写入csv文件的几种方法总结 获取当前文件夹下所有文件夹名 12filenames = os.listdir(path) NumPy Difference between max and maximum: numpy.maximum(A,B) returns the element-wise bigger one of the two numpy.max(A) returns the maximum value inside A Matrix/Vector Multiplication: np.matmul(A, B): Returns matrix product of A and B np.multiply(A, B): Returns element-wise multiplication of A and B np.dot(A, B): Returns dot product of A and B numpy.diagonal(M): Returns the diagonal of a 2-D matrix M numpy.tile(A, reps): repeats A reps times numpy.where(cond, A, B): condition on array. Really useful function, so is just A if cond else B Solve TypeError: only integer scalar arrays can be converted to a scalar index when you execute a[a == b]: this happens because a is not an np array. It is a list and the message above comes from the list type. reference Pandas1234567891011121314# 直接循环 df 循环的是 col 名for col in df: print(col)# 想要循环每一行的数据应使用 iterrows()# row = (row_index: int, data: pd.Series)for row in df.iterrows(): print(row)# 想要读取某一行的数据使用 loc[i]，返回 pd.Seriesrow0 = df.loc[0]# loc 用来过滤时如果有两个以上条件：只能用&amp;，用and会报错，此外也要用圆括号括起来 df.loc[ (df[&quot;att1&quot;] == &quot;012&quot;) &amp; (df[&quot;code&quot;] == &quot;2A&quot;) ] AttributeError: ‘float’ object has no attribute ‘split’ Mathplotlibimport matplotlib.pyplot as plt Change where y range starts in matplotlib: plt.ylim(bottom = x) Rotate the labels in x-axis by 90 degrees: this trick helps you when you have too long x-axis labels. plt.xticks(rotation = 90 ) Output/Save Plot: plt.savefig(&#39;filename.png&#39;) Change labels, ticks, … 1234567plt.xlabel(&#x27;X axis&#x27;, fontsize=15)plt.ylabel(&#x27;Y axis&#x27;, fontsize=15) plt.xticks(lst_of_tick_position, labels, color=&#x27;blue&#x27;, rotation=60) # disabling yticks by setting yticks to an empty listplt.yticks([]) Different Kinds of Plot: scatter plot: plt.scatter(x,y) histogram: plt.hist(x,y) 普通折线图: 123x = np.arange(-10,10,0.1)y = 2*xplt.plot(x,y)","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"http://yao-lirong.github.io/tags/Logistics/"},{"name":"Python","slug":"Python","permalink":"http://yao-lirong.github.io/tags/Python/"}]},{"title":"Latex 实用技巧手册","slug":"2020-11-23-Latex-实用技巧手册","date":"2020-11-23T05:00:00.000Z","updated":"2022-02-25T04:55:11.547Z","comments":true,"path":"2020-11-23-Latex-实用技巧手册/","link":"","permalink":"http://yao-lirong.github.io/2020-11-23-Latex-%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%E6%89%8B%E5%86%8C/","excerpt":"","text":"排版大括号 $f(x)=\\left{ \\begin{aligned} x &amp; = &amp; \\cos(t) \\ y &amp; = &amp; \\sin(t) \\ z &amp; = &amp; \\frac {x}{y} \\end{aligned} \\right.$ 1234567f(x)=\\left\\&#123;\\begin&#123;aligned&#125;x &amp; = &amp; \\cos(t) \\\\y &amp; = &amp; \\sin(t) \\\\z &amp; = &amp; \\frac xy\\end&#123;aligned&#125;\\right $f(x)= \\begin{cases} 0&amp; \\text{x=0}\\ 1&amp; \\text{x!=0} \\end{cases}$ 12345f(x)=\\begin&#123;cases&#125;0&amp; \\text&#123;x=0&#125;\\\\1&amp; \\text&#123;x!=0&#125;\\end&#123;cases&#125; Sections and Chapters: Usually, \\section is the top-level document command in most documents. However, in reports or books, and similar long documents, this would be \\chapter or \\part. To get an unnumbered chapter / section add an asterisk (*) at the end of the command, like \\section*. 大写字母 双写体: $\\mathbb{R}$ - \\mathbb&#123;R&#125; 粗体: $\\mathbf{R}$ - \\mathbf&#123;R&#125; 花体: $\\mathcal{R}$ - \\mathcal&#123;R&#125; Spacing: roughly an M - \\quad, double “quad” - \\qquad \\; is another spacing specify how many inches - \\hspace&#123;0.1in&#125; Vector: $\\vec{p}$ - \\vec&#123;p&#125; Dots: horizontal dots on the line: $\\ldots$ - \\ldots horizontal dots above the line: $\\cdots$ - \\cdots vertical dots: $\\vdots$ - \\vdots diagonal dots: $\\ddots$ - \\ddots Matrix:$$\\begin{bmatrix} \\sigma_{11} &amp; \\cdots &amp; \\sigma_{1n} \\ \\vdots &amp; \\ddots &amp; \\vdots \\ \\sigma_{n1} &amp; \\cdots &amp; \\sigma_{nn}\\end{bmatrix}$$ 12345\\begin&#123;bmatrix&#125; \\sigma_&#123;11&#125; &amp; \\cdots &amp; \\sigma_&#123;1n&#125; \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ \\sigma_&#123;n1&#125; &amp; \\cdots &amp; \\sigma_&#123;nn&#125;\\end&#123;bmatrix&#125; proportional to: $\\propto$ \\propto tilt / similar to: $\\sim$ \\sim Wrap formula with a box$$\\boxed{h(\\mathbf{x}) = \\operatorname*{argmax}y ; \\hat\\pi_y \\prod{\\alpha=1}^{d} P(x_\\alpha | y)}$$ 1\\boxed&#123; h(\\mathbf&#123;x&#125;) = \\operatorname*&#123;argmax&#125;_y \\; \\hat\\pi_y \\prod_&#123;\\alpha=1&#125;^&#123;d&#125; P(x_\\alpha | y) &#125; Comment in latex: use % Under or above any notation (also can do multiline):$$\\underset{k\\in N}{E}\\overset{wow}{E}\\underset{\\substack{i \\in N \\ j \\in N}}{E}$$ 1234\\underset&#123;k\\in N&#125;&#123;E&#125;\\overset&#123;wow&#125;&#123;E&#125; % to write multi-line, use \\substack\\underset&#123;\\substack&#123;i \\in N \\\\ j \\in N&#125;&#125;&#123;E&#125;","categories":[],"tags":[{"name":"Latex","slug":"Latex","permalink":"http://yao-lirong.github.io/tags/Latex/"}]},{"title":"Algorithm Design 及 CS4820 一般性内容总结","slug":"2020-10-13-Algorithm-Design-及-CS4820-一般性内容总结","date":"2020-10-13T04:00:00.000Z","updated":"2021-02-10T20:16:22.984Z","comments":true,"path":"2020-10-13-Algorithm-Design-及-CS4820-一般性内容总结/","link":"","permalink":"http://yao-lirong.github.io/2020-10-13-Algorithm-Design-%E5%8F%8A-CS4820-%E4%B8%80%E8%88%AC%E6%80%A7%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/","excerpt":"CS 4820 develops techniques used in the design and analysis of algorithms, with an emphasis on problems arising in computing applications. Example applications are drawn from systems and networks, artificial intelligence, computer vision, data mining, and computational biology. This course covers four major algorithm design techniques (greedy algorithms, divide and conquer, dynamic programming, and network flow), computability theory focusing on undecidability, computational complexity focusing on NP-completeness, and algorithmic techniques for intractable problems, including identification of structured special cases, approximation algorithms, and randomization.","text":"CS 4820 develops techniques used in the design and analysis of algorithms, with an emphasis on problems arising in computing applications. Example applications are drawn from systems and networks, artificial intelligence, computer vision, data mining, and computational biology. This course covers four major algorithm design techniques (greedy algorithms, divide and conquer, dynamic programming, and network flow), computability theory focusing on undecidability, computational complexity focusing on NP-completeness, and algorithmic techniques for intractable problems, including identification of structured special cases, approximation algorithms, and randomization. Greedy AlgorithmGreedy Stays AheadGreedy is at least as good as the optimal solution in each step Exchange Argument Take any optimal solution, we can make it exactly the same as our greedy solution without having the optimal solution produce a worse result. There is some “structure” unique to this problem. All solutions have this “structure” give the same number of lateness. Our greedy solution has this “structure” We can exchange any optimal solution to have this “structure” without making this solution worse Divide and ConquerMaster theorem says that for an algorithm with running time $T(n) = aT(\\frac{n}{b}) + f(n)$. $f(n)$ is some polynomial of $n$, so we have $T(n) = aT(\\frac{n}{b}) + O(n^c)$. $a = b^c$: $T(n) = O(n^c ; logn)$ - A balance between constant work at each level and number of subproblems at each level. $a &lt; b^c$: $T(n) = O(n^c)$ - Time dominated by the constant work we do at upper levels: take $a=1$ as an extreme example, all of the time will be spent on top level. $a&gt;b^c$: $T(n) = O(n^{log_ba})$ - Time dominated by each subproblems we have as the recursion go deeper. A lot of branches of subproblems will be generated. Network Flow Max flow 问题转换为 Min Cut 问题，Min Cut 问题永远可以给自己不想要的边 infinite capacity 来将它排除在 min cut 之外。 effectively infinite: 任何一个无法达到的数，都可以视作 infinite，比如 infinite capacity 可以是一个已知的 cut 值+1 (max flow 必然小于任意一个 cut，所以没有任何一个 flow 可以达到 cut + 1) NPProving Reduction Show that your reduction σ takes polynomial time. Show that x is a solution to the problem you are reducing from if and only if σ(x) is a solution to theproblem you are trying to show is NP-hard. You need to show the implication in both directions. Proving NP, NP-Hard, NP-Completeness NP: prove you can verify a solution in polynomial time NP-hard: prove some known NP-Hard (or NP-complete) problem can be reduced to A in polynomial time (注意是别的已知问题可以被转换成我们要证明的问题) NP-completeness: it is NP-hard and it is NP Important NP-Complete Problem satisfiability problems: Boolean satisfiability, CNFSAT (conjunctive normal form satisfiability) , 3CNFSAT (aka 3SAT) graph problems: Clique, Independent Set, Vertex Cover, Dominating Set, Colorability, Planar 3-colorability covering problems: Set Cover, 3-dimensional matching (3DM) tour problems: directed and undirected Hamiltonian circuit (HC), Traveling Salesperson (TSP) numerical problems: Subset Sum (SS), Partition, Knapsack, Bin Packing Tips If a problem asks you to decide if there exists a set of at least k objects satisfying some property, try reducing from another problem that involves picking at least k objects, e.g. Independent Set or Clique. Similarly, if a problem asks you to decide if there exists a set of at most k objects satisfying some property, try reducing from another problem that involves picking at most k objects, e.g. Vertex Cover or Set Cover. When reducing Independent Set / Vertex Cover to another graph-like problem. We find out adding a node representing edges is very useful. (Dominating Set, practicefsol 4, fakesol7 3) When a problem does not easily fit into either of the general categories listed above, usually the best thing to try first is 3CNFSAT. When do the reduction from A to B, try to reduce A to a special case of B. (hw5 P3 Clique -&gt; Submatrix Domination, hw6 P2 Vertex Cover -&gt; Dominating Set) Turing MachineDecidabilityGive a total Turing Machine (one that always halts) to accept any “yes” instance and reject any “no” instance Undecidability Prove by Diagonalization Prove by Reduction: we usually reduce our problem to Halting Problem or the complement of it (Non-Halting Problem aka. Looping Problem). Note: σ in this case has to be computable instead of polynomial-time To prove some problem is undecidable within a certain time bound, use clocked diagonalization. Crucial FactsMinimum Spanning Tree cut property: Let A and B partitions vertices V, if e is the minimum edge connecting A and B, e must be in every minimum spanning tree. cycle property: Let C be any cycle in G, e be the maximum cost edge on that cycle, e is not in any minimum spanning tree Proof Techniques Loop Invariant and Recursion: 一个很好的例子是 T7.42 的证明 recursion = inductionloop invariant = induction hypothesistermination condition = basis computation = logic -- Dexter Kozen","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"CS4820","slug":"CS4820","permalink":"http://yao-lirong.github.io/tags/CS4820/"}]},{"title":"INFO1998 Intro to Machine Learning","slug":"2020-10-02-INFO1998-Intro-to-Machine-Learning","date":"2020-10-02T04:00:00.000Z","updated":"2021-02-10T20:12:14.962Z","comments":true,"path":"2020-10-02-INFO1998-Intro-to-Machine-Learning/","link":"","permalink":"http://yao-lirong.github.io/2020-10-02-INFO1998-Intro-to-Machine-Learning/","excerpt":"The goal of this course is to provide you with a high-level exposure to a wide range of Data Science techniques and Machine Learning models. From the basics of getting your Jupyter environment setup, to manipulating and visualizing data, to building supervised and unsupervised models, this class aims to give you the base intuition and skillset to continue developing and working on ML projects. We hope you exit the course with an understanding of how models and optimization techniques work, as well as have the confidence and tools to solve future problems on your own.","text":"The goal of this course is to provide you with a high-level exposure to a wide range of Data Science techniques and Machine Learning models. From the basics of getting your Jupyter environment setup, to manipulating and visualizing data, to building supervised and unsupervised models, this class aims to give you the base intuition and skillset to continue developing and working on ML projects. We hope you exit the course with an understanding of how models and optimization techniques work, as well as have the confidence and tools to solve future problems on your own. Lec2 Data ManipulationIntroduction to Pandas Series: one dimensional array DataFrame: 2-D table Filtering DataFrames: loc Cleaning-Up DataFrames: df.dropna(), df[df[&#39;Open&#39;].notnull()] (These two methods both return a new DataFrame instead of modifying the existed one) View DataFrames: head, tail, … Summary Statistics: mean, median, … describe Dealing with missing data Fill in some random info of our choice: 12#if we there is no record about which cabin he is in, we assume he is on the Top Deckdf[&#x27;Cabin&#x27;]=df[&#x27;Cabin&#x27;].fillna(&#x27;Top Deck&#x27;) Using summary statistics: fill missing entries with median or mean works well with small set Use regression and clustering: will be covered later Lec3 Data VisualizationTypes of Graphs Heatmap Correlation Plots Coloring Graphsplt.scatter(Longitude, Latitude, c=Temp.values.ravel(),cmap=plt.cm.OrRd) color a scattered plot based on values of Temp with color scheme cm.OrRd. Find more color schemes from matplotlib manual. Lec4 Linear RegressionPreparing Data12345678910from sklearn.linear_model import LinearRegressionfrom sklearn.model_selection import train_test_split# X must be a table (in case there are multiple x in y = a1*x1 + a2*x2 + ... + k)X = data[[&#x27;cost&#x27;,&#x27;compl_4&#x27;]] # Y must be one columnY = data[&#x27;median_earnings&#x27;] from sklearn.model_selection import train_test_split# test is 20% of all datax_train, x_test, y_train, y_test = train_test_split(X, Y, test_size=0.2) Predicting and Fitting12345678# creates Linear Regression model LR = LinearRegression()# note LR is an object by calling fit, we set all of its coefficientsLR.fit(x_train, y_train)# predict() returns the predicted valuey_predicted = LR.predict(x_test)# score(x,y&#x27;) first computes the predicted value y based on x and our model, then compare it with y&#x27;score = LR.score(x_test,y_test) Describing the Model12345678# Gives a comprehensive view of Y = a1*x1 + a2*x2 + ... + kLR?# coefficients of x (a1, a2, ...)LR.coef_# intercept kLR.intercept_ Lec5 Measuring Model’s AccuracyWhen determining accuracy, usually want to compare our model to a baseline. Therefore, instead of comparing our model’s prediction to each specific y value, we compare it with the mean y value. 123456from sklearn.metrics import mean_squared_errorcelcius_MSE = mean_squared_error(y_test, celcius_predictions)test_goal_mean = y_test.mean()baseline = np.full((len(celcius_predictions),), test_goal_mean)baseline_MSE = mean_squared_error(baseline, celcius_predictions) overfitting: too specific to the data given, doesn’t predict any other data underfitting: no matter what data you use to train this model, it gives the same curve, so it doesn’t have prediction power either because it doesn’t show any pattern of the data. Lec6 ClassifiersLinear regression is used to predict the value of a continuous variable. Classifiers are used to predict categorical or binary variables. KNN12345678from sklearn.model_selection import train_test_splitfrom sklearn.neighbors import KNeighborsClassifierx_train, x_test, y_train, y_test = train_test_split(X,Y, test_size=0.2)k = 10model = KNeighborsClassifier(k) # specify k nearest elementsmodel.fit(x_train,y_train)predictions = model.predict(x_test) Lec7 Other Supervised Learning ModelsDecision Trees123from sklearn import treefrom sklearn.tree import DecisionTreeClassifiermodel = tree.DecisionTreeClassifier(max_depth=5) How to reduce overfitting? Reduce levels of trees Train multiple decision trees (maybe one for each training data) and take its average as final result Logistic RegressionValue always between 0 and 1. Accept if value higher than threshold, reject if lower. K-fold Cross ValidationRather than doing test-train split only once, we do it k times: First separate our sample into k pieces and each time we take one of them as test set, the others as training set. Use from sklearn.model_selection import KFold to achieve this. Calculate a score for each of the split and take its average as the final score. This score is usually closer to real errors. 12345678910111213141516171819202122from sklearn.model_selection import KFoldfrom sklearn.metrics import mean_squared_error, accuracy_scoreincX = inc_data[[&#x27;education.num&#x27;]]incY = inc_data[&#x27;income&#x27;]kf = KFold(n_splits = 5)accuracy = 0for train_index, test_index in kf.split(incX): X_train = incX.iloc[train_index] Y_train = incY.iloc[train_index] X_test = incX.iloc[test_index] Y_test = incY.iloc[test_index] # best_depth 是我们前一题找到的使分最高的 depth level of decision tree model = tree.DecisionTreeClassifier (max_depth = best_depth) model.fit(X_train, Y_train) pred_test = model.predict(X_test) accuracy += accuracy_score(Y_test, pred_test) accuracy /= 5print(accuracy) Lec9 Unsupervised Learning Supervised Learning: The desired solution (target) is also included in the dataset Unsupervised Learning: The training data is unlabeled and algorithm tries to learn by itself Hierarchical ClusteringHierarchical clustering groups observations into multiple levels of sets; the top-level set includes all of the data, and the bottom-level sets contain individual observations. The levels in between contain sets of observations with similar features. 1234567891011from sklearn.preprocessing import StandardScalerfrom scipy.cluster.hierarchy import dendrogram, linkagefrom matplotlib import pyplot as plt# Standardize features by removing the mean and scaling to unit variancedata = StandardScaler().fit_transform(data)# build our model from dataclust = linkage(data) # draw the dendrogram visulizationdendrogram(clust)plt.show() K-Means ClusteringWe want to cluster the data into k groups. We first randomly choose k points in this dataset. Then we assign other data points to the group they are closest to. After assigning all data points to some group, we recompute the center of each group by taking the means of all points in that group. Repeat this process until no points change group assignment after one iteration. 1234from sklearn import clusterk = 3kmeans = cluster.KMeans(n_clusters = k) #cluster into k groupskmeans.fit(data)","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"20FA","slug":"20FA","permalink":"http://yao-lirong.github.io/tags/20FA/"},{"name":"Python","slug":"Python","permalink":"http://yao-lirong.github.io/tags/Python/"}]},{"title":"Add \"Open with Windows Terminal\" to Right-Click Menu","slug":"2020-09-29-Add-Open-with-Windows-Terminalto-Right-Click-Menu","date":"2020-09-29T04:00:00.000Z","updated":"2020-10-02T12:57:07.733Z","comments":true,"path":"2020-09-29-Add-Open-with-Windows-Terminalto-Right-Click-Menu/","link":"","permalink":"http://yao-lirong.github.io/2020-09-29-Add-Open-with-Windows-Terminalto-Right-Click-Menu/","excerpt":"Windows Terminal Preview now provides native support of this feature.","text":"Windows Terminal Preview now provides native support of this feature. Download the icon here Move the icon to directory C:\\Users\\&lt;your username&gt;\\AppData\\Local\\WindowsTerminal Create a .reg file and run it. 123456789Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt]@=&quot;Open with Windows Terminal&quot;&quot;Icon&quot;=&quot;C:\\\\Users\\\\&lt;your username&gt;\\\\AppData\\\\Local\\\\WindowsTerminal\\\\terminal.ico&quot;[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt\\command]@=&quot;C:\\\\Users\\\\harmo\\\\&lt;your username&gt;\\\\Local\\\\Microsoft\\\\WindowsApps\\\\wt.exe&quot; In Windows Terminal’s settings, Add &quot;startingDirectory&quot; : &quot;.&quot; into defaults list: 1234&quot;defaults&quot;: &#123; &quot;startingDirectory&quot; : &quot;.&quot; &#125;, Reference How to Add Open Windows Terminal Here Option to Right-click Menu Add “open Windows terminal here” to right-click context menu 将”在此处启动Windows Terminal”添加到右键菜单","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"http://yao-lirong.github.io/tags/Logistics/"}]},{"title":"CS2024 C++ Programming","slug":"2020-09-07-CS2024-C++-Programming","date":"2020-09-07T04:00:00.000Z","updated":"2021-09-01T23:39:32.181Z","comments":true,"path":"2020-09-07-CS2024-C++-Programming/","link":"","permalink":"http://yao-lirong.github.io/2020-09-07-CS2024-C++-Programming/","excerpt":"The goal of CS2024 is to teach as much of the C++ language as possible with an eye towards your being able to use it effectively in future classes that may depend on it and/or in a professional setting. C++ is ever changing with new standards released every three years. We look to strike a balance between making sure you thoroughly understand “historic” C++ as well as introducing you to new features enabled in the language in the past decade.","text":"The goal of CS2024 is to teach as much of the C++ language as possible with an eye towards your being able to use it effectively in future classes that may depend on it and/or in a professional setting. C++ is ever changing with new standards released every three years. We look to strike a balance between making sure you thoroughly understand “historic” C++ as well as introducing you to new features enabled in the language in the past decade. Lec01 IntroductionExplaining our First Program #include &lt;iostream&gt; Tells the compiler that we would like to load definitions from a header file named “iostream”. The # (pound sign) indicates this is a preprocessor directive, it gets dealt with BEFORE your code is compiled std::cout &lt;&lt; “Hello World!” &lt;&lt; std::endl; &lt;&lt; is an operator that directs content from the right to the left. In this case, we direct the string “Hello World” to std::cout, which is the console Compiling C++ Windows: use Visual Studio Linux: g++ -std=c++11 -lstdc++ -o demo1 demo1.cpp: -o specifies the name of the compiled file Compiler takes the text of the source code and converts it into a binary object so that it can execute it a bit more efficiently. Lec02 Input/Output and OperatorsInput and Output &gt;&gt; stream extraction operator std::cin &gt;&gt; k take a value from cin, which is the input stream keyboard, and assign it to k getline(cin,str): cin uses space as delimiter so it won’t read in a whole line. Use this to read a full line Usingusing is similar to import in java, so that you don’t have to use the full name of a function when calling it. 1234567using std::cout;using std::endl;int main(int argc, char *argv[]) &#123; // No longer need to use the std:: prefix cout &lt;&lt; “Hello World” &lt;&lt; endl;&#125; Lec03 Introduction to ClassesStructC-Style structure definition: (Define a structure called Course, which has three fields ) 12345typedef struct &#123; string name; string instructor; int numStudents;&#125; Course; ClassesVariables defined inside that class are called member variables. Functions defined inside the class are called member functions Public vs. Privatepublic and private keywords can appear as many times as you want in the class definition. 1234567891011class Course &#123;public: // These can be seen outside the class // Define member functions int getStudentCount() &#123; return numStudents; &#125;private: // These can be seen inside the class only // Define member variables string name; string instructor; int numStudents;&#125; Declaration and Definition of Member FunctionsYou don’t have to define the functions where they are declared. Instead, you can define them outside of the class declaration. When you define them outside of the class declaration, you can still access the member variables inside that class. That’s because you are telling the compiler that this is a member function. 12345678910111213141516class Course &#123;public: // These can be seen outside the class // Define member functions int getStudentCount(); void setStudentCount(int count); private: ...&#125;string Course::getCourseName()&#123;return name;&#125;int Course::getStudentCount()&#123;return numStudents;&#125; You usually want to define your getter and setter functions inside class definition. When other functions you are trying to define are too big, we usually define them outside the class definition and usually in a separate file. So we declare the functions in header file **.h and define them in another file **.cpp 123456789101112/* &lt;Courses.h&gt; */class Course &#123;private: void complexLogic();&#125;/* &lt;Courses.cpp&gt; */#incldue &quot;Courses.h&quot;void Courses::complexLogic()&#123; ...&#125;; ConstructorsConstructors have to have the same name as the class. Constructors have no return type. You can define Constructors outside of class definition too. Constructors are called when you declare an instance of that type: MyClass instance. Note defining a pointer of that class without allocating memory to that pointer MyClass *p will not call the constructor, but declaring a pointer and allocating memory will call the constructor, because that’s the real time an instance is created MyClass *p = new MyClass(). Lec5 Functions IEnumIf you don’t assign values to the ones following the first, they will all have value of previous increment 1. 12345678// Define error codesenum RonsError &#123; cNoError = 0, // Values are optional, default is 0 cBadArg, // If a value is not present, cBadResult, // assign previous value + 1 cUnknownErr&#125;; In C++11, we can use the class keyword to define sort of a “namespace” for the enum. 12345678enum class Months &#123; JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC&#125;if ((month == Months::DEC) || (month &lt; Months::MAR)) ...Months get_march()&#123; return Months::MAR;&#125; Function Declaration and Definition Revisited123456789101112// mymath.h -- header file for math functionslong squareIt(long);// mymath.cpp -- implementation of math functionslong squareIt(long x)&#123; return x * x;&#125;// main.cpp#include “mymath.h”void main()&#123; cout &lt;&lt; “5 squared is “ &lt;&lt; squareIt(5) &lt;&lt; endl;&#125; You should never include a “.c++” file in another c++ file. Lec6 Function IIInline Functions12345inline int performAddition(int x,int y) &#123; return x+y;&#125; Wherever this function is called the compiler has the option of replacing the call with the body of the actual function, instead of creating a memory stack for that function call and etc. The compiler may not do that when it’s a recursive call or that function is really long. Pass By ReferenceWhy and when do you want to use pass by reference? You need to return multiple values. C++ only allows you to return one value. So you send those values as pass by reference parameters You are passing a large structure/class. When passing values, the compiler will make a copy of those structure/class and pass them, which takes up a lot of stack space. In the second case, maybe you don’t want to change anything in the structure, but passing by reference makes such a mistake likely to happen. To fix this, you can declare this passed by value as const, so when you accidentally modify it, you will get a compile-time error. 12345bool isBusy(const BIGDataType &amp;arg1)&#123; if (arg1.busyField = 0) return true; return false;&#125; Default ArgumentWhen we declare a function, we can set a default value to its argument. (Don’t set a default value in function definition) 12345678910class Counter &#123; … void increment(int incrementBy=1); … &#125;;void Counter::increment(int incrementBy);&#123; mycount += incrementBy;&#125; x.increment(); // increment x by 1 y.increment(2); // increment y by 2 Unary Scope OperatorWhen you have 3 variables with the same name defined in global scope, local scope, and a nested scope inside local scope and you want to access the variable in the global scope inside some scope, you can use the :: before calling this variable. There is no way for you in the nested scope to access the variable with a same name in local scope (parent scope). 123456789int x=1; // in the global scopeint main(int argc, char *argv[]) &#123; int x = 6; // local variable to main() // cannot be accessed in the following nested scope &#123; int x = 5; // local variable in a sub-scope of main() cout &lt;&lt; “x is : “ &lt;&lt; ::x &lt;&lt; endl; // &quot;x is : 1&quot; &#125;&#125; Lec7 Function IIIFunction Templates1template &lt;typename a,typename b,…&gt; return_type function_name (formal args) At compilation time the compiler will look at your code and generate a separate function for each type used throughout your code when calling template functions. For example, for this maximum below, when the compiler sees the call to maximum(3,5,8), it uses the function template to automatically generate an overloaded version of maximum() that takes three variables of type int as its arguments. 12345678910template &lt;class T&gt; T maximum(T val1, T val2, T val3)&#123; T maxValue = val1; if (val2 &gt; maxValue) maxValue = val2; if (val3 &gt; maxValue) maxValue = val3; return maxValue;&#125;return maximum(3,5,8); Lec8 Arrays and VectorsArraysArrays don’t have boundary checking. 12345678910111213#include &lt;array&gt;// initializationconst int size = 5;array&lt;int,size&gt; myArray;// range based for-loopfor (int item : myArray) cout &lt;&lt; “Next item is: “ &lt;&lt; item;// sorting and searchingsort(myArray.begin(),myArray.end()); //ascending orderbool found = binary_search(myArray.begin(),myArray.end(),2); Vectors123456#include&lt;vectors&gt;vector&lt;int&gt; primeVector&#123;2,3,5,7,11,13&#125;; primeVector[6] = 17; //valid syntax but can crash the programprimeVector.at(6) = 17; //involves boundary checking and throw an error Lec9 PointersDynamic Allocation123int *iPtr; // declares a pointer to intiPtr = new int; // &quot;new int&quot; gives a dynamically allocated instance of int // then we assign this space to iPtr Note: in the above example, a memory in the heap is allocated to this pointer iPtr contains one of the following: A pointer to the newly allocated data type (in this case, an int) NULL (if the pointer could not be allocated due to insufficient memory) We should always check whether it is NULL before using a dynamically allocated pointer. We can use delete iPtr to dispose a dynamically allocated pointer. 12345int *iPtr; // iPtr points to some random memoryiPtr = new int; // iPtr points to some memory allocated to it in heap*iPtr = 5; // write 5 to the memory iPtr is allocated todelete iPtr; // release the memory assigned to iPtr / iPtr now no longer points to that memoryreturn 0; Pointers to Already Existing ValuesExisting values are in stack frame, so when our pointers point to something already existed, they point to something in the stack frame, but remember variables in stack frame can disappear when out of scope. 12345678int main()&#123; int *iPtr; if (true) &#123; int p = 5; iPtr = &amp;p; &#125; cout &lt;&lt; “*iPtr is “ &lt;&lt; *iPtr &lt;&lt; endl;&#125; So the danger is you will have to know how long this stack frame will live, or you will lose track of what you are pointing to and end up pointing something totally irrelevant. Common Confusion with * int *p - declaring a pointer: The star is part of the type name, and says that we want a pointer to some other type (in our example, int * is the type of p). r = *p - dereferencing a pointer (RHS): The star is the dereference operator. This assignment gives the variable r a new value, namely the value inside the box that the pointer p points to. *p = r - dereferencing a pointer (LHS): The star is the dereference operator. This assignment changes the value inside the box that p points to be a new value, namely the value of the variable r. Pointer Chaos12345678910111213141516int *a = 5, *b = 7;// dereference a, get the value stored in the memory a is pointing to,// and write a same value to the memory b is pointing to *b = *a; // let b point to the same address as a is pointing tob = a; // release the memory allocated to a, // also doing that for b since they are pointing at the same thingdelete a; // throw &quot;pointer being freed is not allocated&quot; error// since we already deleted it when we did that for adelete b; Pointers to User-Defined TypesWhen we want to use member member (functions/ variables), we can use one of the following: 123Course *aCourse = new Course;(*aCourse).setStudentCount(45);aCourse-&gt;setStudentCount(45); Passing Pointers as Arguments1234567int *a = new int;int x = 5;// store 0 in the memory location pointed at by intPtrvoid setToZero(int *intPtr) &#123; *intPtr = 0; &#125; setToZero(a); // pass to it a pointer whose value is some addresssetToZero(&amp;x); // pass the address of some variable to it Const with PointersPrinciple of Least Privilege: Any operation you do should only be given the opptunity to happen if it absolutely needs to. Following this principle, we don’t want to give writing privilege to functions doing reading. There are four possibilities between constant/non-constant pointers pointing to constant/non-constant data: 12345678910111213141516171819202122232425262728293031// Non-Constant Pointer, Non-Constant Data// Free for the pointer to point to something else,// Free for the data it is pointing to be written as something elseint *intPtr = new int;// Non-Constnat Pointer, Constant Data// We can’t modify the data pointed at by coursePtr// We CAN set coursePtr to a different valuevoid printAllCourseData(const Course *coursePtr, const int size)&#123; // For this function, maybe we will direct pointer to some other course // once one course&#x27;s info has been printed, // while we don&#x27;t want to change that info // because this is just a reading function&#125;// Constant Pointer, Non-Consant Data// Pointer can only point to a specific memory// The data it is pointing to can be changedvoid setupCourse(Course *const coursePtr)&#123; // For this function, we only want to change information of this course passed in.&#125;// Constant Pointer, Constant Data// We can’t modify the data pointed at by coursePtr// We can’t set coursePtr to a different value eithervoid printCourseData(const Course *const coursePtr)&#123; // We only want to print out the info of this course passed in and do nothing else&#125; Lec10 Classic Arrays and Pointer ArithmeticClassic Array12int *j[4]; == (int *) j[4]// array of 4 pointersint (*p)[4]; // a pointer to an array of 4 integers Arrays are somewhat pointers. For example, if we have int b[10], b always points to the first element in this array: b == &amp;b[0] Pointer ArithmeticFor any array p[n] == *(p+n). In particular, *(p+n) gives the contents of we have after advancing n steps from p. In fact, we also have p[n] == n[p], because our a[m] is just a syntactic sugar for *(a+m) Dynamic Allocation of Arrays123int a1[8] = new int; // WRONGint *a = new int[8]; // RIGHTdelete [] a; // Must use this, ”delete a” is undefined There are more scope issues when you use arrays as pointers. For example, the following code returns a pointer to something inside current call stack frame. It will disappear when out of the scope. Therefore, the returned pointer from function MakeArray() actually points to something undefined. 123int *MakeArray() &#123; int iArray[50]; return iArray; &#125; The following code behaves differently. Instead of returning a pointer to something in the call stack, it returns something in the heap, which will not disappear after the function finishes execution. 123int *MakeArray(int size) &#123; int *anArray = new int[size]; return anArray; &#125; Passing Arrays as ParametersSince arrays are pointers, you can only pass the real array to a function. There is no concept of passing a copy of that array. These are standard ways of declaring a function taking in arrays as its parameters. 12void swap(int *A, int j, int k);void swap(int A[], int j, int k); Memory Allocation with malloc and sizeof malloc is a function for dynamic memory allocation and it only takes in byte. sizeof(SomeDataType) returns the number of bytes this data type needs. Say we want to declare an array of 6 Courses in heap here. 12Course *courseArray = malloc(sizeof(Course) * 6); // Old C way to initialize array in heapCourse *courseArray = new Course[6]; // The C++ way to do it Lec11 Classes – A Deeper Look1clang -std=c+11 -lstdc++ -c MyString.cpp Implicit InlineWhen you define a function right in the class definition, you make this function implicitly inline. Therefore, there’s no actual method/function created; the code of the method is substituted through the rest of the code wherever that method is called. Multiple ConstructorsYou can use a delegate constructors to save yourself from writing duplicate code. It will just call that constructor, if the delegate constructors take in arguments, you can just pass in those arguments there. 123456789101112131415// older c++ styleMyString::MyString(string initValue) : MyString() &#123; if (growStorage(initValue.length())) &#123; strcpy(storagePtr, initValue.c_str()) stringLength = initValue.length(); &#125;&#125;// c++ 11 styleMyString::MyString(string initValue) : MyString&#123;&#125; &#123; ... &#125;&#125;// Another ExampleMenu::Menu(MenuItem* list[], int n, char prom, string title) : MenuItem(prom, title)&#123; for (int i = 0; i &lt; n; i++) items.push_back(list[i]);&#125;; DestructorThe destructor is a special method (similar to constructor) that is called just before an object is destroyed. There is only one destructor per class (can’t overload). It takes no arguments. A destructor should be used to clean up any dynamically allocated resources (memory, OS objects). You call the destructor when using delete keyword. Passing and Returning ReferencePassing ReferenceIf you modified a parameter passed by reference in a function, the change would persist in the calling function. Note that the way we call this function has not changed. We still pass in two strings instead of pointers. You don’t have to do anything differently to specify that the string arguments are being passed “pass-by-reference” when I call the function; I only need to specify that I want to use pass-by-reference when I declare the getTimeAndTemp function. 12345678void getTimeAndTemp(string &amp;time,string &amp;temp)&#123; time = getTheREALTime(); temp = getTheREALTemp();&#125;int main() &#123; string theTime,theTemp; getTimeAndTemp(theTime,theTemp); // theTime and theTemp will be changed.&#125; Returning ReferenceWhen we add a &amp; before the function name, the function still returns whatever type it returns, but now the function call can appear on left side of assignment operator and we can write a new value to the memory address the returned value is stored in. For the following example, charAt still returns a char type. The only difference is that we can now directly change the returned value stored in the object by using the assignment operator. 123456789101112char &amp;MyString::charAt(int index) &#123; // boundary checking is omitted for clarity return storagePtr[index];&#125;int main() &#123; MyString str(“Hello World!”); char c =str.charAt(11); cout &lt;&lt; c; // &#x27;!&#x27; str.charAt(11) = ‘?’; // legal because we are returning reference cout &lt;&lt; str.charAt(11); // &#x27;?&#x27; cout &lt;&lt; “str is now: “ &lt;&lt; str.MakeString() &lt;&lt; endl; // Hello World?&#125; const in class As a qualifier to a member variable. It means that the member variable cannot be changed As a qualifier to a member function. It means that the member function cannot change anything in the class: 1string getName() const &#123; return mName; &#125; static in class There is ever only one copy of that variable that is shared among all the instances of the class. The storage for this variable must be declared in the global scope using the fully qualified name of the variable (classname::static_variable_name) The shared copy of the variable can be accessed either as a field of any instance or using the fully qualified name of the variable 123456789101112// &quot;Person.h&quot;class Person &#123; static int number_of_persons;&#125;// &quot;Person.cpp&quot;int Person::number_of_person = 0; // &quot;main.cpp&quot;cout &lt;&lt; Person::number_of_person; // 0Person p(&quot;Harmony&quot;); // increment number_of_person by 1 in the constructorcout &lt;&lt; p.number_of_person; // 1 this in class Its “type” is pointer to class type. So, if we have a Person class, Person has an implicitly defined member variable named this that is of type Person * Any of the member variable and functions in the class can be referenced from this Lec12 Operator OverloadsUnary Operator Overloadswe just have to use the operator keyword. 1234567891011// &quot;MyString.h&quot;int operator~();std::string operator+();// &quot;MyString.cpp&quot;int MyString::operator~()&#123; return stringLength;&#125;string MyString::operator+()&#123; return MakeString(); // returns a std::string from our MyString instance&#125; Binary Operator OverloadsWe define most binary operator overloads globally when it doesn’t make “sense” which of the two instances of the operands should “host” the overload. (Expressions on both ends are to some extent equal to the other) We use inline to allow us to place this in the header file without causing multiple definition errors, so we are never really “defining” it, but just replace the code whenever it is called. 12345678inline MyString operator+(const MyString &amp;str1, const MyString &amp;str2) &#123; // use the overloaded unary + sign to return a std::string // then use the std::string overloaded binary + sign to concatenate two strings MyString temp( (+str1) + (+str2) ); return temp;&#125; Here we have an instance of binary overload not done globally. It is a “binary operator” but only takes one argument. 123T &amp;operator[](int i) &#123; return *(mStoragePtr + i); // equivalent to return mStoragePtr[i];&#125; Copy ConstructorsWhenever we use the assignment operator to initialize a variable when it is declared, the compiler actually looks for a constructor that takes in a single argument that matches the type of the value you are assigning to the newly declared instance. If we have MyString str2 = 1;, the compiler would look for a constructor for MyString that took a single integer: MyString::MyString(int arg). If you copy constructors take in some object, it must be pass-by-reference! 123456789Point::Point(Point &amp;anotherPoint) &#123; // ...&#125;int main()&#123; Point p1(4,5); // will use our custom constructor Point p2(p1); // will use the copy constructor (just as a constructor function) Point p3 = p1; // will use the copy constructor&#125; Overloading Assignment =Rather than initialize some variable, we want now to assign a new value to an existing variable. Rather than a global function, we will define it as a member function in our class. 1234567MyString &amp;MyString::operator=(const MyString &amp;sourceStr)&#123; // convert sourceStr to a std::String with our predefined unary + // setValue takes a C++ string // return the address of this object setValue(+sourceStr); return *this;&#125; Overloading Stream Direction &lt;&lt; and &gt;&gt;123456789101112131415inline ostream&amp; operator&lt;&lt;(ostream &amp;os, MyString &amp;str) &#123; os &lt;&lt; +str; // we must always return the stream that was passed in. That allows &quot;chaining&quot;(cout&lt;&lt;a&lt;&lt;&quot;good&quot;&lt;&lt;endl;) to work return os;&#125;inline istream&amp; operator&gt;&gt;(istream &amp;is, MyString &amp;str) &#123; int allocatedSpace = str.getAllocatedSpace(); char *tempBuf = new char[allocatedSpace]; // allocate temp is.get(tempBuf,allocatedSpace-1); // read from instream into location of tempBuf [tempBuf] up to [tempBuf + allocatedSpace - 1] string tempStr = tempBuf; // convert tempBuf to a std::string str.setValue(tempStr); // set str of MyString class to be tempStr delete [] tempBuf; // delete temp memory, realease space return is; // return stream&#125; Lec13 InheritanceBasic Syntax12345678910class DerivedClass : public BaseClass&#123; &lt;member variables unique to Derived Class&gt; ...&#125;;class Student : public Person&#123; int studentID;&#125;; OverrideWe can override a function by just reimplementing it in our derived class. To access the original implementation from the base class, we use its fully qualified name in the derived class. 123456789101112void Person::printInfo()&#123; cout &lt;&lt; “Name: “ &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; “Addr: “ &lt;&lt; address &lt;&lt; endl; cout &lt;&lt; “Phone: ” &lt;&lt; phone &lt;&lt; endl; &#125;;void Student::printInfo()&#123; Person::printInfo(); cout &lt;&lt; “Student ID: “ &lt;&lt; studentID &lt;&lt; endl;&#125;; Virtual FunctionsSay we overwrite the printInfo function in Person and define a global function that takes in a Person class and call the printInfo function on that class. When we pass a Student instance to it, it will actually use the printInfo function of Person instead of Student. That’s because the compiler thinks the function just takes in a Person. 1234567void printPersonInfo(Person &amp;aPerson)&#123; aPerson.printInfo();&#125;;Student s;printPersonInfo(s); // prints out Name, Addr, Phone If you want to use the overridden version of the function, you will have to declare the function in base class as a virtual function. By defining a virtual function, we tell the compiler to call the overridden version no matter what type that instance may be cast to. However, to achieve this effect, we should also pass in an reference or pointer of instance of our derived class. Only in this way can the compiler knows what type our object was declared as. If we just pass by value (a copy of that instance), it will create a copy of our instance with whatever type specified in the function. More specifically, it calls the copy constructor of the specified class. It has no knowledge of what the original type of the argument was. 123456789class Person&#123; virtual void printInfo();&#125;void printPersonInfo(Person &amp;aPerson) // use overriden versionvoid printPersonInfo(Person *aPerson) // use overriden versionvoid printPersonInfo(Person aPerson) // use function in Person; //in fact in the last function, aPerson only has the &quot;Person&quot; part and doesn&#x27;t contain any information specific to the derived class Lec14 PolymorphismWe can dynamically allocate an instance of the derived class and store it in a base class pointer variable. Since Instructor is derived from Person, this is legal. 12Person *aPerson = new Student(); // a pointer of base class(Person) pointing to its derived class(Student)aPerson-&gt;printInfo(); // calls the overridden method in derived class Abstract ClassWe can make a function to be pure virtual (abstract) by adding a = 0 after its declaration. Any new class derived from this class must implement pure virtual methods if the class is going to work. A class with pure virtual functions is an abstract class. Virtual DestructorsIf you have an abstract class, you would need to have an abstract/virtual destructor. That is because when a derived class’s destructor is called, it will (implicitly) call destructors in all base classes it inherits from as well. 12345// Person.hvirtual ~Person() &#123;cout&lt;&lt;&quot;base class destructor called&quot;&lt;&lt;endl;&#125;// Student.h~Students() &#123;cout&lt;&lt;&quot;derived class Studenet destructor called&quot;&lt;&lt;endl;&#125; Lec15 StreamSimple Stream I/O put/get: For any stream, the simplest I/O routines let you input or output one character at a time. End of File eof: a special character (usually has value -1) that signals you’ve reached an end of file state. When we reach eof, we cannot read any further from the file. (Ctrl+Z on Windows, Ctrl+D on other OS) getline: pass in a whole line of characters ( read in until encountering with a \\n) When you type in “This” while running the following code without hitting Enter, it will not print anything, because all characters you typed in have not been sent into the buffer yet. After you hit Enter, “This” will be echoed back. So everything got sent into the buffer, we get one out of it each time, and put it to the outstream, repeat the process until we encounter an eof (Ctrl+Z). 1234while (!cin.eof()) &#123; char c = cin.get(); cout.put(c);&#125; Error HandlingOnce an cin attempt failed, an error flag is set and future attempts to get input will fail. Failure happens when type entered doesn’t match the type of the variable you are assigning value to. cin.fail(): returns true if the last cin assignment failed. cin.clear(): repairs the stream by clearing the error flag in cin. cin.ignore(n, c): ignores the following n characters or one c character. Therefore, cin.ignore(100,&#39;\\n&#39;) ignore all input until you’ve already ignored 100 of them or ignore 1 ‘\\n’ character. 123456cin &gt;&gt; id;while (cin.fail() || id&lt;0 || id&gt;99) &#123; cin.clear(); cin.ignore(99, &#x27;\\n&#x27;); cout &lt;&lt; &quot;invalid number, try again &gt; &quot;; cin &gt;&gt; id;&#125; Int Stream Manipulator dec: decimal, base 10 oct: octal, base 8 hex: hexadecimal, base 16 setbase(n): set to n base These stream manipulators are “sticky”. They will remain the format of your output (even though you start another sentence of cout), until you set another stream manipulator. 123cout &lt;&lt; oct &lt;&lt; 8; //10cout &lt;&lt; 9; // 11cout &lt;&lt; setbase(10) &lt;&lt; 16; // 16 Float Stream Manipulator fixed: print out float number in decimal/fixed point notation scientific: print out float number in scientific notation setprecision(n): always print out 3 digits after the decimal point They are all “sticky”. You’ll have to manually set it back to previous state. 123int curPrecision = cout.precision(); // current settingcout &lt;&lt; setprecision(2) &lt;&lt; 3.12545 &lt;&lt; endl; // 3.13cout.precision(curPrecision); // Restore original setting Fixed Width left: align to left, the output is padded to the field width appending fill characters at the end right: align to right, the output is padded to the field width by inserting fill characters at the beginning These two stream manipulators are sticky. We also use setw(n) to make sure at least n characters are printed. If the string to print has fewer than n characters, fill with space. If it has more than n characters, print everything. setw(n) is not sticky. That’s because most output methods automatically calls setw(0) each time you call them. setw(n) is in the library #include &lt;iomanip&gt; . 123456789#include &lt;iomanip&gt;int n = -77, m = 13579;cout &lt;&lt; setw(6) &lt;&lt; left &lt;&lt; n &lt;&lt; endl;cout &lt;&lt; setw(6) &lt;&lt; right &lt;&lt; n &lt;&lt; endl;cout &lt;&lt; setw(2) &lt;&lt; m &lt;&lt; endl;//-77 // -77//13579 Custom ManipulatorManipulators are just globally defined functions that take an ostream reference and return an ostream reference. Following are some examples: 12345678ostream&amp; beep(ostream &amp;output)&#123; return output &lt;&lt; “\\a”;&#125; // displaying \\a causes beepostream &amp;aReallyLongTokenForNewline(ostream &amp;output)&#123; return output &lt;&lt; “\\n”;&#125;cout &lt;&lt; “This will cause a beep: “ &lt;&lt; aReallyLongTokenForNewLine;cout &lt;&lt; beep; Lec16 Functional Programmingauto keywordThe auto keyword is used to declare a variable whose type is determined by the value it is initialized to. It must be initialized at the moment it is declared (or it will cause a static time compiler error). 12auto f = 3.14 // f is made a doubleauto k; // NO INITIALIZER – This would be a compiler error Function PointersWhen we define a function pointer, we need to define its return type and what type of arguments it takes in: return_type (* function_name) (argument_type1, argument_type2, ...). Note: All these parameters are required. We can declare a function pointer with no allocation. We can assign it to any function that matches the argument type and return type as we do to most pointers. We can also use the C++11 style function in STL functional: std::function&lt; return_type (argument_type1, argument_type2, ...) &gt; function_name, but this is much heavier. 123456789101112131415int SimpleAdd(int arg1,int arg2)&#123; return arg1 + arg2; &#125;int main(int argc, char *argv[])&#123; int (*f)(int start,int stop); // define a function pointer that takes in two ints and returns an int f = SimpleAdd; // f now points at the function “SimpleAdd” int x = (*f)(3,4); // dereference f, get the function it points to and applies it to 3,4 int y = f(3,4); // A syntactic sugar provided. Compiler will do the dereference cout &lt;&lt; &quot; x is: &quot; &lt;&lt; x &lt;&lt; &quot;, y is: &lt;&lt; y &lt;&lt; endl; function&lt;int(int,int)&gt; g; g = simpleAdd; cout &lt;&lt; g(3,4) &lt;&lt; endl; // also gives 7 // *g(3,4) doesn&#x27;t work because g here is an std::function, not a pointer to a C-style function&#125; Function as ParameterWhen we want to pass a function as a parameter of another function, we can pass it as a C-style pointer or C++11 std::funciton . We can also use a template and let the compiler to figure it out. 12345678910void OldCallMe(int (*f)(int), int x) &#123;...&#125;void NewCallMe(std::function&lt;int(int)&gt; f, int x) &#123;...&#125;template&lt;typename T&gt;void CallMe(T fn, int x)&#123; // a syntax error will result if the fn passed in of type T doesn&#x27;t support the following line int newValue = fn(x); cout &lt;&lt; &quot;CallMe-newValue is: &quot; &lt;&lt; newValue &lt;&lt; endl;&#125; Lambda ExpressionsA lambda expression evaluates to a function pointer. It takes the following format: [vars](args) -&gt; returntype &#123; // body of function &#125;;, where return type and arrow can be omitted. 12345678910111213// Declare a lambda with the auto keyword (we don&#x27;t know what type of a function that is)// func is a function that takes no variables or arguments and simply prints out Hello Worldauto func = []() &#123; cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; endl; &#125;;// Declare a lambda with a function pointer:// func2 is a pointer to a function that takes in a string as parameter// More specifically, that function takes in a string and prints it outvoid (*func2)(string) = [](string s) &#123; cout &lt;&lt; “Hello “ &lt;&lt; s &lt;&lt; endl; &#125;;// Use function template (C++11) to store lambdastd::function&lt;void(string)&gt; func3 = [](string s) &#123; cout &lt;&lt; “Hello “ &lt;&lt; s &lt;&lt; endl; &#125;; Capture Local VariablesWe can use lambda expressions to capture local variables. This will be an important way to still be able to use variables in a function that no longer exists when the lambda finally gets executed. If you want to capture local variables, always use C++11 std::function when defining either the lambda expression or the function you want to take this lambda expression. 12345678void CallMe(std::function&lt;int()&gt; fn) &#123;...&#125;;// template also works because it will automatically identify fn as an std::functiontemplate&lt;typename T&gt;void CallMe(T fn) &#123;...&#125;;int myX = 300;CallMe([myX]()-&gt;int&#123; return myX*2; &#125;); You also have the option of capturing local variables by reference. That means if the lambda expression modifies them, the modifications persist back into the “hosting” function where these variables were defined. (Just like any pass by reference function call). Pass by reference or pass a pointer will do. 12345int myX = 300; int *myY = new int; *myY = 3;CallMe([&amp;myX]()&#123; myX *= 2; &#125;);CallMe([myY]()&#123; *myY *= 2; &#125;);cout &lt;&lt; &quot;myX is &quot; &lt;&lt; myX &lt;&lt; endl &lt;&lt; &quot;myY is &quot; &lt;&lt; *myY &lt;&lt; endl; // 600 Lec17 Files I/OofstreamWe use ofstream to write to file. A constructor of ofstream takes in two arguments name of the file to open specifies which mode to use: ios::out open file for writing, overwrite existing file ios::app open file for writing, append to existing file We don’t have to close the stream after writing, ofstream has a destructor that is automatically called at the end of the program. That being said, we can still call out.close() manually. We use out.is_open() to make sure the file is indeed successfully opened and ready to be written in. Directly evaluating the stream variable out itself as a boolean also does the check. 123456#include&lt;fstream&gt;ofstream out(“myFile”,ios::out); // create an ofstream, pass in name of the file and ios::out to indicate you want to use it for outputif (out.is_open()) // make sure we successfully opend the file out &lt;&lt; “Hello world!” &lt;&lt; endl;out.close(); ifstreamWe use ifstream to read from a file. 1234ifstream in(“myFile”,ios::in);string str = &quot;Hello&quot;;if (in.is_open()) in &gt;&gt; str; Sequential FilesSuppose we have a csv file that uses comma as the delimiter and space as a record separator. If we want to change only a specific record, how are we supposed to move around in that file? tellg(): returns the offset from the beginning of the file where the next read operation will get data from. tellp(): returns the offset from the beginning of the file where the next write operation will put data to. seekg(n): sets the “get” offset to the nth character in the file seekp(n): sets the “put” offset to the nth character in the file Reading and Writing at the Same TimeWhen declare an fstream variable, we can specify using multiple “modes” at the same time by putting the or operator | between different modes. We can then use whatever function those modes give 123fstream file(“ages.dat”, ios::in | ios::out) //reads and write to &quot;ages.dat&quot; at the same timestring str; file &gt;&gt; str; // read worksfile &lt;&lt; &quot;That&#x27;s good&quot;; // write also works Lec18 Standard Template LibraryIteratorbegin() points to the first element in the object. end() points to one after the last element. Common operators like + &lt; &gt; are all overloaded for iterators. 123for (vector&lt;string&gt;::iterator p = stringVector.begin(); p &lt; stringVector.end(); ++p) cout &lt;&lt; “Next Vector Element is: “ &lt;&lt; *p &lt;&lt; endl; Vector123vector&lt;string&gt;::iterator q = stringVector.begin();stringVector.erase(q+5); // erase the 6th elementstringVector.erase(q,q+5); // erase [q, q+5), so erase 1st to the 5th element MapMap is based on valuetype, which has type &lt;key, value&gt;. All operations come from this pair. We can use typedef to name some very complicated data type that is frequently used. 12345678910111213141516typedef map&lt;int,string&gt;::value_type IDRecord; // IDRecord is in fact of &quot;pair&lt;int,string&gt;&quot; typetypedef map&lt;int,string&gt;::iterator IDRecordIterator;int main()&#123; map&lt;int,string&gt; ids; IDRecord rec1(12345,&quot;Ron DiNapoli&quot;); IDRecord rec2(34564,&quot;Darpan Kaplan&quot;); ids.insert(rec1); // alway insert a key-value pair ids.insert(rec2); cout &lt;&lt; &quot;ID 34564 belongs to: &quot; &lt;&lt; ids[34564] &lt;&lt; endl; // use array-like way to access map IDRecordIterator p = ids.find(12345); // find returns the address of that entry with a matched key , returns map::end() if key doesn&#x27;t exist IDRecordIterator q = ++p; cout &lt;&lt; &quot;Next entry of ID 12345 is: &quot; &lt;&lt; (*q).second &lt;&lt; endl;&#125; Lec19 ExceptionsBasic SyntaxExceptions can be of any type. We can do throw 3.14, throw &quot;Unexpected&quot;, or throw some object. 1234567891011enum MathErr &#123; noErr, divByZero, genericOverflow &#125;;throw divByZero;try &#123; ...&#125; catch(MathErr e) &#123; ...&#125;// Orcatch(...) &#123;&#125; // catches all kinds of Exceptions Exception Object and InheritanceAs said in previous section, we can throw an object. 1234567891011121314151617181920212223242526272829class MyIndexError &#123; MyIndexError(int i,char *msg):badIndex(i),theMsg(msg)&#123;&#125; int getBadIndex() &#123; return badIndex; &#125; string getMessage() &#123; return theMsg; &#125;private: int badIndex; string theMsg;&#125;;char &amp;MyString::operator[](int index)&#123; if ((index &lt; 0) || (index &gt;= stringLength)) throw MyIndexError(index,”Index out of bounds”); return storagePtr[index];&#125;class BaseException&#123;public: BaseException(string msg,int err=0):message(msg), errorCode(err)&#123;&#125; virtual string getMessage() &#123; return “BASE EXCEPTION: “ + message; &#125; int getErrorCode() &#123; return errorCode; &#125;protected: string message; int errorCode;&#125;; Lec20 Custom TemplatesBasic Syntax1234567891011template &lt;class placeholder&gt; // declare placeholdersclass SimpleClass // regular class definition&#123;public:…&#125;;// define a function outside of template classvoid SimpleClass&lt;placeholder&gt;::FunctionName() &#123;...&#125;// define constructor/destructor outside of template classvoid SimpleClass&lt;placeholder&gt;::SimpleClass() “Definition” template class should also be in the same .h file. Because the compiler needs to generate a separate set of member functions for each type used to create an instance of this class at compile time. That means that these definitions are needed at compile time and not at link time, so .cpp won’t enable us to actually call those functions. Non-Type ParametersWe specified a data type calls placeholder in the template class. We can also specify a constant expression when we declare a template class. This will have the same effect as setting a const value specific for that instance, except previously we couldn’t assign values to const variable. 12template &lt;class storageType,int size&gt; class MyArray &#123;...&#125;template &lt;class storageType=int,int size=5&gt; class MyArray &#123;...&#125; // give a default value Lec22 STL Algorithms#include&lt;algorithm&gt; for all functions below. fill(iterator begin, iterator end, T value): take two iterators/pointers and one value. Fill every position in between with that value.: 12char *ptr = new char[10] // An array of 10 charsfill(ptr,ptr+9,’A’); generate(iterator begin, iterator end, function g): assigns every position in between the two iterators/pointers according to the generating function g. 1234567int nextVal() &#123; static int number = 0; return number++;&#125;int main(int argc,char *argv[]) &#123; std::vector&lt;int&gt; intVector(10); // A vector of integers std::generate(intVector.begin(),intVector.end(),nextVal);&#125; fill_n(begin,count,value): fill from begin to begin+count with specified value generate_n(begin,count,function): fill from begin to begin+count with generated value remove(begin,end,value): remove all elements == value in range from begin to end replace(begin,end,value,replaceWith): replace all elements == value in range from begin to end WITH replaceWith Lec23 Smart PointersShared PointerYou can declare multiple pointers pointing to the same thing using shared pointer and they will all be released when you release one of them, so it’s safer than the classic pointer, where the pointer will hang over there. You can call the use_count() method to get how many shared pointers are out there pointing to this same thing. 123456int main(int argc,char *argv[]) &#123; shared_ptr&lt;Point&gt; pointPtr(new Point(1,2)); shared_ptr&lt;Point&gt; pointPtr2(pointPtr); cout &lt;&lt; “x coordinate is: “ &lt;&lt; (*pointPtr).x &lt;&lt; endl; cout &lt;&lt; “reference count is: “ &lt;&lt; pointPtr.use_count();&#125; Unique PointerThere is only this one pointer pointing to that thing. No other shared pointers can be created pointing to the same thing. For the same reason, use_count() is not available either. Lec24 Namespaces and C/C++ DifferencesNamespaceDeclaring NamespaceWe define a namespace by putting it inside a namespace declaration and its corresponding scope, just like what we do to a class. What’s different is that a single namespace may span multiple files. Therefore, we can declare/define a single namespace in multiple files. 123456namespace CornellCS2024 &#123; // Defines a namespace named CornellCS2024 class MyString &#123; public: ...&#125;; class AnotherClass &#123;...&#125;&#125; Using Namespace We can use anything declared in the namespace by quoting the fully qualified name 1CornellCS2024::MyString aString; We can designate a specific class to use in the rest of the file. 12using CornellCS2024::MyString;MyString aString; We can simply state that we want to use everything declared in this namespace. That’s what we usually do to std in small file. 12using namespace CornellCS2024;MyString aString; C/C++ Difference only supports /* block comments */ variable declarations had to appear the beginning of a scope before any other statements were encountered only has struct, no class no overloads, Namespaces, Declaring a counter variable in a loop, String type, Exceptions, Templates does not use new/delete for dynamic memory allocation/deallocation. Instead, C uses malloc() allocates memory. It needs to be given the exact number of bytes you want to dynamically allocate calloc() is the same as malloc() but initializes all allocated memory to 0 realloc() “grow” a dynamic allocation: basically allocates new space and copies all original memory to new space. free() releases allocated memory Lec99 From Assignments new keyword returns a pointer to an object. You don’t have to use new when creating a new object. Reference 123test t = test(&quot;rrr&quot;, 8);test t(&quot;rrr&quot;, 8);test *t = new test(&quot;rrr&quot;, 8);","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"20FA","slug":"20FA","permalink":"http://yao-lirong.github.io/tags/20FA/"},{"name":"CS2024","slug":"CS2024","permalink":"http://yao-lirong.github.io/tags/CS2024/"}]},{"title":"Windows下配置PostgreSQL","slug":"2020-09-05-Windows下配置PostgreSQL","date":"2020-09-05T04:00:00.000Z","updated":"2020-10-02T12:55:09.373Z","comments":true,"path":"2020-09-05-Windows下配置PostgreSQL/","link":"","permalink":"http://yao-lirong.github.io/2020-09-05-Windows%E4%B8%8B%E9%85%8D%E7%BD%AEPostgreSQL/","excerpt":"如果你在纠结要不要装，别装了吧，对自己好一点","text":"如果你在纠结要不要装，别装了吧，对自己好一点 Download and Install PostgreSQL. During the process, PostgreSQL will ask you to create a username and password, the default username is “postgres” and password is up to you. Run the pg_env.bat under installation folder or the following env.vbs file if that bat doesn’t work 1234567891011on error resume nextset sysenv=CreateObject(&quot;WScript.Shell&quot;).Environment(&quot;system&quot;) &#x27;系统环境变量的数组对象Path = CreateObject(&quot;Scripting.FileSystemObject&quot;).GetFolder(&quot;.&quot;).Path&#x27;添加变量sysenv(&quot;PGHOME&quot;)=&quot;C:\\Hacking\\PostgreSQL&quot; &#x27;!!!change to your own directory!!!&#x27;sysenv(&quot;PGHOST&quot;)=&quot;localhost&quot;sysenv(&quot;Path&quot;)=sysenv(&quot;PGHOME&quot;)+&quot;\\bin;&quot;+sysenv(&quot;Path&quot;)sysenv(&quot;PGLIB&quot;)=sysenv(&quot;PGHOME&quot;)+&quot;\\lib&quot;sysenv(&quot;PGDATA&quot;)=sysenv(&quot;PGHOME&quot;)+&quot;\\data&quot; wscript.echo &quot;PostgreSQL Environment Variable Successfully set&quot; Initialize database by running initdb -D C:\\Hacking\\PostgreSQL\\data Start Server by running pg_ctl -D C:\\Hacking\\PostgreSQL\\data start Register a server service by running pg_ctl register -N &quot;PostgreSQL&quot; -D C:\\Hacking\\PostgreSQL\\data (If not working, run terminal as administrator) You should then be able to see a service called “PostgreSQL” in Windows Services (Win+R services.msc) Create Database by running createdb -U postgres &lt;DatabaseName&gt; and entering the password you entered in step 1. Note it will give a “Password Authentication Failure” if you try createdb &lt;DatabaseName&gt; and enter the password that way. That is because PostgreSQL uses your computer username as default and no such use is registered in PostgreSQL in the first place. You have to use -U option to specify the user you want to log in as. Allow operations on database without password by changing authentication method in PostgreSQL\\data\\pg_hba.conf all from md5 to trust: (might take effect after a reboot) 12345678910# TYPE DATABASE USER ADDRESS METHOD# IPv4 local connections:host all all 127.0.0.1/32 trust (was md5)# IPv6 local connections:host all all ::1/128 trust# Allow replication connections from localhost, by a user with the# replication privilege.host replication all 127.0.0.1/32 trusthost replication all ::1/128 trust Now when we run command createdb db, we may get a message Fatel Error: User &quot;harmo&quot; does not exist. This is a similar problem as in step 6. We want to create a user called “harmo” by running createuser -s -r -U postgres harmo. Note simply creatuser -s -r harmo will not work because the default user to use to create such a user harmo is also harmo, which doesn’t exist in the first place. What a stupid logic PostgreSQL applies. Now PostgreSQL is ready to use. 过了一天服务启动不起来了，查了一堆没有结果，我还用你妈了个嗨，小爷一个周末就整你这傻逼玩意，草了真的是 好像是启动 pgAdmin 之后，又可以用了。刚刚启动的服务本身就是为了让 local server 运作的，而 pgAdmin 可以帮我们完成这个任务。于是我们登录进 pgAdmin 就相当于让那个服务运作起来了，也就可以正常在终端中使用命令了 Reference 主要：Windows下在命令行安装postgresql，并注册成window服务 Windows上PostgreSQL安装配置教程 Windows下Postgresql下载与配置方法 postgresql 口令： psql: 致命错误: 用户 认证失败 本机psql设置需要/不需要密码 Postgres psql: 致命错误: 角色 “postgres” 不存在","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"http://yao-lirong.github.io/tags/Logistics/"},{"name":"CS4320","slug":"CS4320","permalink":"http://yao-lirong.github.io/tags/CS4320/"}]},{"title":"Kinect as Web Cam","slug":"2020-06-24-Kinekt-as-Web-Cam","date":"2020-06-24T04:00:00.000Z","updated":"2020-06-24T04:55:23.561Z","comments":true,"path":"2020-06-24-Kinekt-as-Web-Cam/","link":"","permalink":"http://yao-lirong.github.io/2020-06-24-Kinekt-as-Web-Cam/","excerpt":"高二升高三暑假参加夏令营让我白嫖的 Kinect2，大材小用当做网络摄像头来用","text":"高二升高三暑假参加夏令营让我白嫖的 Kinect2，大材小用当做网络摄像头来用 下载 Kinect For Windows SDK 2.0，下载别人开发的 FullFastKinectCamV2 ver. 2.2，用就完事了 ReferenceKinectCamV2 for Kinect V2","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"http://yao-lirong.github.io/tags/Logistics/"}]},{"title":"2020 网络日志","slug":"2020-06-09-2020-网络日志","date":"2020-06-09T04:00:00.000Z","updated":"2022-04-09T05:56:27.591Z","comments":true,"path":"2020-06-09-2020-网络日志/","link":"","permalink":"http://yao-lirong.github.io/2020-06-09-2020-%E7%BD%91%E7%BB%9C%E6%97%A5%E5%BF%97/","excerpt":"A cartoon intro to DNS over HTTPS: HTTP, DNS, DNS over HTTPS 简介 (中文版 1 2) VS Code上也能玩转Jupyter Notebook 什么是生成函数？: 有自带数学公式的dpf版，来源为豆丁网。其中第三页结尾式子应为 $g(x)+xg(x) = \\frac{g(x)}{x} - 1$, 此段结尾（在第四页开头）的式子应为 $g(x) = \\frac{-x}{x^2+x-1}$. IDM使用技巧","text":"A cartoon intro to DNS over HTTPS: HTTP, DNS, DNS over HTTPS 简介 (中文版 1 2) VS Code上也能玩转Jupyter Notebook 什么是生成函数？: 有自带数学公式的dpf版，来源为豆丁网。其中第三页结尾式子应为 $g(x)+xg(x) = \\frac{g(x)}{x} - 1$, 此段结尾（在第四页开头）的式子应为 $g(x) = \\frac{-x}{x^2+x-1}$. IDM使用技巧","categories":[],"tags":[{"name":"网络日志","slug":"网络日志","permalink":"http://yao-lirong.github.io/tags/%E7%BD%91%E7%BB%9C%E6%97%A5%E5%BF%97/"}]},{"title":"Cornell 20SP 总结","slug":"2020-05-27-Cornell-20SP-总结","date":"2020-05-27T04:00:00.000Z","updated":"2020-08-04T09:54:02.815Z","comments":true,"path":"2020-05-27-Cornell-20SP-总结/","link":"","permalink":"http://yao-lirong.github.io/2020-05-27-Cornell-20SP-%E6%80%BB%E7%BB%93/","excerpt":"CS3110 Data Struct &amp; Functional ProgrammingRanting When you find yourself saying, “I don’t know,” be sure to follow it up with “ - but I’ll find out.” It’s a great way to admit what you don’t know, but then take responsibility like a pro. – The Pragmatic Programmer, Ch2. The Cat Ate My Source Code","text":"CS3110 Data Struct &amp; Functional ProgrammingRanting When you find yourself saying, “I don’t know,” be sure to follow it up with “ - but I’ll find out.” It’s a great way to admit what you don’t know, but then take responsibility like a pro. – The Pragmatic Programmer, Ch2. The Cat Ate My Source Code ​ Nate Foster 完美诠释了如何做到这一点，当你问他 XXX 什么时候搞完， XXX 为什么还没上传，XXX 是不是出错了的时候，他总能告诉你 “I’ll look into it”, “I don’t know but I’ll get it done by today”, “I have another meeting coming up, but you can come to my office hour to talk about that” (当你真去了的话他会和你说他接下来又有另一个事要处理并非常礼貌地请你滚)。网上的所有评价都是 Both 3110 professors are amazing，并且 reddit 上经常有人感谢 Foster，就差赞美 Foster 胜过他亲爷爷了。不知道是 Foster 给了这些人好处，还是 Foster 自导自演，我和 19FA 咨询的一名 TA 意见是相同的：”Clarkson is more organized than Foster”. 我虽然没有上过 Clarkson 的3110，但是我觉得再差也不会差到哪里去了。要不是 SP 的 3410 讲师天气勺评价更差，我绝不选 SP 上 3110。 ​ 不知道是不是计算机院都有的问题：讲义写的实在太好了以至于上课不如自己看讲义。但是 Myers 讲的环环相扣，Foster 则是引入了 iclicker 以强制你在一个可以容纳 300 个人的教室里上计算机课时禁止使用计算机，而是看着他现场 debug 自己本应在课前 debug 好的 demo 代码。Foster 这学期唯一的用处大概就是解答了我关于红黑树的问题 (当然了严格来说不是他解答的，这个我口中的最大用处其实就是我问 “为什么 OCaml 可以几十行实现其他语言几百行的代码，是不是因为 OCaml 的 pattern matching 减少了很多指针操作”，他回答了个 “Yes, you can say that” 而已) Assignment A0: 某一个 Consultant 说我把最后一个函数 tail-recursive Fibonacci 的两个变量搞倒巴了，于是我把它正了过来，这题0分。一个median为满分的小热身，我得了几乎两个 deviation 低于 median。appeal的结果也是不给我分，原因是我的 spec 里面两个变量的顺序是正确的。你说这TM不是废话吗，因为当时改的时候忘改spec了呗。就因为这个作业搞了我的心态所以我后面对 Foster 和这门课一直印象不好。 A3: 写了Maplewood… A5: sxy又救了我一命，说实话我一直到写完都不知道自己在写什么。这个作业完全是被sxy带的 Project做了一个还蛮好玩的二分法解任意一元函数的可编程计算器。 CS2802 Discrete Structures (Honors) - So let’s think about some applications of graph in real life. Say who is the most influential person in this class. - You, professor! - … Yeah, of course. ​ Joe Halpern 是个非常好玩的老头，除了有的时候课上扯太多的例子以至于讲不完课以外，这是一堂要是有时间讲完图论就完美了的课。从一开始的时候必须每次都去 OH 写出来证明 (尤其是某一次的 inductive definition of transitive closure)，到最后某个作业自己独立完成了 “We know M accepts A, WTS A* is regular (accepted by some automata)” 然后这个题还拿了满分，切实的感觉到自己还是学了些有一般适用性的东西的。 MATH3110 Introduction To Analysis​ 因为某人选的这课，临走前请教了刘晓东，他害怕这节课会难所以建议我只是旁听但不要上，吓得我这学期没再多选课，结果不能说完全不难，但是比 2802 这个 3 学分的课整体来说花的时间少。再也不信刘晓东了，第一学期临走前还跟我说别把多元微积分考掉，最后我还是考掉了( ​ 坚定下来选这门课还有一个原因是上学期的线性代数金牌讲师 Meyer 在讲，这学期跟她上了一个学期感觉虽然有的时候课上讲不太到点子上 (Meyer 下学期要去 Carleton 了，哭哭)。解释的不是很明白以外，整个课下来非常有组织性。另一名讲师法国佬 Saloff-Coste 虽然课讲得真不怎么样，但是 OH 特别有用，让人不禁疑惑 OH 的时候讲得这么好为什么课能讲得这么烂。 CS2043 UNIX Tools and Scripting​ 讲的东西都很有用很有意思，但是这老师实属不行，就纯念 PPT WRIT1380 FWS: Elements of Acad Wtg​ 为了成绩能高点又水了一年 FWS，比去年差远了，这老师没有Brad 能扯皮也没他有意思，作业还比 Brad 多。不过确实教了点有用的写作技巧","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"20SP","slug":"20SP","permalink":"http://yao-lirong.github.io/tags/20SP/"}]},{"title":"Mutability","slug":"2020-03-03-Mutability","date":"2020-03-03T05:00:00.000Z","updated":"2020-08-04T09:31:25.468Z","comments":true,"path":"2020-03-03-Mutability/","link":"","permalink":"http://yao-lirong.github.io/2020-03-03-Mutability/","excerpt":"From Textbook: Mutability","text":"From Textbook: Mutability RefsSyntax123ref x!xx := e ref x: creates a reference using the ref keyword (let x = ref 0 creates a location in memory whose contents are initialized to 0) !x: dereferences x and returns the contents of the memory location x := e: is an assignment. It mutates the contents x to be 1. Note that x itself still points to the same location (i.e., address) in memory. Variables really are immutable in that way. What changes is the contents of that memory location. Memory is mutable; variable bindings are not. Counter12345678910111213let next_val = let counter = ref 0 in fun () -&gt; incr counter; !counterlet next_val_broken = fun () -&gt; let counter = ref 0 in incr counter; !counter next_val_broken () = 1 ... 1 ... 1next_val () = 1 ... 2 ... 3 ... Look at how these two functions’ results differ. In the first example, counter is just a temporary variable later bound to the fun() -&gt; ... Therefore, counter will not be initiated every time we call next_val . It is evaluated only when the first time it is defined. Sequencing1e1; e2; ... ; en The sentence above evaluates each one of ei in order from left to right, returning only vn. If the values vi previous expression ei evaluates to are not of type unit, the compiler will give you a warning because it makes no sense to throw away those values. To get rid of the warning (if you’re sure that’s what you need to do), there’s a function ignore : &#39;a -&gt; unit in the standard library. Using it, ignore(2+3); 7 will compile without a warning. Of course, you could code up ignore yourself: let ignore _ = (). This is a syntactic sugar of let _ = e1 in e2 Equality Physical Equality (==,!=): same address Structural Equality (=,&lt;&gt;): same content Mutable Fields (in Record)Syntax123456789(* declare a record with mutable field *)type point = &#123;x:int; y:int; mutable c:string&#125;let p = &#123;x=0; y=0; c=&quot;red&quot;&#125;(*mutate the field of that record*)p.c &lt;- &quot;white&quot;p.x &lt;- 3# Error: The record field x is not mutable Mutable StackArrays and LoopsArrays Array creation: [|e0; e1; ...; en|] Array indexing: e1.(e2) Array assignment: e1.(e2) &lt;- e3 Loops12345678910while e1 do e2 donelet i = ref 0while !i&lt;=2 do print_endline(string_of_int v.(!i)); incr i donefor x=e1 to e2 do e3 donefor x=e1 downto e2 do e3 donefor i=1 to 2 do print_endline(string_of_int v.(i)) donefor i=2 downto 0 do print_endline(string_of_int v.(i)) done while loops terminate when e1 becomes false for loops execute once for each integer from e1 to e2 for..to loops evaluate starting at e1 and incrementing x each iteration; for..downto loops evaluate starting at e1 and decrementing x each iteration","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"CS3110","slug":"CS3110","permalink":"http://yao-lirong.github.io/tags/CS3110/"},{"name":"20SP","slug":"20SP","permalink":"http://yao-lirong.github.io/tags/20SP/"}]},{"title":"Specifications","slug":"2020-02-18-Specifications","date":"2020-02-18T05:00:00.000Z","updated":"2020-08-04T09:34:25.510Z","comments":true,"path":"2020-02-18-Specifications/","link":"","permalink":"http://yao-lirong.github.io/2020-02-18-Specifications/","excerpt":"From Textbook: Specifications and Abstractions Specification of Functions123456(** [f x] is ... Example: ... Requires: ... Raises: ... *)let f x =","text":"From Textbook: Specifications and Abstractions Specification of Functions123456(** [f x] is ... Example: ... Requires: ... Raises: ... *)let f x = Returns: Don’t write Returns: ..., instead, just use [f x] is ... Requires: specific conditions on input Requires: [x &gt;=0] Raises: what the program will do if a bad input is given Raises: xxx Exception if [x&lt;0] Examples: give an example input and output of the function to better explain what it does Specification of ModulesWhat to document in a module: functions not specified in the interface abstraction function representation invariant 1234567891011121314151617181920212223242526(* Implementation of sets as lists without duplicates. * Includes rep_ok checks. *)module ListSetNoDupsRepOk : Set = struct (* Abstraction function: the list [a1; ...; an] represents the * set &#123;a1, ..., an&#125;. [] represents the empty set &#123;&#125;. * * Representation invariant: the list contains no duplicates. *) type &#x27;a set = &#x27;a list let rep_ok (l : &#x27;a set) : &#x27;a set = List.fold_right (fun x t -&gt; assert (not (List.mem x t)); x :: t) l [] let empty = [] let mem x l = List.mem x (rep_ok l) let add x l = rep_ok (if mem x (rep_ok l) then l else x :: l) let rem x l = rep_ok (List.filter ((&lt;&gt;) x) (rep_ok l)) let size l = List.length (rep_ok l) let union l1 l2 = rep_ok (List.fold_left (fun a x -&gt; if mem x l2 then a else x :: a) (rep_ok l2) (rep_ok l1)) let inter l1 l2 = rep_ok (List.filter (fun h -&gt; mem h l2) (rep_ok l1))end note that the above code keeps representation invariant, abstraction function, and other spec about implementation details inside the module definition, because when we generate the docs of this module, everything outside the definition of the module will be come “public” specs for clients and everything inside will become “private” spec for maintainers. Abstraction FunctionAbstraction function maps valid concrete values to abstract values 1234567891011121314151617(** AF: ... *)module ListSetDups : Set = struct (* AF: the list [a1; ...; an] represents the * smallest set containing all the elements a1, ..., an. * The list may contain duplicates. * [] represents the empty set. *) type &#x27;a set = &#x27;a list ... module ListSetNoDups : Set = struct (* AF: the list [a1; ...; an] represents the set * &#123;a1, ..., an&#125;. [] represents the empty set. *) type &#x27;a set = &#x27;a list ... Representation InvariantRepresentation Invariant distinguishes valid concrete values and from invalid concrete values and is the implicit part of all the precondition and postcondition. 1234567(** RI: ... *)module ListSetNoDupsRepOk : Set = struct (* RI: the list contains no duplicates. *) type &#x27;a set = &#x27;a list ... Common MistakesSome common mistakes include not stating enough in preconditions, failing to identify when exceptions will be thrown, failing to specify behavior at boundary cases, writing operational specifications instead of definitional and stating too much in postconditions. Long Variable Name1234let number_of_zeros_in_the_list = fold_left (fun (accumulator:int) (list_element:int) -&gt; accumulator + (if list_element=0 then 1 else 0)) 0 the_listin ... Code using such long names is verbose and hard to read. Instead of trying to embed a complete description of a variable in its name, use a short and suggestive name (e.g., zeroes), and if necessary, add a comment at its declaration explaining the purpose of the variable.","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"CS3110","slug":"CS3110","permalink":"http://yao-lirong.github.io/tags/CS3110/"},{"name":"20SP","slug":"20SP","permalink":"http://yao-lirong.github.io/tags/20SP/"}]},{"title":"Code Reuse with Modules","slug":"2020-02-13-Code-Reuse-with-Modules","date":"2020-02-13T05:00:00.000Z","updated":"2020-08-04T09:34:53.202Z","comments":true,"path":"2020-02-13-Code-Reuse-with-Modules/","link":"","permalink":"http://yao-lirong.github.io/2020-02-13-Code-Reuse-with-Modules/","excerpt":"From Textbook: Code Reuse with Modules IncludesDef: includes enables a structure to include all the values defined by another structure, or a signature to include all the names declared by another signature.","text":"From Textbook: Code Reuse with Modules IncludesDef: includes enables a structure to include all the values defined by another structure, or a signature to include all the names declared by another signature. Syntax1234567891011module type SetExtended = sig include Set (*all other definitions specific to SetExtended*) val of_list : &#x27;a list -&gt; &#x27;a tendmodule ListSetDupsExtended = struct include ListSetDups (*all other definitions specific to SetExtended*) let of_list lst = List.fold_right add lst emptyend Encapsulation1234567891011121314module ListSetDupsImpl = struct type &#x27;a t = &#x27;a list let empty = [] let mem = List.mem let add x s = x::s let elts s = List.sort_uniq Stdlib.compare sendmodule ListSetDups : Set = ListSetDupsImplmodule ListSetDupsExtended = struct include ListSetDupsImpl let of_list lst = lstend The important change is that ListSetDupsImpl is not sealed, so its type &#39;a t is not abstract. Plus, OCaml compiler can infer it is an implementation of Set .When we include it in ListSetDupsExtended, we can therefore exploit the fact that it’s a synonym for &#39;a list. The clients should use ListSetDups, but when we use List to implement other things, we should use ListSetDupsImpl instead. Includes vs. Open1234567891011121314151617181920module M = struct let x = 0endmodule N = struct include M let y = x + 1 let z = 1endmodule O = struct open M let y = x + 1 let z = 1endmodule M : sig val x : int endmodule N : sig val x : int val y : int val z : int endmodule O : sig val y : int val z : int end N has both an x and y, whereas O has only a y. The reason is that include M causes all the definitions of M to also be included in N, so the definition of x from M is present in N. But open M only made those definitions available in the scope of O, aka. a part of the implementation; it doesn’t actually make them part of the structure, aka. the client cannot see them. So O does not contain a definition of x, even though x is in scope during the evaluation of O‘s definition of y. FunctorsDef: a functor is simply a “function” from structures to structures. It is a parametrized module. Syntax123456789101112131415161718module F (M : S) = struct ...end(*annonymous functors*)module F = functor (M : S) -&gt; struct ...end(*functors parametriezed with multiple modules*)module F (M1 : S1) ... (Mn : Sn) = struct ...end(* above are the desugared version of the codes above*)module F = functor (M1 : S1) -&gt; ... -&gt; functor (Mn : Sn) -&gt; struct ...end 12module ANewModule = F(OldModule)module ListSetNoDupsExtended = ExtendSet(ListSetNoDups) ApplicationExtension1234567module ExtendSet(S:Set) = struct include S let add_all lst set = let add&#x27; s x = S.add x s in List.fold_left add&#x27; set lstend Other than Extension: Testing123456module SackTester (S: StackSig) = struct let _ = assert (S.(empty |&gt; push 1 |&gt; peek) = 1)endmodule MyStackTester = StackTester(MyStack)module ListStackTester = StackTester(ListStack) The only difference is that because the latter example is about extension, we need to include everything from its parent module.","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"CS3110","slug":"CS3110","permalink":"http://yao-lirong.github.io/tags/CS3110/"},{"name":"20SP","slug":"20SP","permalink":"http://yao-lirong.github.io/tags/20SP/"}]},{"title":"Modules","slug":"2020-02-11-Modules","date":"2020-02-11T05:00:00.000Z","updated":"2020-03-10T19:03:46.196Z","comments":true,"path":"2020-02-11-Modules/","link":"","permalink":"http://yao-lirong.github.io/2020-02-11-Modules/","excerpt":"From Textbook: OCaml Modules StructuresSemanticsThe first letter of a module’s name should be capitalized. 123module ModuleName = struct (* definitions *)end","text":"From Textbook: OCaml Modules StructuresSemanticsThe first letter of a module’s name should be capitalized. 123module ModuleName = struct (* definitions *)end You can access the variables / methods in a module by Module.method 12let x = ModuleName.empty;;x.peek;; SignaturesSemanticsSignature is a collections of declarations; not evaluated, just type checked. 123456789101112module type ModuleTypeName = sig (* declarations *)endmodule type Stack = sig type &#x27;a stack val empty : &#x27;a stack val is_empty : &#x27;a stack -&gt; bool val push : &#x27;a -&gt; &#x27;a stack -&gt; &#x27;a stack val peek : &#x27;a stack -&gt; &#x27;a val pop : &#x27;a stack -&gt; &#x27;a stackend A structure matches a signature if the structure provides definitions for all the names specified in the signature (and possibly more), and these definitions meet the type requirements given in the signature. If you don’t seal X, as long as the fields in module correspond with those in signature, these two match. when we seal X, we a create a linkage between module with the signature but we don’t have to do that. It’s safer if you explicitly want X to be a type of X, but we add an extra layer of abstraction to X. AbstractionYou can also specify that this module as a type of some signature by providing a module type annotation : Stack. After adding this, everything inside that module will be come abstract and hidden from view. 1234567891011121314151617module type Arith = sig type t val zero : t val one : t val (+) : t -&gt; t -&gt; t val ( * ) : t -&gt; t -&gt; t val (~-) : t -&gt; tendmodule Ints : Arith = struct type t = int let zero = 0 let one = 1 let (+) = Stdlib.(+) let ( * ) = Stdlib.( * ) let (~-) = Stdlib.(~-)end Outside of the module Ints, the expression Ints.(one + one) is perfectly fine, but Ints.(1 + 1) is not, because t is abstract: outside the module no one is permitted to know that t = int. In fact, the toplevel can’t even give us good output about what the sum of one and one is! 12# Ints.(one + one);;- : Ints.t = &lt;abstr&gt; Sharing ConstraintOCaml lets you write sharing constraints that refine a signature by specifying equations that must hold on the abstract types in that signature. If T is a module type containing an abstract type t, then T with type t = int is a new module type that is the same as T, except that t is known to be int. For example, we could write: 123module Ints : (Arith with type t = int) = struct (* all of Ints as before *)end Now both Ints.(one + one) and Ints.(1 + 1) are legal. Modules and the Top LevelWell, apparently you cannot remember everything about how to import a library into OCaml and you don’t have to. So just refer to this site","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"CS3110","slug":"CS3110","permalink":"http://yao-lirong.github.io/tags/CS3110/"},{"name":"20SP","slug":"20SP","permalink":"http://yao-lirong.github.io/tags/20SP/"}]},{"title":"Higher-Order Functions","slug":"2020-02-06-Higher-Order-Functions","date":"2020-02-06T05:00:00.000Z","updated":"2020-03-10T19:07:06.450Z","comments":true,"path":"2020-02-06-Higher-Order-Functions/","link":"","permalink":"http://yao-lirong.github.io/2020-02-06-Higher-Order-Functions/","excerpt":"From Textbook: Higher Order Programming Introduction higher-order: functions as values, you can pass functions as arguments into other functions, functions at the same level as other variables lower-order: languages like C, functions as something higher than other variables Pipeline is a higher-order function. 123let pipeline x f = f xlet (|&gt;) = pipelinelet x = 5 |&gt; double (* 10 *)","text":"From Textbook: Higher Order Programming Introduction higher-order: functions as values, you can pass functions as arguments into other functions, functions at the same level as other variables lower-order: languages like C, functions as something higher than other variables Pipeline is a higher-order function. 123let pipeline x f = f xlet (|&gt;) = pipelinelet x = 5 |&gt; double (* 10 *) Map (Transforms Elements)it maps each element of the list through a function 123456789(* [map f [x1; x2; ...; xn]] is [f x1; f x2; ...; f xn] *)let rec map f = function | [] -&gt; [] | h::t -&gt; (f h)::(map f t)let add1 = map (fun x-&gt; x+1);let add1&#x27; = map ((+)1);let concat3110 = map (fun x -&gt; x^&quot;3110&quot;) Filter (Eliminates Elements)List.filter &lt;predicate&gt; &lt;list&gt;it picks all elements which meet predicate p to form a new list. 12345(* [filter p l] is the list of elements of [l] that satisfy the predicate [p]. * The order of the elements in the input list is preserved. *)let rec filter f = function | [] -&gt; [] | h::t -&gt; if f h then h::(filter f t) else filter f t Fold (Combines Elements)Fold Right Can we abstract the following two functions as a single function? 1234567let rec sum = function | [] -&gt; 0 | h::t -&gt; h + (sum t)let rec concat = function | [] -&gt; &quot;&quot; | h::t -&gt; h ^ (concat t) First, we abstract the initial value 1234567891011let rec sum&#x27; init = function | [] -&gt; init | h::t -&gt; h + sum&#x27; init tlet sum = sum&#x27; 0let rec concat&#x27; init = function | [] -&gt; init | h::t -&gt; h ^ concat&#x27; init tlet concat = concat&#x27; &quot;&quot; We find out the only thing these two functions have in difference is the operator. So the next step, we factor out the operator. 123let rec combine init op = function| [] -&gt; init| h::t -&gt; op h (combine init op t);; The intuition for why this function is called fold_right is that the way it works is to “fold in” elements of the list from the right to the left, combining each new element using the operator. For example, fold_right (+) [a;b;c] 0 results in evaluation of the expression a+(b+(c+0)). The parentheses associate from the right-most subexpression to the left. One way to think of fold_right would be that the [] value in the list gets replaced by init, and each :: constructor gets replaced by op. For example, [a;b;c] is just syntactic sugar for a::(b::(c::[])). So if we replace [] with 0 and :: with (+), we get a+(b+(c+0)). Fold Left123let rec fold_left op acc = function | [] -&gt; acc | h :: t -&gt; fold_left op (op acc h) t The idea is that fold_left (+) 0 [a;b;c] results in evaluation of ((0+a)+b)+c. The parentheses associate from the left-most subexpression to the right. So fold_left is “folding in” elements of the list from the left to the right, combining each new element using the operator. Fold Left vs. Fold RightWhy is there a difference of the order the operand takes in arguments (op acc h; op: &#39;a -&gt; &#39;b -&gt; &#39;a as in fold_left; op h (combine init op t); op: &#39;a -&gt; &#39;b -&gt; &#39;b as in fold_right)? And why is there a difference of the order these two functions take in argument (fold_left op acc lst; fold_right op lst init)? fold_left f init [v1; v2;...; vn] is f (... (f (f init v1) v2)...) vn whereas fold_right f [v1; v2;...; vn] init is f v1 (f v2 (...(f vn init)...)) (– Nate Foster) order of evaluation: fold_left evaluates from left to right fold_right evaluates from right to left tail-recursive: because of the way these two functions evaluate fold_left is tail-recursive. We can add that value to acc, the group of elements completed evaluation, after evaluating the current element. fold_right is not recursive. Because it cannot evaluate the nth element before evaluating the (n+1)th element. And the evaluation of nth element depends on (n+1)th element. This pattern violates the definition of tail-recursive Then is there a tail-recursive version of fold_right? You can first reverse the list and then fold_left. Fold Application12345678let length l = List.fold_left (fun a _ -&gt; a+1) 0 llet rev l = List.fold_left (fun a x -&gt; x::a) [] llet map f l = List.fold_right (fun x a -&gt; (f x)::a) l []let filter f l = List.fold_right (fun x a -&gt; if f x then x::a else a) l [](*test whether a list is full of true*)let lst_and_fold = List.fold_left (fun acc elt -&gt; acc &amp;&amp; elt) true Generalized Fold1234567let rec foldtree init op = function | Leaf -&gt; init | Node (v,l,r) -&gt; op v (foldtree init op l) (foldtree init op r) let size t = foldtree 0 (fun _ l r -&gt; 1 + l + r) tlet depth t = foldtree 0 (fun _ l r -&gt; 1 + max l r) tlet preorder t = foldtree [] (fun x l r -&gt; [x] @ l @ r) t","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"CS3110","slug":"CS3110","permalink":"http://yao-lirong.github.io/tags/CS3110/"},{"name":"20SP","slug":"20SP","permalink":"http://yao-lirong.github.io/tags/20SP/"}]},{"title":"Advanced Data Types","slug":"2020-02-04-Advanced-Data-Types","date":"2020-02-04T05:00:00.000Z","updated":"2020-03-10T21:02:58.286Z","comments":true,"path":"2020-02-04-Advanced-Data-Types/","link":"","permalink":"http://yao-lirong.github.io/2020-02-04-Advanced-Data-Types/","excerpt":"From Textbook: Advanced Data Types Algebraic Data Types以前我们的 variants 比较像 enum，但是现在我们更像一个abstract class","text":"From Textbook: Advanced Data Types Algebraic Data Types以前我们的 variants 比较像 enum，但是现在我们更像一个abstract class 12345678910111213(*definition*)type t = C1 | C2 of t2| ... | Cn (*of tn*)(* t: &#x27;a * &#x27;a * ... *)(*expression*)C e---or---C(* e: (e1:&#x27;a, e2:&#x27;a, ...) *)(*pattern matching*)C p(* p: (e1:&#x27;a, e2:&#x27;a, ...) *) examples: 12345678910111213141516171819202122232425262728type point = float * float type shape = | Point of point | Circle of point * float (* center and radius *) | Rect of point * point (* lower-left and upper-right corners *)let area = function | Point _ -&gt; 0.0 | Circle (_,r) -&gt; pi *. (r ** 2.0) | Rect ((x1,y1),(x2,y2)) -&gt; let w = x2 -. x1 in let h = y2 -. y1 in w *. htype string_or_int =| String of string| Int of inttype string_or_int_list = string_or_int listlet rec sum : string_or_int list -&gt; int = function | [] -&gt; 0 | (String s)::t -&gt; int_of_string s + sum t | (Int i)::t -&gt; i + sum tlet three = sum [String &quot;1&quot;; Int 2] When do we need [],(),&#123;&#125; | of? 12type node = &#123;value:int; next:mylist&#125;and mylist = Nil | Node of node []: list (): Constructor of a tuple &#123;&#125;: Constructor of a record |: delineate different variants inside a type of: defining the construction of an algebraic type Recursive Variants12345678910type intlist = Nil | Cons of int * intlisttype &#x27;a tree = | Leaf | Node of &#x27;a nodeand &#x27;a node = &#123; value: &#x27;a; left: &#x27;a tree; right: &#x27;a tree&#125; Parametrized VariantsNo matter what kind of types we define, either a variant, a record, or a tuple. We need the type parameter &#39;a or (&#39;a,&#39;b) when we define it. 123456(* [Option] makes it safer to return nothing*)type &#x27;a option = None | Some of &#x27;atype &#x27;a mylist = Nil | Cons of &#x27;a * &#x27;a mylisttype (&#x27;a,&#x27;b) pair = &#123;first: &#x27;a; second: &#x27;b&#125;type (&#x27;a,&#x27;b) test = &#x27;a * &#x27;b Similarly, when you want to declare a variable that has a parametrized type, you also need to give the type parameter. 123type &#x27;a tree = Leaf of &#x27;a | Node of (&#x27;a * &#x27;a tree * &#x27;a tree)let x:&#x27;a tree = Leaf 5let x:int tree = Leaf 5 If you do let x:tree = Leaf 5, the compiler won’t know what type you are talking about. Polymorphic VariantsThey would be better off with the name “anonymous variants,” because you want to use them when these variants are only used in this specific function and not anywhere else. The constructor of polymorphic variants start with a “ ` “ 123456789101112(* note: no type definition *)let f = function | 0 -&gt; `Infinity | 1 -&gt; `Finite 1 | n -&gt; `Finite (-n) val f : int -&gt; [&gt; `Finite of int | `Infinity ]let lst = [`Pos 5; `Zero; `Neg (~-4); `Pos 3];;val lst : [&gt; `Neg of int | `Pos of int | `Zero ] list = [`Pos 5; `Zero; `Neg (-4); `Pos 3] Pattern Matching12345678910111213141516type &#x27;a tree = | Leaf | Node of &#x27;a nodeand &#x27;a node = &#123; value: &#x27;a; left: &#x27;a tree; right: &#x27;a tree&#125;(* [mem x t] returns [true] if and only if [x] is a value at some * node in tree [t]. *)let rec mem x = function | Leaf -&gt; false | Node &#123;value; left; right&#125; -&gt; value = x || mem x left || mem x right ExceptionsThe Basics12345678910(*Definition: it is just a special kind of &quot;type&quot;*)exception E of t(*Call an Exception*)raise e(*syntactic sugar*)failwith &quot;Not Good&quot;raise (Failure (&quot;Not Good&quot;)) Pattern MatchingThe following code says: try evaluating e. If it produces an exception packet, use the exception patterns from the original match expression to handle that packet. If it doesn’t produce an exception packet but instead produces a normal value, use the non-exception patterns from the original match expression to match that value. 123456789match try e with | q1 -&gt; e1 | ... | qn -&gt; enwith | r1 -&gt; e1 | ... | rm -&gt; em","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"CS3110","slug":"CS3110","permalink":"http://yao-lirong.github.io/tags/CS3110/"},{"name":"20SP","slug":"20SP","permalink":"http://yao-lirong.github.io/tags/20SP/"}]},{"title":"Standard Data Types","slug":"2020-01-30-Standard-Data-Types","date":"2020-01-30T05:00:00.000Z","updated":"2020-03-10T20:39:30.121Z","comments":true,"path":"2020-01-30-Standard-Data-Types/","link":"","permalink":"http://yao-lirong.github.io/2020-01-30-Standard-Data-Types/","excerpt":"From Textbook: Standard Data Types ListsBuilding Lists The empty list is written [] and is pronounced “nil”, a name that comes from Lisp. Given a list lst and element elt, we can prepend elt to lst by writing elt::lst. The double-colon operator is pronounced “cons”","text":"From Textbook: Standard Data Types ListsBuilding Lists The empty list is written [] and is pronounced “nil”, a name that comes from Lisp. Given a list lst and element elt, we can prepend elt to lst by writing elt::lst. The double-colon operator is pronounced “cons” cons always prepend things, so cons is actually right-associative. The following code has the same effect. 121::2::3::[];;1::(2::(3::[]));; All the elements of a list must have the same type. The word list itself here is not a type. For example, given int, it produces the type int list. You could think of type constructors as being like functions that operate on types, instead of functions that operate on values. (We mentioned this idea of thinking constructor as a function on type in CS2112) Accessing ListsThe following code computes the sum of a list. 1234let rec sum lst = match lst with | [] -&gt; 0 | h::t -&gt; h + sum t The following code computes the length of a list. _, the underscore character is used when we want to indicate the presence of some value in a pattern without actually giving it a name. 12345let rec length lst = match lst with | [] -&gt; 0 | _::t -&gt; 1 + length t The following code appends one list onto the beginning of another list. 1234let rec append lst1 lst2 = match lst1 with | [] -&gt; lst2 | h::t -&gt; h::(append t lst2) Note: every natural number is either 0 or is 1 greater than some other natural number n, and so a proof by induction has a base case for 0 and an inductive case for n+1. Likewise all our functions have a base case for the empty list and a recursive case for the list that has one more element than another list. This similarity is no accident. There is a deep relationship between induction and recursion; we’ll explore that relationship in more detail later in the course. Mutating ListsValues in OCaml are immutable. The following code increments the head by 1. 1234let inc_first lst = match lst with | [] -&gt; [] | h::t -&gt; (h+1)::t This code looks extremely similar with C or Java operating on pointers. The implementation of list in OCaml works in the way that it shares the tail list t between the old list and the new list, such that the amount of memory in use does not increase (beyond the one extra piece of memory needed to store h+1). The reason that it’s quite safe for the compiler to implement sharing is exactly that list elements are immutable. Pattern Matching with ListsBasicsEach of the clauses pi -&gt; ei is called a branch or a case of the pattern match. The p‘s here are a new syntactic form called a pattern. a variable name, e.g. x the underscore character _, which is called the wildcard (we don’t care what it is) the empty list [] p1::p2 [p1; ...; pn] 1234let length_is lst n = match length lst with | n -&gt; true | _ -&gt; false The code above always returns true, because suppose that the length of lst is 5. Then the pattern match becomes: match 5 with n -&gt; true | _ -&gt; false. And n matches 5. A variable pattern matches any value and here produces the binding n-&gt;5. The correct codes are written below. 123456789101112let length_is lst n = match length lst with | m -&gt; if m=n then true else false | _ -&gt; false let length_is lst n = match length lst with | m -&gt; m=n | _ -&gt; falselet length_is lst n = length lst = n However, this doesn’t mean patterns are not the variable values as in switch statement. Yes they are general “patterns”. But you can match them to specific values. e.g. 123456789match 5 with| 6 -&gt; true| _ -&gt; false;;- : bool = falsematch 5 with| 5 -&gt; true| _ -&gt; false;;- : bool = true Advanced Pattern Matching p1 | ... | pn: an “or” pattern; matching against it succeeds if a match succeeds against any of the individual patterns pi, which are tried in order from left to right. All the patterns must bind the same variables. (p : t): a pattern with an explicit type annotation. c: here, c means any constant, such as integer literals, string literals, and booleans. &#39;ch1&#39;..&#39;ch2&#39;: here, ch means a character literal. For example, &#39;A&#39;..&#39;Z&#39; matches any uppercase letter. p when e: matches p but only if e evaluates to true. Tuples and Recordsboth represent heterogeneous types of values, both sizes are fixed RecordsWorks like struct in C++. Each field is identified by names. Definition123type student =&#123;name: string; gpa : float; year :int;&#125; (*defining a type*)let rbg = &#123;name = &quot;R B&quot;; gpa = 4.0; year = 1954;&#125; (*declare an instance of that type*)let s = rbg.name (*accessing field in the record*) Patter Matching123456match rbg with | &#123;name=n; gpa=g; year=y&#125; -&gt; y(*syntactic sugar of codes above*)match rgb with | &#123;name;gpa;year&#125; -&gt; name TuplesTuples are identified by position, instead of naming the components. Definition1234let t = (10,&quot;am&quot;) (*t has type: int * string*) type time = int * string let t:time = (10,&quot;am&quot;) (*t has type: time*) fst t;; snd t;; (*predefined functions to access the first and second element of a tuple*) Pattern Matchingif we use a pattern in a let expression (or definition), we are really just doing pattern matching with a single clause. 123456789let tick t =let (t,s) = t in (t+1,s) (*tick : int * &#x27;a -&gt; int * &#x27;a = &lt;fun&gt;*)let tick (t:time):time =let (t,s) = t in (t+1,s) (*tick : time -&gt; time = &lt;fun&gt;*)let tick (t:time):time = match t with| (t,s) -&gt; (t+1,s) Pattern Matching in a Nutshell1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768(* Pokemon types *)type ptype = TNormal | TFire | TWater(* A record to represent Pokemon *)type mon = &#123;name: string; hp : int; ptype: ptype&#125;(********************************************* * Several ways to get a Pokemon&#x27;s hit points: *********************************************)(* OK *)let get_hp m = match m with | &#123;name=n; hp=h; ptype=t&#125; -&gt; h(* better *)let get_hp m = match m with | &#123;name=_; hp=h; ptype=_&#125; -&gt; h(* better *)let get_hp m = match m with | &#123;name; hp; ptype&#125; -&gt; hp(* better *)let get_hp m = match m with | &#123;hp&#125; -&gt; hp(* best *)let get_hp m = m.hp(************************************************** * Several ways to get the 3rd component of a tuple **************************************************)(* OK *)let thrd t = match t with | (x,y,z) -&gt; z(* good *)let thrd t = let (x,y,z) = t in z(* better *)let thrd t = let (_,_,z) = t in z(* best *)let thrd (_,_,z) = z(************************************* * How to get the components of a pair *************************************)let fst (x,_) = xlet snd (_,y) = y(************************ * take tuple as a whole ************************)let rep_ok ((n,lst) as v) = if List.length lst = n then v else failwith &quot;RI violated&quot;","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"CS3110","slug":"CS3110","permalink":"http://yao-lirong.github.io/tags/CS3110/"},{"name":"20SP","slug":"20SP","permalink":"http://yao-lirong.github.io/tags/20SP/"}]},{"title":"Functions","slug":"2020-01-28-Functions","date":"2020-01-28T05:00:00.000Z","updated":"2020-03-10T20:35:21.091Z","comments":true,"path":"2020-01-28-Functions/","link":"","permalink":"http://yao-lirong.github.io/2020-01-28-Functions/","excerpt":"From Textbook: Functions FunctionsDefinition: let f x1 x2 ... xn = e (f is the function name; xi is input, and there can be multiple inputs; e is the output) We can think of t1 -&gt; t2 -&gt; u as the type of a function that takes two inputs, the first of type t1 and the second of type t2, and returns an output of type u. Likewise for a function that takes n arguments. A function is already a value (that’s how you assign the value “function” to a variable name), so there is nothing to be evaluated when we evaluate its dynamic semantic.","text":"From Textbook: Functions FunctionsDefinition: let f x1 x2 ... xn = e (f is the function name; xi is input, and there can be multiple inputs; e is the output) We can think of t1 -&gt; t2 -&gt; u as the type of a function that takes two inputs, the first of type t1 and the second of type t2, and returns an output of type u. Likewise for a function that takes n arguments. A function is already a value (that’s how you assign the value “function” to a variable name), so there is nothing to be evaluated when we evaluate its dynamic semantic. Anonymous FunctionDefinition: fun x -&gt; x+1 (fun is a keyword indicating an anonymous function) Anonymous functions are also called lambda expressions, a term that comes out of the lambda calculus, which is a mathematical model of computation in the same sense that Turing machines are a model of computation. In the lambda calculus, fun x -&gt; e would be written $λx.e.$ The λ denotes an anonymous function. Function Application Normal way:(fun x -&gt; e3) ((fun x -&gt; e2) e1);; Pipeline: e1 |&gt; fun x-&gt;e2 |&gt; fun x-&gt;e3;; They are semantically the same as “let expressions” : let x = e1 in let x = e2 in e3 (In fact, the let expression is just a syntactic sugar of function application) Function application is left-associative: g f x = (g f) x, while function types are right-associative: g -&gt; f -&gt; x = g -&gt; (f -&gt; x) Polymorphic FunctionsThe &#39;a is a type variable: it stands for an unknown type, just like a regular variable stands for an unknown value. Labeled ArgumentsOCaml supports labeled arguments to functions. You can declare this kind of function using the following syntax: 12# let f ~name1:arg1 ~name2:arg2 = arg1 + arg2;;val f : name1:int -&gt; name2:int -&gt; int = &lt;fun&gt; This function can be called by passing the labeled arguments in either order: 1f ~name2:3 ~name1:4;; A sugar of declaring function with labeled arguments is 1let f ~name1 ~name2 = name1 + name2 Partial ApplicationA function of two variables: let add x y = x + y A composite function: let addx x = fun y -&gt; x + y 123let add x y = x+ylet add x = fun y -&gt; x+ylet add = fun x -&gt; (fun y -&gt; x+y) The top two are just syntactic sugar for the last statement. Now, think about what does the last line mean? Does the fun y -&gt; x+y actually knows that there exists an x? The answer is yes. That’s because the statement fun y -&gt; x+y is in the scope of x‘s declaration. For the codes below, the outermost function actually takes in a value of type t1 and produces a function that is of type t2 -&gt; (t3 -&gt; t4) And the type of such a function 1t1 -&gt; t2 -&gt; t3 -&gt; t4 really means the same as 1t1 -&gt; (t2 -&gt; (t3 -&gt; t4)) That is, function types are right associative: there are implicit parentheses around function types, from right to left. The intuition here is that a function takes a single argument and returns a new function that expects the remaining arguments. Below is an example of Partial Application: The bottom two are syntactic sugars of the first statement 123let comp = fun f g -&gt; fun x -&gt; g(f x);;let compa f g = fun x -&gt; g(f x);;let compb f g x = g(f x);; Applying comp to other functions: 1234567891011utop # let inc x = x+1;;val inc : int -&gt; int = &lt;fun&gt;────────────────────────────────────────────────────────utop # let inc2 = comp inc inc;;val inc2 : int -&gt; int = &lt;fun&gt;────────────────────────────────────────────────────────utop # inc 1;;- : int = 2────────────────────────────────────────────────────────utop # inc2 1;;- : int = 3 A useful application of Partial Application is precomputation: When we want to use a process multiple times, we can just write a function that takes in other function and do that job. g. predefine comp so that when we want to composite two functions, we only need to apply it to the function comp instead of writing out the composite function on ourselves every time. Unit FunctionThere is only one value of this type, which is written () and is also pronounced “unit”. So unit is like bool, except there is one fewer value of type unit than there is of bool. Unit is therefore used when you need to take an argument or return a value, but there’s no interesting value to pass or return. Type InferenceHow to determine the type of a very complicated function? Add right-associative parameters; Rewrite the function as a more understandable let expression Find out which variables have to take in a value (then it must be a function), which doesn’t (then it can be anything) Determine the type of each variable from the last statement, and write their types from left to right in the sequence they were taken in. Take fun f g -&gt; fun x -&gt; g(f x) as an example: let h = fun f g -&gt; ( fun x -&gt; g(f x) ) x doesn’t take in a value, so x is a variable of type a’ f takes in x, so f must be a function of type a’ -&gt; b’ g takes in the output of f, so g must be a function of type b’ -&gt; c’ The type of this function is 12 f g x (output:g(f x))(a&#x27; -&gt; b&#x27;) -&gt; (b&#x27; -&gt; c&#x27;) -&gt; a&#x27; -&gt; c&#x27; Take fun f g -&gt; fun x -&gt; (g f) x as another example: let h = fun f g -&gt; (fun x -&gt; (g f) x) x doesn’t take in a value, so x is a variable of type a’ f doesn’t take in a value, so f is a variable of type b’ g takes in f, so g must be a function whose input is of type b’; plus its output takes in another variable x, so its output is also a function, which takes in a type a’. Therefore, g is of type b&#39; -&gt; (a&#39; -&gt; c&#39;) The type of this function is 12f g x (output:(g f) x)b&#x27; -&gt; (b&#x27; -&gt; a&#x27; -&gt; c&#x27;) -&gt; a&#x27; -&gt; c&#x27;","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"CS3110","slug":"CS3110","permalink":"http://yao-lirong.github.io/tags/CS3110/"},{"name":"20SP","slug":"20SP","permalink":"http://yao-lirong.github.io/tags/20SP/"}]},{"title":"CS2043 Unix Tools and Scripting","slug":"2020-01-24-CS2043-Unix-Tools-and-Scripting","date":"2020-01-24T05:00:00.000Z","updated":"2021-08-31T00:16:56.845Z","comments":true,"path":"2020-01-24-CS2043-Unix-Tools-and-Scripting/","link":"","permalink":"http://yao-lirong.github.io/2020-01-24-CS2043-Unix-Tools-and-Scripting/","excerpt":"AboutThe goal of CS2043 is to introduce you to the UNIX/Linux “command line” and its accompanying tools. When done with this class you should feel comfortable navigating any UNIX shell prompt, installing UNIX/Linux systems and understanding any shell script that you may encounter down the road. We’ll cover basic commands through script writing and visit some of the more common tools used today!","text":"AboutThe goal of CS2043 is to introduce you to the UNIX/Linux “command line” and its accompanying tools. When done with this class you should feel comfortable navigating any UNIX shell prompt, installing UNIX/Linux systems and understanding any shell script that you may encounter down the road. We’ll cover basic commands through script writing and visit some of the more common tools used today! LEC02 File System (01/24)Root DirectoryUnlike Windows, UNIX has a single global “root” directory (instead of a root directory for each disk or volume). The root directory is just /. Absolute paths start with a /, and always refer to the root directory. cat: concatenate and print a file cat &gt;&gt; &lt;filename&gt;: concatenate your following input in shell to the file specified wc -l &lt;filename&gt;: count the number of lines in a file wc -w &lt;filename&gt;: count the number of words in a file touch: create a file if not existed mkdir -p test/a/b: make directory and all its parent directory if they do not exist cp –r &lt;src&gt; &lt;dest&gt;: To copy a complete directory cp –f &lt;src&gt; &lt;dest&gt;: To overwrite more aggressively LEC03 Permission (01/27)Reading permission: Linux Representation Permission by user type -rwx—— User permissions —-rwx— Group permissions ——-rwx Other permissions r- read, w- write, x - execute groups &lt;username&gt;: check which group this user is in and you can manage permission by groups chmod &lt;mode&gt; &lt;filename&gt;: change permissions: &lt;mode&gt;: +774: add user and group all rwx permissions, give others only r permission to the file -222: deprive user, group, and other’s permissions to write the file =111: change user, group, and other’s permissions to only execute the file. They will lose permissions to read or write if they previously had su: makes you the super user sudo: grants you the super power temporarily LEC04 More Commands (01/29) more | less: to view file man: \\something to search for “something”, n to go to its next occurrence find &lt;directory&gt; -&lt;criteria&gt; &lt;specification&gt;: Modifiers for find are evaluated in conjunction (a.k.a AND). But you can condition your arguments with an OR using the –o flagfind can also execute command on found files / directories by using the –exec modifier, and find will execute the command for you The variable name is {} You have to end the command with either a : Semicolon (;): execute command on each result as you find them- Plus (+): find all the results first, then execute command arguments for &lt;criteria&gt;: -name: the file’s name -amin n: file last access was n minutes ago -atime n: file last access was n days ago examples: find ./ -name *.sh: find under the current directory all files containing the extension name “.sh” find . –amin -10 –exec cat &#123;&#125; \\+: Display all the contents of files accessed in the last 10 minutes find . –type f –readable –executable: All files that are readable and executable find . –type f –readable –o –executable: All files that are readable or executable find . –amin +10: Find all files accessed at least 10 minutes ago find . –amin -10: Find all files accessed at most 10 minutes ago LEC05 Zipping (01/31)Zipping tar -c -v -f &lt;zipped_filename&gt; &lt;files_to_zip&gt;: tar files only create a bundle of file,s it doesn’t compress Remember to put -f as the last one, or at least -f must come right before &lt;zipped_filename&gt; -c : create a new bundle -v : verbose (output information about what’s going on) -f : save in file tar -xvf &lt;archived_filename&gt; &lt;files_to_zip&gt;: -x: extract files Piping1&lt;command1&gt; | &lt;command2&gt; ls -al /bin | less: show everything in directory /bin as scrollable history | tail -20 | head -10 : the most recent 10th - 19th file RedirectionIf you don’t specify, the output or input of a command comes from the terminal command &gt; file: write the output of the command into file (overwrite) command &lt; file: take the file as input of a command line command 2&gt; file: outputs the error message to a file (stderr(2) in C) command &gt;&gt; file: append the output of the command into file (doesn’t overwrite) LEC06 Loops and Variables (02/03)Environment and Variables environment variables: in the computer local variables: only in current shell Shebang #!/bin/sh: execute the file using Bourne shell (sh) #!/bin/bash: execute the file using bash shell (bash) exit codereturned value of main will be printed out if executing the script in Linux exit N: exit with status N executing multiple commands in a row cmd1; cmd2: execute cmd 1 first, then cmd 2 cmd1 &amp;&amp; cmd2: execute cmd2 only if cmd 1 returns 0 (exited normally) cmd1 || cmd2: execute cmd2 only if cmd 1 doesn’t return 0 (failed) ScriptingWe mostly use bash in our scripting. So remember to include #!/bin/bash in the top Variablesstoring command output: var = &quot;$(echo hello world)&quot; if statement123456789if [ CONDITION_1 ] then # statementselif [ CONDITION_2 ]then # statementselse # statementsfi if...then...fi part is necessary. elif and else are allowed, but not necessary. Shorten codes with ; to write them in one line, like if [[ 0 –eq 0]]; then echo “Hiya”; fi for loop123for (( i = 0; i &lt;= 11; ++i )); do echo “i: $i”done while loop1234567891011121314151617s=“s” while [[ &quot;$s&quot; != &quot;ssss&quot; ]]; do echo &quot;$s&quot; s=&quot;s$s&quot;donex=0 while (( x &lt;= 11 )); do echo &quot;x: $x&quot; (( ++x ))done# Loop through lines in a filefile=“filename.txt”while read -r line; do echo &quot;Line: $line&quot;done &lt; &quot;$file&quot; Comparing ValuesNumbers $n1 –eq $n2 tests if n1 == n2 $n1 –ne $n2 tests if n1 != n2 $n1 –lt $n2 tests if n1 &lt; n2 $n1 –le $n2 tests if n1 &lt;= n2 $n1 –gt $n2 tests if n1 &gt; n2 $n1 –ge $n2 tests if n1 &gt;= n2 Strings “$s1” == “$s2” tests if s1 and s2 are identical “$s1” != “$s2” tests if s1 and s2 are different Path Testing Test if /some/path exists: -e /some/path Test if /some/path is a file: -f /some/path Test if /some/path is a directory: -d /some/path Test if /some/path can be read/written/execute: -r/-w/-x /some/path Arithmetic ExpressionPut expressions inside (( )) . In script, you need to put $ before expressions to read values. Below are some examples 123echo $(( 2 + 3 )) #5x=10; sum=$(( $x+10 ))echo $sum #20 Passing Arguments $1, $2, …, $10: values of the first, second, etc. arguments If 3 arguments are given, $4, $5, … higher are empty $0 is the name of the script $# is the number of arguments (argc in C) $? Is the exit code of the last program executed You can have your script set this with exit &lt;number&gt; (read man exit) No explicit call to exit is the same as exit 0 (a.k.a, success!) $* expands \\$1 .. \\$n into one string, has the same effect as “\\$1 \\$2 … \\$n” (one string) $@ expands $1 .. $n into individual strings, same as “$1” “$2” .. “$n” (n strings) Be careful with spacing comparing two variables Lec07 Your Shell, Job, and Processes (02/05)Resource MonitoringCommands ps &lt;PID&gt; (process snapshot): report the current running processes, including PID ps -C &lt;command_name&gt;: report the current process using its corresponding shell command top: displays CPU usage of current processes htop: better version of top, though not pre-installed in many Linux distributions Examples1234ps –C firefox #find firefox&#x27;s pid through its command name61860 ... firefoxhtop -p 61860 #display usage of this specific process Modifying Processes nice -n &lt;priority:int&gt; &lt;command name&gt; : initialize command with non-default priority renice -n &lt;priority&gt; -p &lt;PID&gt;: readjust the priority of a running process kill &lt;PID&gt;: kill this process killall &lt;command name&gt;: kill processes by name, kill all processes related to this program JobsWhen we are executing ping or installing big packages, we may lose control of our command line temporarily. And we may want to run these commands in the background. &lt;command&gt; &amp;: run the command in background, but will still print output in the terminal jobs: report jobs working in background bg &lt;job_id&gt;: resumes the job in background (note: job id should come after %, like %1, or the command will take it as the PID) fg &lt;job_id&gt;: resume job in the foreground Lec08 Your Shell (02/10) source &lt;script_name&gt;: the command runs script in the current shell, not as usual in a spawned shell alias &lt;new_name&gt;=&lt;old_name&gt;: e.g. x = &#39;cd /Desktop&#39; ssh -X: allows X11 rendering (allows graphic interface through remote server) scp [flags] &lt;from&gt; &lt;to&gt; (secure copy): copy files from the internet (remote host): Must specify the user on the remote host. Syntax for remote client: user@host:/path (Note You need the : to start the path) ctrl + r reverse search your history for the most recent command that has the string you just typed in. Lec10 Shell Expansions and Search (02/14)Grammar of Shell Expansions *: multiple character wildcard: match any string, including the empty string ?: single character wildcard: match a single character: matches exactly one but what that character is doesn’t matter [brackets]: [a-z, A-Z] matches one character in the range [^ ...]: not, [^abc] matches any character that is not a, b, or c &#123;... , ...&#125;: matches any pattern inside the comma separated braces. &#123;Hello,World&#125; matches either “Hello” or “World” \\ : escape space: &#123;Hello, Goodbye&#125; World = Hello Goodbye World &#123;Hello, Goodbye&#125;\\ World = Hello World Goodbye World (the space is escaped, so “World” is now taken as a part of the set of words) $: to read values (echo $PWD reads the PWD variable and then echo its value) &lt;: create instream from file &gt; &gt;&gt;: direct output to a file (overwrite or append) GREPgrep &lt;pattern&gt; [input] Globally search a Regular Expression and Print. GREP can be used to search or filter large amounts of data. grep -r &lt;pattern&gt; ./ search current directory and all its subdirectories for the pattern specified grep -i &lt;p&gt; ./ ignore upper/lower case distinctions -v display those lines that do NOT match -n precede each matching line with the line number -c print only the total count of matched lines Regular Expressions a?: search for a with 0 or 1 appearance a*: search for a with 0 or multiple appearance a+: search for a with 1 or multiple appearance .: wildcard Lec11 Sed, Cut, and Paste sed: Replace: sed &#39;s/no spoon /a fork/g&#39; no_spoon.txt: replace (s/) every occurrence in the whole document (globally: /g) of “no spoon” with “a fork” Delete: sed &#39;/[Dd]avid/d&#39; david.txt: executes delete command (/d) xargs: can read from stdin, so it can pass output from other commands to scripts that only take in arguments, not from stdin. shift &lt;number&gt;: drop the first &lt;number&gt; arguments paste: merge multiple files paste –d , names.txt phones.txt &gt; result.csv: merge names and phones together, -ddelimit them with ‘,’ paste –d , -s names.txt phones.txt &gt; result.csv: merge file serially (-s) instead of in parallel LEC12 awk, gawk, and Process Substitutionawk awk &#39;/[Mm]onster/ &#123;print&#125;&#39; frankenstein.txt: find regex [Mm]onste and print the lines out. awk &#39;/[Mm]onster/&#39; frankenstein.txt: if not specified, the default action is to print awk &#39;/[Mm]onster/ &#123;print $0&#125;&#39; frankenstein.txt: $0 refers the whole line awk &#39;/[Mm]onster/ &#123;print $1&#125;&#39; frankenstein.txt: prints the first word of the line contains our pattern awk &#39;/Ron/&#123;print $3&#125;&#39; marks.txt: prints the third column of the line containing ‘Ron’ in the file ‘marks.txt’ awk &#39;BEGIN&#123;x=5; y=10; z=x+y; print z&#125;&#39;: arithmetics in awk &amp;&amp; || a?b:c !(a&amp;&amp;b): also work in awk awk &#39;/s/?/8./:/9./ &#123;print&#125;&#39; marks.txt: If there’s an ‘s’, look for grade in 80s, otherwise grade in 90s awk &#39;!/s/ &#123;print&#125;&#39; marks.txt: Look for all lines that do not contain an ‘s’ Process SubstitutionWe can treat a command of series of commands as if they were a file &lt; (list): treat the list of commands as input e.g. echo &quot;This is a test&quot; &gt; &gt;(wc –w) &gt; (list): treat the list of commands as output file e.g. while read x; do echo $x; done &lt; &lt;(git log) LEC13 Advanced Bash ScriptingCondition Statements: casecase employs a patter match, using shell expansion 123456789case &quot;$var&quot; in&quot;A&quot; ) #commands to execute if [[ $var == &quot;A&quot; ]]2 ) #commands to execute if [[ $var -eq 2 ]][2-4] ) ##commands to execute if [[ $var -ge 2 ]] &amp;&amp; [[ $var -le 4 ]]* ) #default commands Arrays1234567891011121314151617arr = ( use parentheses and seperate items by space )my_arr = ( &quot;a string&quot; 1 ) % can be of multiple types# You can also customize the indexes inside the array (so its more like a dictionary instead of a traditional array)my_arr[44] = &quot;string&quot;# perform an array operation by $&#123;expr&#125;echo &quot;Index 51: $&#123;arr[51]&#125;&quot;#iterate through the array as individual itemsfor x in &quot;$&#123;arr[@]&#125;&quot;; do echo &quot;$x&quot;; done#iterate through the array as a joined long seriesfor x in &quot;$&#123;arr[*]&#125;&quot;; do echo &quot;$x&quot;; done#iterate through the list of indexesfor idx in &quot;$&#123;!new_arr[@]&#125;&quot;; do echo “$idx”; done","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"20SP","slug":"20SP","permalink":"http://yao-lirong.github.io/tags/20SP/"},{"name":"CS2043","slug":"CS2043","permalink":"http://yao-lirong.github.io/tags/CS2043/"}]},{"title":"Installing and Configuring Ocaml on Linux","slug":"2020-01-20-Installing-Ocaml-on-Linux","date":"2020-01-20T05:00:00.000Z","updated":"2020-01-25T00:48:22.405Z","comments":true,"path":"2020-01-20-Installing-Ocaml-on-Linux/","link":"","permalink":"http://yao-lirong.github.io/2020-01-20-Installing-Ocaml-on-Linux/","excerpt":"Install Ocamlrun sh &lt;(curl -sL https://raw.githubusercontent.com/ocaml/opam/master/shell/install.sh) and install opam at /usr/bin (Caution: install it under this directory to ensure you can also access opam at user’s directory)","text":"Install Ocamlrun sh &lt;(curl -sL https://raw.githubusercontent.com/ocaml/opam/master/shell/install.sh) and install opam at /usr/bin (Caution: install it under this directory to ensure you can also access opam at user’s directory) Configure Ocaml and VSCode initiate with sandbox (bubblewrap) disabled opam init --bare -a -y --disable-sandboxing switch OPAM to the OCaml 4.09.0 compiler: 123# Note: do NOT prefix these commands with sudoopam switch create 4.09.0 ocaml-base-compiler.4.09.0eval $(opam env) install OPAM packages needed 12opam install -y utop ounit qtest yojson lwt lwt_ppx menhir ansiterminal lambda-term merlin ocp-indent user-setup bisect_ppx-ocamlbuildopam user-setup install install “OCaml and Reason IDE” and configure settings.json in vscode as such: 12345678910&#123; &quot;workbench.colorTheme&quot;: &quot;Solarized Light&quot;, &quot;editor.tabSize&quot;: 2, &quot;editor.rulers&quot;: [ 80 ], &quot;editor.formatOnSave&quot;: true, &quot;reason.path.ocamlmerlin&quot;: &quot;/home/mint/.opam/4.09.0/bin/ocamlmerlin&quot;, &quot;reason.path.ocamlfind&quot;: &quot;/home/mint/.opam/4.09.0/bin/ocamlfind&quot;&#125; note that it first showed that “cannot locate ocamlmerlin binary.” I fixed the problem by changing directory of “ocamlmerlin” and “ocamlfind” in the settings. (Find their path with which ocamlmerlin)","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"http://yao-lirong.github.io/tags/Logistics/"},{"name":"CS3110","slug":"CS3110","permalink":"http://yao-lirong.github.io/tags/CS3110/"}]},{"title":"Cornell 19FA 总结","slug":"2019-12-22-Cornell-19FA-总结","date":"2019-12-22T05:00:00.000Z","updated":"2019-12-27T02:58:05.112Z","comments":true,"path":"2019-12-22-Cornell-19FA-总结/","link":"","permalink":"http://yao-lirong.github.io/2019-12-22-Cornell-19FA-%E6%80%BB%E7%BB%93/","excerpt":"CS2112 OO Design Data Structs (Honors) My goal in teaching this course has been to make you guys fearless about taking ideas and turning them into systems of codes that work – Andrew Myers, 2019/12/10","text":"CS2112 OO Design Data Structs (Honors) My goal in teaching this course has been to make you guys fearless about taking ideas and turning them into systems of codes that work – Andrew Myers, 2019/12/10 从A1到A7肉眼可见自己的成长，真的想学CS的话一定要上这个课，因为这个课所以我觉得这一学期过得特别快，两周一个project，一学期就这样过去了。 A1: 什么嘛，还是挺简单的吗（结果拿了低于一个deviation） A2(Isaac)：因为亲爱的中国朋友们自己有自己的队友，只有一个黑哥找我当队友。这个黑哥好像是课上唯一一个黑哥，真的非常努力。但是说实话有的时候忙不到点上去，忙了白忙。最后RSA因为一个莫名其妙的bug，又是低于一个median (128 commits) A3(Ralph)：我最爱的数据结构，Chinese American 队友，强是真的强。可以直接无障碍读Java源码，他的hashTable估计就是这样写出来的，不然更强，因为他的hashTable写得实在太好了。基本上被他带了，我就写了个trie而已。但有可能是因为这次作业太简单，而且相对独立，我俩都觉得不需要和对方交流，结果没什么团队合作的感觉，做的还不如A2带感 (152 commits) A4(Xinyu &amp; Faizaan)：终于有中国人没有队友了（，所以是一个中国妹子和一个美国人做得队友。这个美国人，真的不正经，明明能提前做完非要拖到最后一秒写。幸亏因为A4整个结构是我写的，我几乎对它有绝对了解和掌控，进行得还是很顺利的。这个中国小姑娘是真的强，给她讲明白了就能写，写出来还一点都没bug A5(Xinyu &amp; Faizaan)：因为A4我要关心的东西太多，整个给我整虚脱了，于是我把A5全权交给了美国人，结果作为代码量最大的project之一，他又没写完，应该是我做的最差的一次作业。但是最后成绩没有想象的那么差，主要批的松。 A6(Xinyu &amp; Faizaan)：因为我懒得学习JavaFx一堆乱七八糟的语法，所以我又全权交给了美国人，这个时候其实有点破罐子破摔的感觉。同时我把A5用不了的地方整个重写了一遍。最后一晚上非常刺激，虽然我们deadline之前一个小时做完了，但是最后一刻我改了改一些错误信息展示的代码让整个GUI更好看，结果在测试的时候发现了一个bug。我以为是我的错误，于是git reset回去，交上了以前的版本。刺激在于我卡着deadline交上的，更刺激的是我交完以后发现我交的仍然是最新版本，所以bug仍然存在，心情起伏最大的一晚上。（不过最后发现和我那一个小时的改动没关系，是model不是GUI出了问题） A7(Xinyu &amp; Faizaan)：server我觉得还是要学一下的，和A4一样试着写了个结构。小姑娘帮我把server全写完了，最可怕的是一个bug都没有，真的吓人。美国人可能因为要准备自己的Final，所以这一次竟然在deadline之前六七个小时就写完了，然后早早提交上去了。非常满意的一次作业（也是除A3外唯一的高于median的作业）(475 commits in total) 本来指着Final里面擅长的算法和数据结构提提分，结果Final出点过于简单，并拉不开分差。要是出到和给的example同一个难度，我是有信心这节课拿A的。 MATH 2210 Linear Algebra我的教授是个老爷子(James West) ，老爷子快九十了吧，一句话说到最后一个词的时候我已经忘了他第一个说的词是什么了，人真的很好，可是脑子确实老化了，并不是那个最好的讲师。 后来换到 Myer 的 session，讲得确实不错（West 那里的人全跑她那去了），最后一个 OH 还多留了三十分钟专门给我把 Inner Product Space 讲明白了，一位优雅又善良的女老师。 DEA 1500 Intro to Environ. Psychology本专业唯一一节我觉得可以上的课，而且评价也很好，于是就上了。Gary Evans 绝对是数一数二的讲师，清晰有条理，课程内容也很有趣（虽然后期有些同质化）。如果说美国1%的人掌握着99%的财富，那我也要说美国1%的聪明并真正有着人文情怀的人领到了99%的傻子，就是这1%的人构建了部分人心目中的人类文明灯塔。Gary 就是那个1%。能从他的课中感受到他对这个星球甚至整个人类的爱。 Sometimes we focus on China’s carbon footprint and says it should regulate more. However, look at the data of the United States per capita. I’m not saying China shouldn’t regulate more, but isn’t it a little hypocritical to ask China to do more regulations while we are producing more than them? 虽然不想捧一踩一，但是Gary其实应该也很老了。即使如此却一直用饱满的精神为大家呈现这门课，最后几个lecture不知道他怎么了，有的时候会失掉自己的声音，整个声音突然就变哑了，那个时候真的是心疼他。他的最后一课我会永远记在心里。 我知道你们中有很多人是各方面的积极分子，比如环保主义者，你有的时候也觉得为什么大家都不理解我在做的事都是为了他们好，你有的时候也会觉得自己非常无助。我要向大家展示这一句话：这些做出巨大改变的运动，往往是由一小群人领导的。回想一下，他（甘地）当时是大多数吗？他（马丁路德金）也不是。你可能觉得这些人都是一开始就非常伟大的 … 这个当时只有十二岁的小女孩，向世界揭露了纳粹的罪行，她当时有多么强大的能力吗？… 有时你可能会觉得很无力，但是记住Margaret说了什么：永远都是那一小部分人。 – Gary Evans, 2019/12/09 WRIT 1370 FWS: Elements of Acad WtgBrad是个稍微带点痞气的不错的人，虽然这课叫做 Metaphor in Art, Science and Culture 但我实际上觉得他其实这三个都并不很懂… Don’t be Strangers. – Brad Zukovic, 2019/12/06 CS5199 Comp Program &amp; Problem Solving狗屎课，课程都进行了一大半了才告诉别人用什么方式计算attendance，幸亏最后运气好刚刚好到了pass的线，不然要是第一学期成绩单上就有个fail或者withdraw，那是真的难看。 PE1395 Self Defense挺好玩的","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"19FA","slug":"19FA","permalink":"http://yao-lirong.github.io/tags/19FA/"}]},{"title":"Add pdf file to hexo","slug":"2019-12-17-add-pdf-file-to-hexo","date":"2019-12-17T05:00:00.000Z","updated":"2019-12-18T03:22:39.731Z","comments":true,"path":"2019-12-17-add-pdf-file-to-hexo/","link":"","permalink":"http://yao-lirong.github.io/2019-12-17-add-pdf-file-to-hexo/","excerpt":"Say you’ve put book.pdf in ./source/books/, then put something like [Download my book!](/books/book.pdf) anywhere in the article and it will create the link for you. Cited From hexo","text":"Say you’ve put book.pdf in ./source/books/, then put something like [Download my book!](/books/book.pdf) anywhere in the article and it will create the link for you. Cited From hexo","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"http://yao-lirong.github.io/tags/Logistics/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yao-lirong.github.io/tags/Hexo/"}]},{"title":"Problem Analysis","slug":"2019-12-05-Problem-Analysis","date":"2019-12-05T05:00:00.000Z","updated":"2019-12-18T03:24:32.793Z","comments":true,"path":"2019-12-05-Problem-Analysis/","link":"","permalink":"http://yao-lirong.github.io/2019-12-05-Problem-Analysis/","excerpt":"From Lecture: Hard problems and undecidability Computable ProblemTime ComplexityTractable Problems (P)Polynomial algorithms: $O(n^k)$ for some k ($k\\leq4$)","text":"From Lecture: Hard problems and undecidability Computable ProblemTime ComplexityTractable Problems (P)Polynomial algorithms: $O(n^k)$ for some k ($k\\leq4$) Exponential Time (EXPTIME)Exponential Time algorithm: $O((2^k)^n)$ Nondeterministic Polynomial Problems (NP)e.g.: Hamilton cycles, SAT (Boolean satisfiability), Graph coloring How would you solve a very hard problem? If you have enough resources (space &amp; time), you can just randomly generate some results and check the result’s correctness. Therefore, the key is that you have to check the correctness in deterministic time (polynomial time). In fact, all of them can be solved by exponential-time algorithms that essentially try all exponentially many possible solutions, but this approach is infeasible NP-Complete: All NP problems can be expressed using the three NP examples above. These three problems are said to be NP-Complete. In fact, SAT is the most frequently used one. There are many people working on how to solve well-formed SAT problems in a reasonable amount of time. e.g. You can transform a Hamilton cycle problem into an SAT problem and use those SAT algorithms to solve it Space Complexity L: logarithmic space PSPACE: polynomial space NPSPACE: nondeterministic polynomial space Inclusion Relationships$L\\sube P\\sube NP \\sube PSPACE = NPSPACE \\sube EXPTIME$ Unknow Problems $O(Factoring)\\in P$ ? NP = EXPTIME ? P = NP ? L = P ? because L≠PSPACE, we know that at least one of the inequalities L≠P, P≠NP, and NP≠PSPACE must hold, but we don’t know which. Incomputable Problems (Halting Problem)interpretclaim: we can convert a program to an AST we can build an interpreter for the AST We have a simple program p that returns only a boolean value. If we can’t determine whether such simple programs terminate, then of course we have no hope of determining whether more complex programs do. 12345678/** @return result of p on input i or does not terminate if p couldn&#x27;t terminate on input i*/boolean interpret (Program p, Object i) class p &#123; boolean main(Object i)&#123;...&#125;&#125; method interpretis correct $\\iff$ $\\forall(p,i)$ p.main(i)==interpret(p,i) terminate12/** Return whether p would halt on i */boolean terminates(Program p, Object i) Autological &amp; HeterologicalA program is either autological or heterological: autological: program is autological if it returns true when provided its own AST (return value for other inputs not defined) heterological: either returns false on itself as input or doesn’t terminate Self-ReferenceYou cannot build both interpret and terminates for a program. 12345678910class H&#123; /** returns whether P is heterological (either doesn&#x27;t terminate or return false) */ boolean main(Program p)&#123; if(terminates(p,p)) return !interpret(p,p); //terminate but returns false, so p is heterological else return true; // doesn&#x27;t terminate, so p is heterological &#125;&#125; can’t directly return !interpret(p,p) because we are not sure whether P will terminate. Therefore, we have to first check whether it terminates or not. Now we want to pass H itself to H.main note: H can always terminate no matter what p is (because if p terminates, it calls interpret, which always returns a value if p terminates; if p doesn’t terminate, it just returns a boolean value of true) Therefore, if we pass H itself, it goes into the if (terminates) &#123;&#125; block, which returns ! interpret(h,h) = !h.main(h) Therefore, calling h.main(h) actually returns !h.main(h) But how can h returns the negation of what it’s supposed to return? Therefore, there doesn’t exist a program like h. \\ Therefore, we cannot build both interpret and terminate. Since we can and did build an interpreter, terminate is what we can’t really build. That’s the why this problem is called a “halting problem”. ImplicationsTheoretical ImplicationsEvery language is either: too expressive to analyze termination precisely (incomplete) not expressive to build on interpreter (inconsistent) makes a program like H illegal (impossible to be both comprehensive and consistent) practical implicationse.g. Can we write a IntelliJ plugin to check NullPointerException? if NPE is decidable, consider the codes below 123h;x = null;x.hashcode(); // It should give you an error at this line at compile-time, which means the program can determine whether the program will actually run to this line, which means the program can determine whether h terminates Reduction: if algorithm for problem A can be used to solve B (with suitable efficiency), A must be at least as hard as B. (In the example of above A: NPE checker B: halting problem)","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"19FA","slug":"19FA","permalink":"http://yao-lirong.github.io/tags/19FA/"},{"name":"CS2112","slug":"CS2112","permalink":"http://yao-lirong.github.io/tags/CS2112/"}]},{"title":"Priority Queue and Heap","slug":"2019-11-26-Priority-Queue-and-Heap","date":"2019-11-26T05:00:00.000Z","updated":"2019-12-18T03:24:37.089Z","comments":true,"path":"2019-11-26-Priority-Queue-and-Heap/","link":"","permalink":"http://yao-lirong.github.io/2019-11-26-Priority-Queue-and-Heap/","excerpt":"From Lecture: Heaps and priority queues Priority Queue1234567interface PriorityQueue&lt;E&gt; &#123; void increasePriority(E x, int priority) //constructor PriorityQueue (ElemOps&lt;E&gt; ops);&#125;","text":"From Lecture: Heaps and priority queues Priority Queue1234567interface PriorityQueue&lt;E&gt; &#123; void increasePriority(E x, int priority) //constructor PriorityQueue (ElemOps&lt;E&gt; ops);&#125; Binary HeapInvariant Order: n.priority&lt;=n.child.priority (小根堆) shape: All leaves are at depth h or h-1 All h-depth are on the left This heap is in fact a complete binary tree ImplementationSwimif parents have bigger priority, this node should swim. Sinkif any of the child has higher priority (smaller value), we swap this node with the one with a higher priority (the smaller one). And we only sink when there is actually something to sink (we are at the second deepest level, one level above the leaves) 但是要注意，有的时候你想要sink，但是你的孩子实际上是未被初始化的一些有着随机优先值的结点，这时如果你做交换了，那就全完了。所以应当判断这个孩子结点原本在不在堆中 AddWe should preserve both the invariant when adding one element. shape: Ifwe add it at the end of the heap, shape invariant is preserved order: This invariant can be broken (though it’s at the end, it may not be the node with lowest priority) . So this newly added element should swim. Extractextract the head of the heap. But we need to replace it with something to preserve the invariant. shape: The last element in the array is a good candidate. We move it to the root of the tree. This reestablishes the shape invariant order: This invariant may now be broken. We fix the heap invariant by sinking the root 要注意我们做任何删除操作的时候，要确保这个元素已经不在数组中了(1. 长度– 2. 原本的index设为LOWEST_PRIORITY 确保它永远在堆底待着) Change in Priority shape: maintained order: we may need to bubble the element up if we increase the priority (which for a min-queue means decreasing the value) or down if we decrease the priority. You need to know the node’s index to perform swimming and sinking. But if the node is an object, how would you know its index? We can store its index inside the object. HeapifyHere is a very efficient way to turn an arbitrary array into a heap. Heapifying can be done by bubbling every element down, starting from the last element in the second last layer (叶子的前一层，叶子那一层没有可以sink的东西，或者说，叶子那一层的Heap Invariant是绝对被保存的，第一个Heap Invariant不被保存的节点是倒数第二层的第一个节点) in the array representation and working backward. The total time required to do this is linear. At most half the elements need to be bubbled down one step (倒数第二层，叶子前一层), at most a quarter of the elements need to be bubbled down two steps (倒数第三层，叶子前两层), and so on. Time Complexity: $n/2 + 2n/4 + 3n/8 + 4n/16 + … + k^n/2k + … = 2n.$ This method tells us to start from the end and bubble down. However, we can also start from the front and bubble up. The only difference is that up is slower than down in total (think about how many nodes have to go through how many layers to get to the correct position for each kind of heapify). We can also try bubbling down from the front or bubbling up from the end. These two methods are incorrect. Because when we bubble up from the front, we can guarantee that the nodes we have looped through and its parent can form a heap. Similarly, when we bubble down from the end, we can guarantee that the nodes we have looped through and its children can form a heap. However, for bubbling down from the front and bubbling up from the end, no such qualities can be guaranteed. Resizable ArrayYou can store your heap in a resizable array with a load factor as we’ve seen in the HashTables. Code in C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;chrono&gt;#include&lt;time.h&gt;using namespace std;const int M=1000000,INF=10e9; int n=0,a[M];void swim(int); void sink(int);void add(int); int extract(); int head(); void print(); int height(int);int main()&#123; /* 堆排序小测试 int num; cin&gt;&gt;num; for(int i=0;i&lt;num;i++) &#123;int now; cin&gt;&gt;now; add(now);&#125; for(int i=0;i&lt;num;i++) cout&lt;&lt;&quot;extracted&quot;&lt;&lt;extract()&lt;&lt;endl&lt;&lt;endl;*/ /* 洛谷P3378 模板 堆 int result[M/2],ans=0; int num; cin&gt;&gt;num; for(int i=0;i&lt;num;i++)&#123; int command; cin&gt;&gt;command; switch(command)&#123; case 1: int adding; cin&gt;&gt;adding; add(adding); break; case 2: result[ans++]=head(); break; case 3: extract(); break; &#125; &#125; for(int i=0;i&lt;ans;i++) cout&lt;&lt;result[i]&lt;&lt;endl;*/ /* heapify 时间测试 理论上来说sink比swim要快(需要的操作少) 但是大概因为我的sink的实现方法太烂，所以竟然 swim 快一点 int max = 100000;n=max; for(int i=0;i&lt;max;i++) a[i] = max-i; auto t0 = std::chrono::system_clock::now(); for (int i = (n/2); i &gt; 0; i--) sink(i); //for(int i=2;i&lt;=n;i++) &#123;swim(i);&#125; auto t1 = std::chrono::system_clock::now(); using milliseconds = std::chrono::duration&lt;double, std::milli&gt;; milliseconds ms = t1 - t0; std::cout &lt;&lt; &quot; time taken by my code: &quot; &lt;&lt; ms.count() &lt;&lt; &#x27;\\n&#x27;;*/ return 0;&#125;void swim(int i)&#123; while(a[i/2]&gt;=a[i]&amp;&amp;i&gt;1)&#123; //注意边界的选择：i&lt;=1的话上面已经没东西了，就没有再上游的必要了 swap(a[i/2],a[i]); i = i/2; &#125;&#125;void sink(int i)&#123; int l=i*2, r=i*2+1; while((a[i]&gt;=a[l]||a[i]&gt;=a[r])&amp;&amp;i&lt;pow(2,height(n)))&#123;//叶子的上一层才需要下沉，叶子那一层没有东西可以沉 if(a[l]&lt;=a[r]&amp;&amp;l&lt;=n)&#123; //l&lt;=n判断这个孩子结点确实在堆中，而不是一个堆外但在数组中的结点 //有问题，这个地方如果不把每个删掉的元素设为INF的话，r会一直存在在数组中； //考虑2 1 (0) 的情况，其中0是已经被删掉的元素，但是因为a[r]=0&lt;a[l]=1所以2不会sink //如果将数组初始化成INF的话，就不需要在不在堆内l&lt;=n这个条件判断了 //但是内存占用会极大提高，因为整个长为M的数组都被初始化了 swap(a[i],a[l]); i = l; l=i*2; r=i*2+1; continue; &#125; else if (a[l]&gt;a[r]&amp;&amp;r&lt;=n)&#123; swap(a[i],a[r]); i = r; l=i*2; r=i*2+1; continue; &#125; else return; &#125;&#125;void add(int i)&#123; a[++n] = i; swim(n);&#125;int extract()&#123; int result = a[1]; swap(a[1],a[n]); a[n--]=INF; sink(1); return result;&#125;int head()&#123;return a[1];&#125;// returns the height of a complete binary tree with n nodesint height(int x)&#123; if(x==0) return 1; int digit=0; while(x&gt;0) &#123;x=x&gt;&gt;1; digit++;&#125; return digit;&#125;void print()&#123;for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl;&#125; 0-1 Based上面是用Binary heap设计一个 Max-oriented Priority Queue， 数组是1-based。 假如遇到面试官问怎么heapify怎么办？ 下面我们就对上面代码进行少许改动，变为0-based，可以直接对数组进行max - heapify。 heapify()方法: 可以看出我们的heapify方法基本没有变化，除了把N / 2变成了数组的长度 nums.length / 2 sink()方法 : 这里我们要注意一下边界条件。 先设置len = nums.length，这里len就相当于之前的N， 然后再进行比较的时候，我们要把每次的 j 都减1，从1-based改变为 0-based，其他代码都不需要改变 1234567891011121314151617181920212223public static void heapify(int[] nums) &#123; if (nums == null) &#123; return; &#125; for (int k = nums.length / 2; k &gt;= 1; k--) &#123; sink(nums, k); &#125; &#125; private static void sink(int[] nums, int k) &#123; int len = nums.length; while (2 * k &lt;= len) &#123; int j = 2 * k; if (j &lt; len &amp;&amp; nums[j - 1] &lt; nums[j]) &#123; j++; &#125; if (nums[k - 1] &gt; nums[j - 1]) &#123; break; &#125; swap(nums, k - 1, j - 1); k = j; &#125; &#125;","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"19FA","slug":"19FA","permalink":"http://yao-lirong.github.io/tags/19FA/"},{"name":"CS2112","slug":"CS2112","permalink":"http://yao-lirong.github.io/tags/CS2112/"}]},{"title":"Udacity: Android Basics","slug":"2019-11-23-Android-Basics-User-Interface","date":"2019-11-23T05:00:00.000Z","updated":"2019-12-18T03:02:23.239Z","comments":true,"path":"2019-11-23-Android-Basics-User-Interface/","link":"","permalink":"http://yao-lirong.github.io/2019-11-23-Android-Basics-User-Interface/","excerpt":"User InterfaceImages &amp; Texts wrap content: android:layout_height=&quot;wrap_content&quot; dp: density-independent pixel text size: android:textsize=&quot;20sp&quot; sp: scalar-independent pixel background and text color: android:background=&quot;#66ffcc&quot; android:textColor=&quot;66ccff&quot;","text":"User InterfaceImages &amp; Texts wrap content: android:layout_height=&quot;wrap_content&quot; dp: density-independent pixel text size: android:textsize=&quot;20sp&quot; sp: scalar-independent pixel background and text color: android:background=&quot;#66ffcc&quot; android:textColor=&quot;66ccff&quot; View GroupsLinear Layout linear layout: similar to Hbox and Vbox in javaFX, one linear layout can contain many other linear layouts weight values: give different weights to layouts to determine what proportion of the space they should take in the screen Relative Layout relative layout to parent:android:layout_align_Parent(Top/Bottom/Left/Right) = &quot;true/false&quot;; android:layout_center(Horizontal/Vertical)=&quot;true&quot; assigning ID: android:id = &quot;@+id/ben_textview&quot; (used “+” because we added a new ID to the library) referring to ID: android:id = &quot;@id/ben_textview&quot; (no longer need the “+” here) relative layout to others: android:layout_to(Right/Left)Of=&quot;@id/pic&quot; Multiscreen AppsAdd texts to the Layoutwith List12345678910111213ArrayList&lt;String&gt; words;//findViewById only returns a View, we should downcast it to a LinearLayoutLinearLayout rootView = (LinearLayout) findViewById(R.id.rootView);for(String word:words)&#123; //TextView takes into a context, in this case is &quot;this&quot; TextView wordView = new TextView(this); wordView.setText(word); //add wordView to the this View of List(LinearLayout) rootView.addView(wordView);&#125; However, a LinearLayout is not scrollable and can easily go beyond the screen. Therefore, we should use an ArrayAdapter with ArrayAdapter123ArrayAdapter&lt;Word&gt; itemsAdapter = new WordAdapter(this, words);ListView listView = (ListView) findViewById(R.id.list);listView.setAdapter(itemsAdapter); We have to create two more classes: a Word class, and a customized WordAdapter that extends ArrayAdapter&lt;Word&gt;. We also have to create another XML file to customize the display of one item in the list.","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yao-lirong.github.io/tags/Android/"}]},{"title":"Import Junit and JavaFx into VSCode","slug":"2019-11-21-import-Junit-and-JavaFx-into-VSCode","date":"2019-11-21T05:00:00.000Z","updated":"2019-12-18T03:05:06.747Z","comments":true,"path":"2019-11-21-import-Junit-and-JavaFx-into-VSCode/","link":"","permalink":"http://yao-lirong.github.io/2019-11-21-import-Junit-and-JavaFx-into-VSCode/","excerpt":"The import javafx cannot be resolvedI have java 11 installed on my computer. JavaFx was not bundled with Java 11 so I have to first download it from here and put it at the same directory as Java jdk. But VScode still gives me the error “The import javafx cannot be resolved”. This was resolved after I ran Java: Clean the Java Language Server workspace, though I have no idea how VSCode magically found the directory of JavaFx.","text":"The import javafx cannot be resolvedI have java 11 installed on my computer. JavaFx was not bundled with Java 11 so I have to first download it from here and put it at the same directory as Java jdk. But VScode still gives me the error “The import javafx cannot be resolved”. This was resolved after I ran Java: Clean the Java Language Server workspace, though I have no idea how VSCode magically found the directory of JavaFx. The import Junit.Jupiter cannot be resolvedI downloaded Junit.Jupiter.api (the package I used for my tests) from here and put the jar file under workspace\\lib. Then problem was solved. Tests are now runnable.","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"http://yao-lirong.github.io/tags/Logistics/"},{"name":"Java","slug":"Java","permalink":"http://yao-lirong.github.io/tags/Java/"}]},{"title":"Shortest path algorithm","slug":"2019-11-21-shortest-path-algorithm","date":"2019-11-21T05:00:00.000Z","updated":"2019-12-18T03:24:39.397Z","comments":true,"path":"2019-11-21-shortest-path-algorithm/","link":"","permalink":"http://yao-lirong.github.io/2019-11-21-shortest-path-algorithm/","excerpt":"From Lecture: Dijkstra’s shortest path algorithm Dijkstra white: dist == infinity gray: dist &lt; infinity, in queue black: dist &lt; infinity, not in queue","text":"From Lecture: Dijkstra’s shortest path algorithm Dijkstra white: dist == infinity gray: dist &lt; infinity, in queue black: dist &lt; infinity, not in queue 123456789101112131415root.dist = 0; //root is the sourcefrontier.push(root); //root is now greywhile(!frontier.empty())&#123; Node g = frontier.pop(); for (g -&gt; v)&#123; if(v.dist==infinity)&#123; //found a new white node v.dist = g.dist + d; frontier.push(v); &#125; else&#123; // v is grey v.dist = min(v.dist, g.dist+d); &#125; &#125; //g is now black&#125; v1 and v2 is on the best path iff v1.dist+d=v2.dist Therefore, if we want to get the shortest path, we can use this algorithm to walk straight back to the graph from destination. PerformanceTotal: O((V+E)lgV) outer loop: O(V lgV) once per vertex, O(V) iterations finding min element in the queue once: O(lg V) - BST or heap inneer loop: O(E lgV) O(E) iterations time to push/update priority queue: O(lg V) CorrectnessLoop Invariant: For every black node b, gray g: b.dist&lt;=g.dist v.dist is length of shortest interior path to v (or infinity if none) (interior path means it stays in the black region, which means it only uses black nodes) Establishment:no black nodes PostCondition: no gray nodes all the nodes are black -&gt; All paths are interior path -&gt; shortest: interior path is actual answer Preservation:不写了，👴 后面看不懂了。 Application:if you have something like condition probability which has to be multiplied to produce the correct result. But so you want to know the shortest probability there. You can just take the log of probability. For example, suppose that we had a state machine that transitioned to new states with some given probability on each outgoing edge. The probability of taking a particular path through the graph would then be the product of the probabilities on edges along that path. We can then answer questions such as, “What is the most likely path that the system will follow in order to arrive at a given state?” by solving a shortest path problem in a weighted graph in which the weights are the negative logarithms of the probabilities, since $(−log a) + (−log b) = −log ab$.","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"19FA","slug":"19FA","permalink":"http://yao-lirong.github.io/tags/19FA/"},{"name":"CS2112","slug":"CS2112","permalink":"http://yao-lirong.github.io/tags/CS2112/"}]},{"title":"Graph (Recitation)","slug":"2019-11-20-Graph-(Recitation)","date":"2019-11-20T05:00:00.000Z","updated":"2019-11-23T17:13:46.747Z","comments":true,"path":"2019-11-20-Graph-(Recitation)/","link":"","permalink":"http://yao-lirong.github.io/2019-11-20-Graph-(Recitation)/","excerpt":"From Recitation: Euler paths, planar graphs, and Hamiltonian paths Edge ClassificationWe have an edge e=(v,child), where v is always grey Tree edge: 12if (child.color==white) e = TreeEdge;","text":"From Recitation: Euler paths, planar graphs, and Hamiltonian paths Edge ClassificationWe have an edge e=(v,child), where v is always grey Tree edge: 12if (child.color==white) e = TreeEdge; Back edge: 12if (child.color==grey) e = BackEdge; Forward edge: 12if (child.color==black &amp;&amp; v.timeStamp&lt;child.timeStamp) e = ForwardEdge; Cross edge: 12if (child.color==black &amp;&amp; v.timeStamp &gt; child.timeStamp) e = ForwardEdge;","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"19FA","slug":"19FA","permalink":"http://yao-lirong.github.io/tags/19FA/"},{"name":"CS2112","slug":"CS2112","permalink":"http://yao-lirong.github.io/tags/CS2112/"}]},{"title":"Graph Traversal","slug":"2019-11-19-Graph-Traversal","date":"2019-11-19T05:00:00.000Z","updated":"2019-11-23T17:13:25.840Z","comments":true,"path":"2019-11-19-Graph-Traversal/","link":"","permalink":"http://yao-lirong.github.io/2019-11-19-Graph-Traversal/","excerpt":"From Lecture: Graph traversals Tricolor AlgorithmIt is a general model of many graph traversal algorithms. Invariant: there is no black-&gt;white edge","text":"From Lecture: Graph traversals Tricolor AlgorithmIt is a general model of many graph traversal algorithms. Invariant: there is no black-&gt;white edge 123456781. color all nodes white2. color roots gray3. while(some gray node g)&#123; color g&#x27;s white sucessors grey if (no more white successors)&#123; color g black; &#125;&#125; At the end of this algorithm, there will be no grey nodes in the graph. All reachable nodes are black, while all unreachable nodes are white. Properties unique to different tricolor algorithm: which successor in which order to color grey? whether and when to color g black BFS Gray Frontier: FIFO queue v.distance = length of shortest path from root to v OR infinity if no path yet v.color==black means v.dist!=infinity &amp; v is not in queue set v.distance = infinity for all v set root.distance = 0, queue.push(root) (root.color=gray) ```javawhile(!frontier.empty()){ Node v=frontier.pop(); for (Node v&gt;g) // v is g&#39;s successor if(v.dist==infinity)&#123; // v.color==white v.distance = g.distance+1; frontier.push(v); &#125; //g is now black: g.color = black } 1234567891011121314151617181920212223## DFS- use LIFO stack- OR use recursion### Recursion:```java/** Effect: mark all nodes black that are reachable from v on all white paths. Requires: v is gray. */void visit(Node g) &#123; for (Node v&gt;g)&#123; if(v.color==white)&#123; v.color = gray; visit(v); &#125; &#125; g.color = black;&#125; cycle detection: grey -&gt; grey Therefore, if we reach a gray successor in DFS, we found a cycle DFS therefore gives linear-time cycle detection topological sort: DFS runs in a postorder traversal way: Node finishes after all descendants/dependents finished toposort = reversal postorder traversal","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"19FA","slug":"19FA","permalink":"http://yao-lirong.github.io/tags/19FA/"},{"name":"CS2112","slug":"CS2112","permalink":"http://yao-lirong.github.io/tags/CS2112/"}]},{"title":"Synchronization","slug":"2019-11-12-synchronization","date":"2019-11-12T05:00:00.000Z","updated":"2019-11-23T17:13:09.990Z","comments":true,"path":"2019-11-12-synchronization/","link":"","permalink":"http://yao-lirong.github.io/2019-11-12-synchronization/","excerpt":"From Lecture: Synchronization Monitoridea: object state guarded by its mutex monitor is just a class, whose all public methods “synchronize,” which means you can’t access state without holding mutex Principal: let short methods hold the mutex in case it doesn’t affect performance","text":"From Lecture: Synchronization Monitoridea: object state guarded by its mutex monitor is just a class, whose all public methods “synchronize,” which means you can’t access state without holding mutex Principal: let short methods hold the mutex in case it doesn’t affect performance 12T1: add(elem)T2: size(); contains(elem); when elem is added, it may not be seen in size. So add should be written as synchronized add (T elem) &#123;&#125; Locks &amp; Deadlock Lock is achieved by a mutex deadlocks happen when all threads end up being blocked by a mutex e.g.123456class a&#123; synchronized f()&#123; b.g();&#125;&#125;class b&#123; synchronized g() &#123; a.f() &#125;&#125; 12T1: a.f() ---&gt; b.g()T2: b.g() ---&gt; a.f() Say we first go into T1, we acquire a; Then before going into b.g() in T1, we acquire b.g() in T2. Then we get into a deadlock cause we can’t get b.g() in a.f() nor vice versa. That’s because we wrote a lock acquisition order in cycle Solution: no cycle write an order in which to acquire mutex e.g. a&lt;b: can’t acquire a after b (which makes b.g() illegal) And then write a spec /** Requires: lock level &lt; a */ acquire mutex in the same order (T1: A,B; T2: A,B instead of T2: B,A) Barriersin scientific computation, there are many computations embarrassingly parallel span N threads and wait until they are all done updates before barrier will be seen by all threads after the barrier 123b = new CyclicBarrier(N); // N is the number of threads(without R/W sharing)// after each thread finishes executing, it will wait(), until all threads are done// (the barrier blocks everything until N await() are called) Blocking AbstractionsHow to build your own threads-blocking abstractions? e.g.12345678910111213141516171819202122232425/** computes two threads seperately and then add them together*/class WorkerPair extends Runnable&#123; int done=0; // # threads done (0~2) Object result; WorkerPair()&#123; new Thread(this).start(); new Thread(this).start(); &#125; public void run()&#123; realDoWork(); //TODO implement this synchronized(this)&#123; // Why not put a synchronized around run()? because then only one thread will really realDoWork(); done++; result = something; &#125; &#125; Object getResult()&#123; while(done&lt;2)&#123;...&#125; return result; &#125; &#125; Condition Variables allow you to block things until some condition is true a condition variable is always associated with a mutex every Java object has its own condition variable, which ties to its own mutex A notifyAll() is sent whenever any of the conditions may become true; threads awakened by notifyAll() then test to see if their particular condition has become true; otherwise, they go back to sleep. 12345678/** Effect: blocks thread and releases mutex, wait for some condition to become true(note: why should wait() release mutex? Becuase when the program enters this waiting thread, this thread first acquires mutex, so when it begins to wait, it has to release it so other threads can do their work and finally wake it up after done) Requires: mutex is held*/void wait();/** Effect: return all wait() method (Unblocks/Wake up all threads that are waiting) Requires: mutex held*/void notifyAll(); To block until condition is true: 12345678910111213public void run()&#123; realDoWork(); synchronized(this)&#123; done++; result = something; notifyAll(); &#125;&#125;synchronized Object getResult()&#123; while(done&lt;2) wait(); return result;&#125; while (!condition) wait(); is the most usual way to write a condition variable wait(): wait for some condition to be true, which is determined by other threads notifyAll() called after whatever some of the operations already done can probably wake some method up","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"19FA","slug":"19FA","permalink":"http://yao-lirong.github.io/tags/19FA/"},{"name":"CS2112","slug":"CS2112","permalink":"http://yao-lirong.github.io/tags/CS2112/"}]},{"title":"Concurrency","slug":"2019-11-07-Concurrency","date":"2019-11-07T05:00:00.000Z","updated":"2019-11-23T17:14:51.488Z","comments":true,"path":"2019-11-07-Concurrency/","link":"","permalink":"http://yao-lirong.github.io/2019-11-07-Concurrency/","excerpt":"From Lecture: Concurrency Concurrency and Parallelism Concurrency: multiple threads (java level, can be executed by one core or multiple core) parallelism: multiple cores (hardware level. can execute one thread or multiple thread)","text":"From Lecture: Concurrency Concurrency and Parallelism Concurrency: multiple threads (java level, can be executed by one core or multiple core) parallelism: multiple cores (hardware level. can execute one thread or multiple thread) 123456789import java.lang.Thread;class Thread&#123; /** starts a new thread executing run() */ void start(); /** Effect: anything; but default does nothing*/ void run();&#125; run() 里面就是写的这个thread到底应该干什么 Threads InterferenceBest approach: most objects owned by 1 thread Read-Only sharing ok Read/Write sharing | Write/Write sharing dangerous 1234567891011class Account &#123; int balance; void withdraw(int n) &#123; int b = balance - n; // R1\u0001 balance = b; // W1\u0001 &#125; void deposit(int n) &#123; int b = balance + n; // R2\u0001 balance = b; // W2\u0001 &#125;&#125; e.g. initial balance: $100, T1 executes witdraw(50), T2 executes deposit(50) (R1, W1, R2, W2) or (R2, W2, R1, W1), the final balance is indeed $100. (R1, R2, W2, W1) destroys $50 -&gt; $50 (R2, R1, W1, W2) creates ​$50 -&gt; $150 We therefore want deposit, withdraw method to be (or at least act to be) atomic (indivisible), as if this sentence cannot be influenced by other threads (reading and writing are happening simultaneously) . Mutex(mutual exclusion locks) Threads can acquire them and release them. At most one thread can hold a mutex at a time. While a mutex is being held by a thread, all other threads that try to acquire it will be blocked until it is released, at which point just one waiting thread will manage to acquire it. every write and read to a shared mutable variable, mutex must be held 1234567/** Effect: blocks current thread until mutex is held by another thread then acquires mutex */acquire();/** Effect: release mutex */release(); 12345synchronized(Object o)&#123; //acquire o&#x27;s mutex ... // do some operations //release o&#x27;s mutex&#125; Take deposit &amp; withdraw as an example: 123456789void withdraw(int n) &#123; //do something synchronized(this) &#123; //acquire o&#x27;s mutex balance -= n; //release o&#x27;s mutex &#125; //do something else&#125; Because the pattern of wrapping entire method bodies in synchronized(this) is so common, Java has syntactic sugar for it: 123synchronized void withdraw(int n) &#123; balance -= n;&#125; Whenever mutex is not held, that variable guarded by the mutex will change unpredictably and the invariant will not hold as long as we called synchronized someMethodName() or synchronized(this). Everything in this object/class this will be held mutex (?). So we want to write small methods and small classes. As mentioned previously: Best approach: most objects owned by 1 thread Conclusion avoid unnecessary concurrency: slows down the program limit sharing of mutable state: we don’t have to care about concurrency if its immutable(read only) guard all accesses to shared mutable state with mutexes: in case of thread interference","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"19FA","slug":"19FA","permalink":"http://yao-lirong.github.io/tags/19FA/"},{"name":"CS2112","slug":"CS2112","permalink":"http://yao-lirong.github.io/tags/CS2112/"}]},{"title":"Designing and documenting interfaces and implementations","slug":"2019-10-17-Designing-and-documenting-interfaces-and-implementations","date":"2019-10-17T04:00:00.000Z","updated":"2019-11-23T17:11:57.725Z","comments":true,"path":"2019-10-17-Designing-and-documenting-interfaces-and-implementations/","link":"","permalink":"http://yao-lirong.github.io/2019-10-17-Designing-and-documenting-interfaces-and-implementations/","excerpt":"From Lecture: Designing and documenting interfaces and implementations An Example of Writing Interface1. Overview: what concerns? 12/** An n*n mutable 2048 puzzle. */class Puzzle&#123;&#125;","text":"From Lecture: Designing and documenting interfaces and implementations An Example of Writing Interface1. Overview: what concerns? 12/** An n*n mutable 2048 puzzle. */class Puzzle&#123;&#125; 2. Choose operations creators create objects constructors factory methods (usually static, loose coupling; don’t expose the choice of which class is being constructed) 12public Puzzle(int n)&#123;&#125; public static Puzzle create(int n)&#123;&#125; observers(queries): primary purpose: report the state of object no side effect (doesn’t change anything) mutators (command): primary purpose: side effect on the state of the object only makes sense when the object is mutable should maintain class invariants Command-Query Separation: You have to decide whether this class belongs to command or query, don’t write both of these things in a single method Problem with getters: representation exposure in Mutable Objects (sometimes you directly return the reference to this object and now doing modification to the returned object and unintendedly change the original object) 3. Write Specifications: Returns/Creates: postcondition Requires/Checks: precondition Effects/Modifies: side effects Examples: (as needed) Exceptions: - in return clause: when there is a client error (not programmer error) - in checks clause: when precondition violated 12345678910111213141516/** Returns: the puzzle size n*/int size();/** Effects: adds a random tile to the board*/void addRandomTile();/** Effects: adds a random tile to the board Returns: true if there was room*/boolean addRandomTile();/** Effects: adds a random tile to the board Throws: BoardFull if there is no room*/void addRandomTile() throws BoardFull;/** Effects: shifts the tiles in direction d*/void shiftTile(Direction d); 4. Documenting Impls:Audience: maintainers, not clients Goals: keep impl details out of the spec (abstraction barrier) Represents: an abstraction function: concrete fields -&gt; client view 12345/** A rational number */class Rational &#123; int num,dem; //Represents: the rational number num/dem&#125; Class Invariant: Spec for private/protected methods Algorithms Explanations: (If sometimes the spec is not enough to understand the method(specific algorithm), you should write algorithm explanations inside the method(This would be something client doesn’t have to know but maintainers may want to know so you don’t write them in the spec)) Write paragraphs instead of interleave comments 1234/** revtrieves the greatest common demoninator of x and y*/int gcd(x,y)&#123; /**This method uses Euclid&#x27;s to find the ... */&#125;","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"19FA","slug":"19FA","permalink":"http://yao-lirong.github.io/tags/19FA/"},{"name":"CS2112","slug":"CS2112","permalink":"http://yao-lirong.github.io/tags/CS2112/"}]},{"title":"Value Representation, Hashing, and Generics","slug":"2019-09-30-Value-Representation,-Hashing,-and-Generics","date":"2019-09-30T04:00:00.000Z","updated":"2019-12-25T05:14:40.128Z","comments":true,"path":"2019-09-30-Value-Representation,-Hashing,-and-Generics/","link":"","permalink":"http://yao-lirong.github.io/2019-09-30-Value-Representation,-Hashing,-and-Generics/","excerpt":"From Lecture: representing Java values Generics, more lists Hash tables Download my notes in OneNote here","text":"From Lecture: representing Java values Generics, more lists Hash tables Download my notes in OneNote here Subtyping Like other implements declarations, the declaration above that LList&lt;T&gt; implements Collection&lt;T&gt; generates a subtype relationship: in fact, a family of subtype relationships, because the subtype relationship holds regardless of what actual type T is chosen. The compiler therefore understands that the relationship LList&lt;String&gt; &lt;: Collection&lt;String&gt; holds. What about these other possible relationships? LList&lt;String&gt; &lt;: LList&lt;Object&gt; ? LList&lt;String&gt; &lt;: Collection&lt;Object&gt; ? Both of these look reasonable at first glance. But they are actually unsound, leading to possible run-time type errors. The following example shows the problem: 1234LList&lt;String&gt; ls = new LList&lt;String&gt;();LList&lt;Object&gt; lo = ls;lo.add(2112);String s = ls.head(); // extract data from head of list\u0001 The head element of the list, which is assigned to a variable of type String, is actually an Integer! This is erroneous, so the Java compiler will not allow it. A similar situation arises with arrays, although in that case the error is unfortunately only caught at run time. 1234String[] a = new String[1];Object[] b = a;b[0] = 2112;System.out.println(a[0]); The idea that there can be a subtyping relationship between different instantiations of the same generic type is called variance. Variance is tricky to support in a sound way, so Java does not support variance. Other languages such as Scala do have variance. Wildcards To make up for the lack of variance, Java has a feature called wildcards, in which question marks are used as type arguments. The type LList&lt;?&gt; represents an object that is an LList&lt;T&gt; for some type T, though precisely which type T is not known at compile time (or for that matter, even at run time). A value of type LList&lt;T&gt; (for any T) can be used as if it had type LList&lt;?&gt;, so there is a family of subtyping relationships LList&lt;T&gt; &lt;: LList&lt;?&gt;. This means that a method can provide a caller with a list of any type without the client knowing what is really stored in the list; the client can get elements from the list but cannot change the list: 1234567891011121314LList&lt;?&gt; f() &#123; LList&lt;Integer&gt; i = new LList(); i.add(2); i.add(3); i.add(5); return i;&#125;// in caller\u0001LList&lt;?&gt; lst = f();lst.add(7); // illegal: type ? not known\u0001for (Object o : lst) &#123; println(o);&#125; Note that the type of the elements iterated over is not really known either, but at least we know that the type hidden by ? is a subtype of Object. So it is type-safe to declare the variable o as an Object. If we need to know more about the type hidden by the question mark, it is possible to add an extends clause. For example, suppose we have an interface Animal with two implementing classes Elephant and Rhino. Then the type Collection&lt;? extends Animal&gt; is a supertype of both Collection&lt;Elephant&gt; and Collection&lt;Rhino&gt;, and we can iterate over the collection and extract Animals rather than just Objects. 1234Collection&lt;? extends Animal&gt; c = new LList&lt;Rhino&gt;();for (Animal a : c) &#123; // use a as Animal here\u0001&#125; Limitations The way generics are actually implemented in Java is that all actual type parameters are erased at run time. This implementation choice leads to a number of limitations of the generics mechanism in Java when in a generic context where T is a formal parameter: Constructors of T cannot be used; we cannot write new T(). The workaround for this limitation is to have an object with a factory method for creating T objects. Arrays with T as elements cannot be created, either. We cannot write new T[n] , because the type T is not known at run time and so the type T[] cannot be installed into the object’s header. The workaround for this limitation is to use an array of type Object[] instead: T[] a = (T[]) new Object[n]; This of course creates an array that could in principle be used to store things other than T’s, but as long as we use that array through the variable a, we won’t. The compiler gives us an alarming warning when we use this trick because of the unsafe cast, but this programming idiom is fairly safe. Note that if we need to create an array of T in a context where T is known to be a subtype of some type, then the array that should be created is an array of that type, rather than of Object. Similarly, we can’t create an array whose type includes a parameter type: 1HashSet&lt;String&gt;[] sets = new HashSet&lt;String&gt;[n]; // error: generic array creation\u0001 The workaround is to use a wildcard type to create the array, and dynamically cast it to the desired type: 1HashSet&lt;String&gt;[] sets = new HashSet&lt;?&gt;[n]; We can’t use instanceof to find out what type parameters are, because the object does not contain that information. If, for example, we create an LList&lt;String&gt; object, the object’s header word only records that it is an LList. So an LList&lt;String&gt; object that is statically typed as an Object can be tested to see if it is some kind of LList, but not whether the actual type parameter is String: 12345678910Object co = new LList&lt;String&gt;();if (co instanceof LList&lt;String&gt;) ... // illegal\u0001if (co instanceof LList&lt;?&gt;) ... // legal\u0001if (co instanceof LList) ... // legal but discouraged\u0001LList&lt;String&gt; ls = (LList&lt;String&gt;) co; // legal but only partly checked\u0001LList&lt;?&gt; ls = (LList&lt;?&gt;) co; // legal\u0001LList&lt;String&gt; ls = (LList&lt;?&gt;) co; // illegal\u0001LList&lt;String&gt; ls = (LList)co; // legal but discouraged\u0001 The last four lines above illustrate how downcasts interoperate with generics. Code can cast to a type with an actual type parameter, but the type parameter is not actually checked at run time; Java takes the programmer’s word that the type parameter is correct. We can cast to a wildcard instantiation, but such a cast is not very useful if we need to use the elements at their actual type. Finally, we can cast to the raw type LList; casting to raw types is unsafe. It is essentially the same as casting to LList&lt;?&gt; except that Java allows a raw type to be used as if it were any particular instantiation. Raw types should be avoided when possible. Accessing type operations What if we want to use methods of T in a generic context where T is a formal parameter? There is more than one way to do this, but in Java the most powerful approach is to provide a separate model object that knows how to perform the operations that are needed. For example, suppose we want to compare objects of type T using the compareTo method. We declare a generic interface Comparator&lt;T&gt;: 123456interface Comparator&lt;T&gt; &#123; /** Compares x and y. Return 0 if x and y are equal, a negative number if x &lt; y, * and a positive number if x &gt; y. */ int compareTo(T x, T y);&#125; Now, a generic method for sorting an array takes an extra comparator parameter: 123456789/** Sort the array a in ascending order using cmp to define the ordering on the * elements. */&lt;T&gt; sort(T[] a, Comparator&lt;T&gt; cmp) &#123; ... if (cmp.compareTo(a[i], a[j]) &gt; 0) &#123; ... &#125; ...&#125; A class can then implement the comparator interface and be used to make the right comparator operation available to the generic code. 123456789class SCmp implements Comparator&lt;String&gt; &#123; @Override public int compareTo(String x, String y) &#123; return x.compareTo(y); &#125;&#125;String[] a = &#123;&quot;z&quot;, &quot;Y&quot;, &quot;x&quot;&#125;;sort(a, new SCmp()); Notice that here we are using String‘s own compareTo operation as a model for the comparator, but we don’t have to. For example, we could have used the compareToIgnoreCase method to sort strings while ignoring the difference between upper and lower case. It turns out that we can also use Java 8’s new lambda expressions to implement the interface even more compactly. Here is how we would sort the array using a lambda expression while also ignoring case: 1sort(a, (x,y) -&gt; x.compareToIgnoreCase(y)); The lambda expression (x,y) -&gt; x.compareToIgnoreCase(y) is actually just a very convenient syntactic sugar for declaring a class like the one above and instantiating it with new. Generic classes may need to access parameter type operations too. The typical approach is to accept the model object in constructors, then to store it in an instance variable for later use by other methods: 12345678910111213141516class SortedList&lt;T&gt; implements Collection&lt;T&gt; &#123; Comparator&lt;T&gt; comparator; SortedList(Comparator&lt;T&gt; cmp) &#123; comparator = cmp; // save model object\u0001 ... &#125; boolean add(T x) &#123; ... if (comparator.compareTo(x, y)) &#123; // use model object\u0001 ... &#125; ... &#125;&#125;","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"19FA","slug":"19FA","permalink":"http://yao-lirong.github.io/tags/19FA/"},{"name":"CS2112","slug":"CS2112","permalink":"http://yao-lirong.github.io/tags/CS2112/"}]},{"title":"P1162 填涂颜色","slug":"2019-07-07-P1162-填涂颜色","date":"2019-07-07T04:00:00.000Z","updated":"2019-10-06T21:02:29.816Z","comments":true,"path":"2019-07-07-P1162-填涂颜色/","link":"","permalink":"http://yao-lirong.github.io/2019-07-07-P1162-%E5%A1%AB%E6%B6%82%E9%A2%9C%E8%89%B2/","excerpt":"题目来源：洛谷P1162 填涂颜色 如果被包围的部分没什么特点，那么就可以看看其他部分有没有什么特点，本题中就是可以从外围开始搜索，搜到墙就停下，最后没被搜到的部分就是被墙包围的部分 为了防止外围起点就是墙，或者是外围的0被墙分为好几部分导致我们无法搜索到被分割的部分，可以多开一圈数组，使得外围相互连接起来，确保不被包围的0一定可以被搜到","text":"题目来源：洛谷P1162 填涂颜色 如果被包围的部分没什么特点，那么就可以看看其他部分有没有什么特点，本题中就是可以从外围开始搜索，搜到墙就停下，最后没被搜到的部分就是被墙包围的部分 为了防止外围起点就是墙，或者是外围的0被墙分为好几部分导致我们无法搜索到被分割的部分，可以多开一圈数组，使得外围相互连接起来，确保不被包围的0一定可以被搜到 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,dir[4][2]=&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;bool graph[32][32],vis[32][32];///graph 记录这个图原来是0还是1（空还是墙），vis记录被没被访问过///注意这两个数组都是开的32（数据是1~30，本来开31就够了）保证了外面又一圈0，也就是最外面的一圈都是联通的，避免了第一个点1,1就是墙导致循环循环不下去的情况，也避免了一堵墙把中间全部堵死，只扫了墙左边的0，没扫同在墙外但在墙右边的0的情况void dfs(int, int);int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) cin&gt;&gt;graph[i][j]; dfs(0,0); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(vis[i][j]) cout&lt;&lt;&quot;0 &quot;;///如果访问过，那么一定是墙外的0 else if(graph[i][j]) cout&lt;&lt;&quot;1 &quot;;///输入时原本是墙，那么它还是墙（这一句可以和上面那一句互换位置） else cout&lt;&lt;&quot;2 &quot;;///及没被访问过，输入时也不是墙，那么肯定是被包围在里面的0 &#125; cout&lt;&lt;endl; &#125; return 0;&#125;void dfs(int x, int y)&#123; if( x&lt;0 | x&gt;n+1 | y&lt;0 | y&gt;n+1 | graph[x][y] | vis[x][y] ) ///如果1.越界（注意是 &lt;0|&gt;n+1 这里可以看出来我们多开了一圈0在原输入外面） ///2.是墙|被访问过 那么不做操作 return; vis[x][y]=true; for(int i=0;i&lt;4;i++) dfs(x+dir[i][0],y+dir[i][1]);&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"http://yao-lirong.github.io/tags/NOI/"}]},{"title":"P1141 01迷宫","slug":"2019-07-04-P1141-01迷宫","date":"2019-07-04T04:00:00.000Z","updated":"2019-10-06T21:02:20.863Z","comments":true,"path":"2019-07-04-P1141-01迷宫/","link":"","permalink":"http://yao-lirong.github.io/2019-07-04-P1141-01%E8%BF%B7%E5%AE%AB/","excerpt":"题目来源：洛谷P1141 01迷宫 BFS找连通块 连通块肯定还是DFS找得快，因为一开始不知道什么是连通块所以写了个BFS 搜索连通块不需要记录从某一个点出发最远能到达哪个点（BFS搜索最短距离），只需要记录从某一个点出发一共经过了多少个符合条件的点就行了（BFS搜索连通块），因为如果A和B联通，B和C联通，那么A和C必然联通，所以一次搜索能达到的所有点必定在同一个连通块内","text":"题目来源：洛谷P1141 01迷宫 BFS找连通块 连通块肯定还是DFS找得快，因为一开始不知道什么是连通块所以写了个BFS 搜索连通块不需要记录从某一个点出发最远能到达哪个点（BFS搜索最短距离），只需要记录从某一个点出发一共经过了多少个符合条件的点就行了（BFS搜索连通块），因为如果A和B联通，B和C联通，那么A和C必然联通，所以一次搜索能达到的所有点必定在同一个连通块内 如果对于每个查询我们都搜索一遍的话肯定会超时，所以我们用vis数组记录下来一次搜索中所有经过的点所在的（必定是同一个）连通块的序号，ans数组记录相应序号的连通块中共有几个点，下次如果询问的点已经被搜索过就可以免去搜索直接输出答案了。 程序向本来被封死的地方走了一步，可能是初始化的问题。初始化就别用那些花里胡哨的句子了，还是老老实实写for循环吧，反正时间空间够用，别的句子太容易出错 莫名其妙输出来几十万的数据，估计是爆内存了，数组一定要根据题目要求开得足够大 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;struct node&#123; int x,y;&#125;;int m,n,question[100005][2],dir[4][2]=&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;,vis[1003][1003],ans[100005],connect=1; bool maze[1003][1003];///question 存储了每组询问的起点坐标///vis = 0 代表这个点没走过，现在不在任何一个连通块里面；vis = x (x&gt;0) 代表这个点走过了，并且在x号连通块里面；这个数组一定要开大，只开到1003是不行的，必须要开到和question一个数量级///ans 存储每个连通块里面共有几个点///maze 存储这个迷宫///connect 代表各个连通块的序号int bfs(int, int); bool legal(node, node);int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)&#123; char a; cin&gt;&gt;a; if(a==&#x27;0&#x27;) maze[i][j]=0; else if(a==&#x27;1&#x27;) maze[i][j]=1; &#125;///因为每个输入之间是不空格的，所以用char来输入做一个巧妙的处理 for(int i=1;i&lt;=m;i++) cin&gt;&gt;question[i][0]&gt;&gt;question[i][1]; ///初始化最后出了很大问题，还是用最保险的for循环 for(int i=0;i&lt;100005;i++) ans[i]=1; for(int i=0;i&lt;1003;i++) for(int j=0;j&lt;1003;j++) vis[i][j]=0; for(int i=1;i&lt;=m;i++) cout&lt;&lt;bfs(question[i][0],question[i][1])&lt;&lt;endl; return 0;&#125;bool legal(node now, node next)&#123; ///这里不需要分情况讨论“如果 now==0 则必须 next==1” 或相反，只需要确保now和next的值不同就行了 return maze[now.x][now.y]!=maze[next.x][next.y] &amp;&amp; next.x&gt;=1 &amp;&amp; next.x&lt;=n &amp;&amp; next.y&gt;=1 &amp;&amp; next.y&lt;=n &amp;&amp; vis[next.x][next.y]==0;&#125;int bfs(int x, int y)&#123; queue &lt;node&gt; q; node start; start.x = x; start.y = y; if(vis[start.x][start.y]==0)&#123;///如果这个点不在现有的任何一个连通块内，则进入队列，开始bfs vis[start.x][start.y] = connect; q.push(start); &#125; else return ans[vis[start.x][start.y]];///如果这个点在某个连通块内，则直接输出此连通块对应的结果 while(!q.empty())&#123; node now = q.front(); q.pop(); for(int i=0;i&lt;4;i++)&#123; node next; next.x = now.x + dir[i][0]; next.y = now.y + dir[i][1]; if(legal(now,next))&#123; vis[next.x][next.y] = connect;///记录下来点next属于连通块connect ans[connect]++;///连通块connect中总点数+1 q.push(next); &#125; &#125; &#125; return ans[connect++];///所有属于connect的点都搜完了，返回答案，并使connect++，表示接下来要扫的是新的连通块&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"http://yao-lirong.github.io/tags/NOI/"}]},{"title":"P1118 Backward Digital Sums","slug":"2019-07-02-P1118-Backward-Digital-Sums","date":"2019-07-02T04:00:00.000Z","updated":"2019-10-06T21:02:06.301Z","comments":true,"path":"2019-07-02-P1118-Backward-Digital-Sums/","link":"","permalink":"http://yao-lirong.github.io/2019-07-02-P1118-Backward-Digital-Sums/","excerpt":"题目来源：洛谷P1118 数字三角形 暴力搜索看到题目的第一眼想的就是直接搜，发现不少TLE，我还减了不少枝… 超时，只有20分，通过几个运行结果来看，写法应该对了，只是全都TLE而已","text":"题目来源：洛谷P1118 数字三角形 暴力搜索看到题目的第一眼想的就是直接搜，发现不少TLE，我还减了不少枝… 超时，只有20分，通过几个运行结果来看，写法应该对了，只是全都TLE而已 ^在c++中不是幂运算，是异或（如果两个相应位为“异”（值不同），则该位结果为1，否则为0。0^0=0; 0^1=1; 1^0=1; 1^1=0）。幂运算用pow(base,power) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;int n,tri[13][13],ans[13]; bool flag=true;void dfs(int);int main()&#123; int start; cin&gt;&gt;n&gt;&gt;start; tri[n][1]=start; dfs(n-1); if(!flag) for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;; return 0;&#125;void dfs(int level)&#123; if(flag)&#123; int lbound=pow(2,level-1),ubound=tri[level+1][1]-lbound;///lbound(lower_bound)是假设第一行全是1，得出的后续几行的最小值 for(int i=lbound;i&lt;=ubound;i++)&#123; if(!flag) continue; tri[level][1]=i; bool jump=false; for(int j=1;j&lt;=n-level;j++)&#123; tri[level][j+1]=tri[level+1][j]-tri[level][j]; ///可以加一个判定条件，如果小于XXX，就停止本次搜索 if(tri[level][j+1]&lt;lbound) &#123;jump=true; break;&#125;///与前面的lbound定义一样，如果一不下心搜出来0或者-1那么肯定不对 if(tri[level][j+1]==tri[level][j]) &#123;jump=true; break;&#125;///自己发现的规律，相邻两项不可能相等，因为相邻的两项相等会导致再上面一层也有两项相等，直到第一层有两项相等，意味着答案不符合条件 &#125; if(jump) continue; for(int j=1;j&lt;=n-level+1;j++)&#123; cout&lt;&lt;tri[level][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; if(level==1)&#123; int sum=0; for(int i=1;i&lt;=n;i++)&#123; sum+=pow(2,tri[1][i]); sum-=pow(2,i); &#125;///这个地方用了一个二进制的性质算我们的答案第一行是否是1~N的数字且互不相同(每个1~N的数都有两种状态，在答案里有或者没有) if(sum==0)&#123;///sum==0 代表sum(pow(2,tri[1][i]))==sum(pow(2,i)) for(int i=1;i&lt;=n;i++) ans[i]=tri[1][i]; flag=false; &#125; /// 停止所有搜索，已找到答案 &#125; if(level&gt;1&amp;&amp;flag==true) dfs(level-1); &#125; &#125;&#125; 杨辉三角以下为杨辉三角一维dfs，只有70分，还是需要剪枝 首先要搞清楚这个数字三角形究竟是什么吧。大家可以自己在草稿纸上写一下，假设n为一个比较小的数(比如，按样例，4)，设第一行的n个数分别为a,b,c,…(我这里是a,b,c,d)，然后模拟加一下，就会发现sum是…… 如果n为4，那么sum是a+3b+3c+d。 如果n为5，那么sum是a+4b+6c+4d+e。 如果n为6，那么sum是a+5b+10c+10d+5e+f。 观察各项的系数，你发现了什么？ 如果你有敏锐的数学眼光，你会发现，各项系数恰与杨辉三角有关！ 那么我们就可以枚举每个a,b,c,…，逐一与sum比较，就可以得出答案了。~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int yanghui[13][13],ans[13],n,sum; bool vis[13];int compute();void dfs(int);int main()&#123; cin&gt;&gt;n&gt;&gt;sum; memset(vis,true,sizeof(vis)); ///初始化杨辉三角 yanghui[1][1]=1;yanghui[2][1]=1;yanghui[2][2]=1; for(int i=3;i&lt;=n;i++)&#123; yanghui[i][1]=1; for(int j=2;j&lt;=i;j++) yanghui[i][j]=yanghui[i-1][j-1]+yanghui[i-1][j]; &#125; dfs(1);///从第一个位置开始搜索 return 0;&#125;int compute()///当已经枚举到了最后一位时，可以计算现在答案的值是否真的等于我们输入的sum&#123; int temp=0; for(int i=1;i&lt;=n;i++) temp+=ans[i]*yanghui[n][i]; return temp;&#125;void dfs(int pointer)&#123; for(int i=1;i&lt;=n;i++)&#123; if(vis[i])&#123; ans[pointer]=i; vis[i]=false; if(pointer==n&amp;&amp;compute()==sum) &#123; for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;; break; &#125; if(pointer&lt;n) dfs(pointer+1); ans[pointer]=0; vis[i]=true; &#125; &#125;&#125; 二维DFS上面方法的问题在于：只在所有位置都选完的时候才判定是否符合条件(sum=sum_to_find|(在这个程序中)sum=compute())，但是有很多情况下在我们没选完的时候就已经不符合条件了(sum&gt;sum_to_find)。我们必须要排除这种情况，这样的话就必须在搜索的同时记录现在状态下合(sum)的大小，那么我们就需要写一个二维的dfs ~~实在太蠢了，把所有要判定的地方都加上&amp;flag运行时间直接从1500ms提到了101ms ~~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int yanghui[13][13],ans[13],n,sum_to_find; bool vis[13],flag=true;int compute();void dfs(int,int);int main()&#123; cin&gt;&gt;n&gt;&gt;sum_to_find; memset(vis,true,sizeof(vis)); ///初始化杨辉三角 yanghui[1][1]=1;yanghui[2][1]=1;yanghui[2][2]=1; for(int i=3;i&lt;=n;i++)&#123; yanghui[i][1]=1; for(int j=2;j&lt;=i;j++) yanghui[i][j]=yanghui[i-1][j-1]+yanghui[i-1][j]; &#125; dfs(1,0); return 0;&#125;void dfs(int pointer,int sum)&#123; if(flag)&#123;///这个地方代码这么丑是因为我把所有要判定的地方都加上&amp;flag，不然TLE for(int i=1;i&lt;=n;i++)&#123; if(vis[i]&amp;&amp;flag)&#123; ans[pointer]=i; vis[i]=false; sum+=ans[pointer]*yanghui[n][pointer]; if(pointer==n&amp;&amp;sum==sum_to_find&amp;&amp;flag) &#123; for(int i=1;i&lt;=n;i++) &#123;cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;; flag=false;&#125; break; &#125; if(pointer&lt;n&amp;&amp;sum&lt;sum_to_find&amp;&amp;flag) dfs(pointer+1,sum); sum-=ans[pointer]*yanghui[n][pointer]; ans[pointer]=0;///这两句的顺序可不能搞混了，要先还原sum值，再还原ans值，因为sum值和ans值有关 vis[i]=true; &#125; &#125;&#125;&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"http://yao-lirong.github.io/tags/NOI/"}]},{"title":"P1019 单词接龙","slug":"P1019 单词接龙","date":"2019-06-26T04:00:00.000Z","updated":"2019-06-27T12:39:41.866Z","comments":true,"path":"P1019 单词接龙/","link":"","permalink":"http://yao-lirong.github.io/P1019%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/","excerpt":"题目来源：洛谷P1019 单词接龙 调了好几天，最后请教了醉神(@magolor)，十分钟给我调好了… 这个程序一个问题就是循环根本就不会吧dict全循环一遍，那可能就是初始化出了问题： m=pointer 的位置，当时记得应该写一个副本 m 代替 pointer 被改变，但是写着写着忘了 m 具体应该在哪被初始化了，问题就出现在这 回溯的状态：一定要明确回溯应当回溯到具体那个状态，是ans_temp已经被改变的状态吗？还是未改变的状态？本题中是ans_temp未改变的状态","text":"题目来源：洛谷P1019 单词接龙 调了好几天，最后请教了醉神(@magolor)，十分钟给我调好了… 这个程序一个问题就是循环根本就不会吧dict全循环一遍，那可能就是初始化出了问题： m=pointer 的位置，当时记得应该写一个副本 m 代替 pointer 被改变，但是写着写着忘了 m 具体应该在哪被初始化了，问题就出现在这 回溯的状态：一定要明确回溯应当回溯到具体那个状态，是ans_temp已经被改变的状态吗？还是未改变的状态？本题中是ans_temp未改变的状态 我的解与标解 跟我的做法一样，区别只是标解用for循环枚举j而不是跟我一样用直接用dfs函数 下面是我的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;char dict[21][30],ans[500]; int n,vis[21],ans_max=0,ans_temp=0;void dfs(int,int);int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;dict[i]; for(int i=1;i&lt;=n;i++) vis[i]=2; cin&gt;&gt;dict[0][0];///开头的字母 dfs(0,0); cout&lt;&lt;ans_max; return 0;&#125;void dfs(int word,int pointer)&#123; if(pointer&lt;strlen(dict[word]))&#123; ans_temp++; int ans_mark=ans_temp; ans_max=max(ans_max,ans_temp); dfs(word,pointer+1);///这句话以上是将本单词中的下一个字母加入答案字符串中，以下是将查看以这个字母为基准，能不能接上其他单词的龙 ans_temp=ans_mark; &#125; int m; for(int i=1;i&lt;=n;i++)&#123;///枚举n个词中哪个词的首字母可以和现在字符串的最后一个相同 if(vis[i]&gt;0)&#123; int j=0; ///!!! m=pointer; ///!!!其他人的做法是直接枚举单词 word 中的所有字母，不像我是通过 dfs(word,pointer+1)来枚举，所以不需要考虑pointer如何如何，我们这里如果对 pointer 后面的字母(pointer+1,pointer+2,...)一个个进行比对，必然会改变pointer的值，所以用了一个副本 m 进行比对，保证pointer值不变 if(dict[word][m]==dict[i][j])&#123;///如果头一个字母相同 bool flag=true; while(m&lt;strlen(dict[word]))&#123;///一直比对到最后一个字母，并且这里判断了“相邻的两部分不能存在包含关系”这一条件 if(dict[word][m]!=dict[i][j]) flag=false; m++; j++; &#125; if(flag)&#123;///如果每个字母都一样 ///!!! int ans_mark=ans_temp;///记录一下现在的长度，因为再进行其他的dfs，ans_temp会被更新 ans_temp+=j-1;///答案字符串的长度就可以加上新加入的单词的长度 ///!!!注意这个地方这两句话应该是先记录 ans_temp 再更新 ans_temp ，因为我们最后回溯的时候是要回溯到没有接龙接上当前单词的状态，所以应该是先记录，后更新 ans_max=max(ans_max,ans_temp); vis[i]--; dfs(i,j); vis[i]++; ans_temp=ans_mark;///把ans_temp更新回来 &#125; &#125; &#125; &#125;&#125; 先预处理得到两两单词间的最短重合部分，然后搜索得到答案 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;string dict[31]; int ans_now=1,ans_max=0,n,vis[31],overlap[31][31];///这个地方把 ans_now 设为1，是因为第一个开头的字母不会被算在长度内，为了把这个开头的字母算进去，ans_now 从1开始int find_overlap(string,string);///寻找两个单词的最小重合部分void dfs(int);int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;dict[i]; for(int i=1;i&lt;=n;i++) vis[i]=2; cin&gt;&gt;dict[0];///开头的字母 memset(overlap,0,sizeof(overlap)); for(int i=0;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) overlap[i][j]=find_overlap(dict[i],dict[j]); dfs(0); cout&lt;&lt;ans_max; return 0;&#125;int find_overlap(string a, string b)///其中，a是将要被别人接上去的字符串，b是想要接上去的字符串&#123; for(int i=a.size()-1;i&gt;=0;i--)&#123;///倒序寻找最小重合部分的大小 int ja=i,jb=0; bool flag=true; while(ja&lt;a.size())&#123;///正序看看这个部分是否重合 if(a[ja]!=b[jb]) &#123;flag=false; break;&#125; ja++; jb++; &#125; if(flag)&#123; int ans_overlap=a.size()-i; ///得到重叠部分的大小 if(ans_overlap!=a.size()&amp;&amp;ans_overlap!=b.size()) return ans_overlap; ///判断重叠部分是不是包含部分，如果不是就返回答案 else if(a.size()==1) return ans_overlap; ///如果是开头的字母(cin&gt;&gt;dict[0])，永远有 ans_overlap==a.size()==0 那么不管ans_overlap!=a.size()是否成立，我们都要返回答案 else return 0;///其他的情况下，重叠部分是包含部分，不能接龙，所以返回0 &#125; &#125; return 0;///没找到重叠部分&#125;void dfs(int word)&#123; for(int i=1;i&lt;=n;i++)&#123; if(overlap[word][i]&gt;0 &amp;&amp; vis[i]&gt;0)&#123; ans_now+=dict[i].size()-overlap[word][i];///接上的字符串的长度 ans_max=max(ans_max,ans_now); vis[i]--; dfs(i); vis[i]++; ans_now-=dict[i].size()-overlap[word][i]; &#125; &#125;&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"http://yao-lirong.github.io/tags/NOI/"}]},{"title":"P1101 单词方阵","slug":"P1101 单词方阵","date":"2019-06-17T04:00:00.000Z","updated":"2019-06-27T12:38:11.330Z","comments":true,"path":"P1101 单词方阵/","link":"","permalink":"http://yao-lirong.github.io/P1101%20%E5%8D%95%E8%AF%8D%E6%96%B9%E9%98%B5/","excerpt":"题目来源：洛谷P1101 单词方阵 dir 这个数组是很好用的，不需要为8个方向特意写8个不同的函数，只需要写一个函数但是改变取哪一个dir[i]来判定哪一个方向符合条件就行了","text":"题目来源：洛谷P1101 单词方阵 dir 这个数组是很好用的，不需要为8个方向特意写8个不同的函数，只需要写一个函数但是改变取哪一个dir[i]来判定哪一个方向符合条件就行了 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;char matrix[103][103], yizhong[8]=&quot;yizhong&quot;; bool mark[103][103];/// matrix 存储每个位置的字母，yizhong 存储我们要找的字符串 &quot;yizhong&quot;，mark存储这个位置符不符合要求，最后要不要被变成 &quot;*&quot; 输出int dir[8][2]=&#123;&#123;0,1&#125;,&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;,&#123;0,-1&#125;,&#123;-1,-1&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;&#125;;/// dir[8] 存储了8个方向，dir[i][0] 是x轴坐标，dir[i][1] 是y轴坐标void dfs(int,int); /// 这个题虽然放在dfs里面但是因为这个字符串的方向是固定的，不会拐弯抹角，所以好像和dfs没什么关系int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) cin&gt;&gt;matrix[i][j]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dfs(i,j); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(mark[i][j]) cout&lt;&lt;matrix[i][j]; else cout&lt;&lt;&quot;*&quot;; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;void dfs(int x, int y)&#123; for(int i=0;i&lt;8;i++)&#123; ///对于任意一个点，我们都看看它周围八个方向各自符不符合条件 int j=0;bool flag=true; while(j&lt;7)&#123; ///分别检视每一个字符 与 yizhong 是否匹配 if(matrix[x+j*dir[i][0]][y+j*dir[i][1]] != yizhong[j])&#123; ///非常精髓 flag=false; break; /// 不匹配，flag=false &#125; j++; &#125; if(flag)&#123; ///匹配的话就记录下来它们是符合要求的，最后直接输出当前位置的字符 for(int j=0;j&lt;7;j++) mark[x+j*dir[i][0]][y+j*dir[i][1]]=true; &#125; &#125;&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"http://yao-lirong.github.io/tags/NOI/"}]},{"title":"P1219 八皇后","slug":"P1219 八皇后","date":"2019-06-16T04:00:00.000Z","updated":"2019-06-27T12:35:50.676Z","comments":true,"path":"P1219 八皇后/","link":"","permalink":"http://yao-lirong.github.io/P1219%20%E5%85%AB%E7%9A%87%E5%90%8E/","excerpt":"题目来源：洛谷P1219 八皇后 我的解法自己的程序出现的几个问题： 对角线表达式太过复杂，各层绝对值都可以简化，应该相信大部分情况下复杂的都是错误的 不需要记录这一行放没放过棋子，因为我们是按照一行一行的顺序放过来的，上一行必定有棋子，下一行必定无棋子","text":"题目来源：洛谷P1219 八皇后 我的解法自己的程序出现的几个问题： 对角线表达式太过复杂，各层绝对值都可以简化，应该相信大部分情况下复杂的都是错误的 不需要记录这一行放没放过棋子，因为我们是按照一行一行的顺序放过来的，上一行必定有棋子，下一行必定无棋子 注意初始化的部分，一开始就是把循环语句里写成了 NE_SW[i]=true; NE_SW[i+1]=true 导致了错误而且一直没检查出来 最后那个存储 solution 的地方还是有问题，如果找到了某一行的一个解并且继续向下搜寻这一行的其他解的话，会出现不存储前面几行棋子位置的问题，没想到解决方法只能在输出的地方做了些操作 大部分标解中dfs只有一个参数就是行数x然后对于每个x进行for循环枚举纵坐标y，我这样的做法也可以 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;bool board[14][14],col[14],line[14],NE_SW[26],NW_SE[26]; int n,ans,solution[3][15];bool flag(int, int);void dfs(int, int);int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123;col[i]=true; line[i]=true; NE_SW[i]=true; NW_SE[i]=true; NE_SW[i+n]=true; NW_SE[i+n]=true;&#125;/// 这个地方初始化一定要注意 dfs(1,1); for(int i=0;i&lt;3;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(solution[i][j]==0) solution[i][j]=solution[i-1][j]; cout&lt;&lt;solution[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;ans;&#125;bool flag(int x,int y)///判定这个点能不能放棋子&#123; if(col[x]&amp;&amp;line[y])&#123;if(NE_SW[x+y-1])&#123; if( y&lt;=x &amp;&amp; NW_SE[n-int(abs(x-y))] ) return true; else if( y&gt;x &amp;&amp; NW_SE[n+int(abs(x-y))] ) return true; //cout&lt;&lt;&quot;最后一个对角线出了问题&quot;&lt;&lt;endl; &#125;//cout&lt;&lt;&quot;第一个对角线出了问题&quot;&lt;&lt;endl; &#125; //cout&lt;&lt;&quot;x,y有问题&quot;&lt;&lt;endl; return false;&#125;void dfs(int x,int y)&#123; ///cout&lt;&lt;&quot;function called at&quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl; if(flag(x,y))&#123; //if(x==n) ans++; if(ans&lt;=3) solution[ans][x]=y; ///cout&lt;&lt;endl&lt;&lt;&quot;one unit placed at&quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl&lt;&lt;endl; col[x]=false; line[y]=false; if(y&lt;=7-x) NE_SW[x+y-1]=false; ///左上角部分的 右上-左下对角线 else NE_SW[x+y-1]=false; /// 右下角部分的 右上-左下对角线 if(y&lt;=x) NW_SE[n-int(abs(x-y))]=false; ///右上角部分的 左上-右下对角线 else NW_SE[n+int(abs(x-y))]=false; ///左下角部分 左上-右下对角线 if(x==n) &#123;ans++;&#125; ///cout&lt;&lt;&quot;-------------&quot;&lt;&lt;endl&lt;&lt;&quot;one solution found, total solution is now &quot;&lt;&lt;ans&lt;&lt;endl&lt;&lt;&quot;-------------&quot;&lt;&lt;endl;&#125; else dfs(x+1,1); col[x]=true; line[y]=true; if(y&lt;=7-x) NE_SW[x+y-1]=true; ///左上角部分的 右上-左下对角线 else NE_SW[x+y-1]=true; /// 右下角部分的 右上-左下对角线 if(y&lt;=x) NW_SE[n-int(abs(x-y))]=true; ///右上角部分的 左上-右下对角线 else NW_SE[n+int(abs(x-y))]=true; ///左下角部分 左上-右下对角线 ///cout&lt;&lt;&quot;value changed back at&quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl; &#125; if(y&lt;n) dfs(x,y+1);&#125; 更可读的代码以及问题优化 优化了对角线的表达 优化了答案位置的记录 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;bool col[14],line[14],NE_SW[26],NW_SE[26]; int n,ans=0,solution[14]; /// col[x] line[y]/// NE_SW 右上向左下方向的对角线，从左上角(1,1)为第一条，第二条是(2,1)-(1,2)/// NW_SE 左上到右下方向的对角线，从右上角(1,n)为第一条，第二条是(n-1,1)-(n,2)void dfs(int,int);bool flag(int,int);int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123;col[i]=true; line[i]=true; NE_SW[i]=true; NW_SE[i]=true; NE_SW[i+n]=true; NW_SE[i+n]=true;&#125; dfs(1,1); cout&lt;&lt;ans; return 0;&#125;bool flag(int x,int y)&#123; return col[x]&amp;&amp;line[y]&amp;&amp;NE_SW[x+y]&amp;&amp;NW_SE[n+y-x];&#125;void dfs(int x,int y)&#123; if(flag(x,y))&#123; solution[x]=y;///注意这个地方特别精髓，因为如果我们每个答案都开新的一行数组记录的话有可能会出现上面问题4说的情况，所以我们只需要每次覆盖记录就好了，反正x永远是按从上到下的顺序来的 //col[x]=false; line[y]=false; NE_SW[x+y]=false; NW_SE[n+y-x]=false; col[x]=!col[x]; line[y]=!line[y]; NE_SW[x+y]=!NE_SW[x+y]; NW_SE[n+y-x]=!NW_SE[n+y-x]; ///注意 !col[x] 只是表达 col[x] 取反的一个值，只有 col[x]=!col[x] 才能给原波尔值赋值为它的反 if(x==n)&#123;///最后一行也被填好了，我们得到一个解 ans++; if(ans&lt;=3)&#123; for(int i=1;i&lt;=n;i++) cout&lt;&lt;solution[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; &#125; else dfs(x+1,1);///还不到最后一行的话就接着去找下一行 ///回溯：拿走刚刚放下的棋子 //col[x]=true; line[y]=true; NE_SW[x+y]=true; NW_SE[n+y-x]=true; col[x]=!col[x]; line[y]=!line[y]; NE_SW[x+y]=!NE_SW[x+y]; NW_SE[n+y-x]=!NW_SE[n+y-x]; &#125; ///如果这个位置不符合条件(flag(x,y)==false)/这个位置符合条件的情况已经被全部枚举了(flag(x,y)==true) 那么我们就可以去找本行的下一个位置是否满足条件 if(y&lt;n) dfs(x,y+1);&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"http://yao-lirong.github.io/tags/NOI/"}]},{"title":"P1031 均分纸牌","slug":"P1031 均分纸牌","date":"2019-06-04T04:00:00.000Z","updated":"2019-06-27T12:40:49.788Z","comments":true,"path":"P1031 均分纸牌/","link":"","permalink":"http://yao-lirong.github.io/P1031%20%E5%9D%87%E5%88%86%E7%BA%B8%E7%89%8C/","excerpt":"题目来源：洛谷P1031 均分纸牌 标解注意本题中平均数的运用 首先，一定要想到每堆排的张数减去平均张数，这样，题目就变成了移动正数，加到负数中，是大家都变成了0，这就意味着成功了60%！！！！（关键）。以例题来说，平均张数为10，原张数变为-1，-2,+7，-4，因为没有为0的数，所以从最左边出发，将-1移动到-2中，变为0，-3，+7,4，再讲-3向右移动……一次类推，直到全为0为止。没移动一次，步数便加1。关键是，负数怎么移动，其实，移动-x张牌，其实就是从另一堆中移动x张牌，步数相同。还有就是要过滤0，如排数为4，4,2,6，则减去平均数后为0,0，-2,2，就要从第三对开始移动。注意有些0是不能过滤的，如1,0,1，-2中的0。还有就是每次移动好都要过滤。如-2，2,1,3，-4，第一步后变为0,0,1,3，-4，可以省略第二堆的移动。","text":"题目来源：洛谷P1031 均分纸牌 标解注意本题中平均数的运用 首先，一定要想到每堆排的张数减去平均张数，这样，题目就变成了移动正数，加到负数中，是大家都变成了0，这就意味着成功了60%！！！！（关键）。以例题来说，平均张数为10，原张数变为-1，-2,+7，-4，因为没有为0的数，所以从最左边出发，将-1移动到-2中，变为0，-3，+7,4，再讲-3向右移动……一次类推，直到全为0为止。没移动一次，步数便加1。关键是，负数怎么移动，其实，移动-x张牌，其实就是从另一堆中移动x张牌，步数相同。还有就是要过滤0，如排数为4，4,2,6，则减去平均数后为0,0，-2,2，就要从第三对开始移动。注意有些0是不能过滤的，如1,0,1，-2中的0。还有就是每次移动好都要过滤。如-2，2,1,3，-4，第一步后变为0,0,1,3，-4，可以省略第二堆的移动。 1234567891011#include &lt;iostream&gt; using namespace std; int main() &#123; int a,p=0,js=0; cin &gt;&gt;a;int q[a]; for (int y=0;y&lt;a;y++)&#123;cin &gt;&gt;q[y]; p+=q[y];&#125; p/=a; for (int y=0;y&lt;a;y++)q[y]-=p; for (int y=0;y&lt;a;y++) &#123;if (q[y]==0)continue; q[y+1]+=q[y]; js++; &#125; cout &lt;&lt;js; return 0;&#125; 我的解法1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int sum=0,card[103],num,mean,no_count=0; cin&gt;&gt;num; for(int i=1;i&lt;=num;i++) &#123;cin&gt;&gt;card[i]; sum+=card[i];&#125; mean=sum/num; int pointer=0,local_sum=0; for(int i=1;i&lt;=num;i++)&#123; local_sum+=card[i]; pointer++;///我的思路是记录有没有一个 local_max==local_sum，如果有 local_sum，即pointer所指的那一堆，之前的就全部排好了，不需要再操心了 if(pointer==1 &amp;&amp; card[i]==mean) &#123;pointer=1; no_count++;&#125; ///直接等于平均数的堆要拿出来特殊讨论，因为他们只有跟在已经排好序的堆后面的时候才不需要再经过一次移动，而前面的堆已经排好序的标志就是 pointer==1，这种情况下我们可以少移动一个，并且重新设置 pointer==1 代表前面的堆都有序 if(local_sum==pointer*mean &amp;&amp; pointer!=1)&#123; /// local_sum==pointer*mean 此时我们找到一个堆，可以使前面的所有堆获得符合要求的解，并且他只需要向别人输送牌，自己不需要接受，所以有一个 no_count++ /// pointer!=1 这是 local_sum 就是他本身，必然相等 no_count++; pointer=0; local_sum=0; &#125; &#125; cout&lt;&lt;num-no_count;&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"http://yao-lirong.github.io/tags/NOI/"}]},{"title":"P2678 跳石头","slug":"P2678 跳石头","date":"2019-06-03T04:00:00.000Z","updated":"2019-06-27T12:27:21.150Z","comments":true,"path":"P2678 跳石头/","link":"","permalink":"http://yao-lirong.github.io/P2678%20%E8%B7%B3%E7%9F%B3%E5%A4%B4/","excerpt":"题目来源：洛谷P2678 跳石头 这是一道标准的 “最大值最小”或“最小值最大“ 的题，遇到这种题，我们就可以使用 贪心+二分查找 的方法来做 二分答案/二分查找有序（单调）的，有界的就可以用二分法查找。","text":"题目来源：洛谷P2678 跳石头 这是一道标准的 “最大值最小”或“最小值最大“ 的题，遇到这种题，我们就可以使用 贪心+二分查找 的方法来做 二分答案/二分查找有序（单调）的，有界的就可以用二分法查找。 有界：对于本题，我们可以发现，这个所谓的最短跳跃距离显然不能超过一个范围（跳一次从头跳到尾）。也就是说，答案是有一个确定的范围限制的（开头到结尾的距离内），我们就可以考虑一种另外的方法去解决——枚举答案，并去验证答案是否可行，这实际上是一种倒推 二分：那么如何确保我们可以最快的找到答案呢？二分是最好选择 单调：二分的前提条件是什么？是答案区间是整体有序的。我们只考虑合法解，并称之为可行解。考虑所有可行解，我们肯定是要从这些可行解中找到一个最好的作为我们的答案， 这个答案我们称之为最优解。最优解一定可行，但可行解不一定最优。 我们假设整个序列具有单调性，且一个数x为可行解，那么一般的，所有的x’(x’&lt;x)都是可行解。 并且，如果有一个数y是非法解，那么一般的，所有的y’(y’&gt;y)都是非法解。 总结来说，可以使用二分查找的条件：解的上下界确定(l=0,r=L),可以写出判断条件(f(x)&lt;=m),解具有区间单调性(在某个值之前条件都成立，之后都不成立) 本题和 P2855 River Hopscotch 是同一道题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int rocks[50003],ending,num,removed,result;void finding(int,int);int main()&#123; cin&gt;&gt;ending&gt;&gt;num&gt;&gt;removed; for(int i=1;i&lt;=num;i++) cin&gt;&gt;rocks[i]; rocks[0]=0; rocks[num+1]=ending; sort(rocks+1,rocks+num+1); finding(0,ending); cout&lt;&lt;result; return 0;&#125;void finding(int m, int n)&#123; int mid=(m+n)/2, removing=0; int now=0,pointer=0;///now 表示我们现在所在的位置，pointer 表示下一个可以跳到的位置 while(pointer&lt;num)&#123;///人家这个方法直接一步子迈过去了，根本不需要记录哪个石头被拿掉了，或者判定一个原本有石头的地方被没被拿掉，毕竟题目本身就叫跳石头，为什么要一个个石头看呢，直接跳不就好了 pointer++; if(rocks[pointer]-rocks[now]&lt;mid)///我们认为mid是最短跳跃距离，如果有某种情况使得跳跃距离比这个最短的还短，我们就需要拿走这块石头来增大这个地方的跳跃距离，使其大于最短跳跃距离 removing++; else//如果比最短距离长的话，我们就可以跳过去 now=pointer; &#125; if(m&lt;=n)&#123; ///这个地方我写 m&lt;n 或者 m&lt;=n 有区别吗？我的m到最后的时候只能通过mid+1这一种方式更新，+1又不影响/2以后mid的值，所以这两个判定不是一样的吗？ ///确实判定的时候没什么区别，最后都会更新到m=4 n=4 mid=4，但是 m&lt;n 运行到 m=4 n=4 mid=4 会发现 m!&lt;n 所以不会更新 result if(removing&gt;removed) finding(m,mid-1); ///如果我们以mid为最小距离的情况下移动的石块比我们本应该移动的石块多的话，说明这个答案是不合法的，并且所有大于mid的都不合法（越大于mid移动的石块只会越来越多），所以减少 最小移动距离 使得我们不要移动那么多石块 else if(removing&lt;=removed) &#123; result=mid; finding(mid+1,n);&#125; ///如果以mid为最小距离的情况下移动的石块比我们本应该移动的石块多的话，说明这个答案合法，但是因为我们要寻找最大的最小值，所以增大 最小距离 看看有没有更优的解 &#125;&#125;/*25 5 2 2111417 21*/ 二分查找模板非递归形式的二分查找模板 123456789101112int l=1,r=ll;/// 1 是答案的最小值，ll是答案的最大值 while(l&lt;=r) &#123; ///当左右边界重合的时候就是答案，退出循环 int mid=(l+r)&gt;&gt;1,q=check(mid);//“&gt;&gt;1”相当于“/2” if(check) ///当该距离满足条件的时候 &#123; ///去寻找右半部分，看看还有没有符合条件的更大的值 ll=mid+1;///ll上mid右边，找右半部分 ans=mid;///记录答案（更新中） &#125; else l=mid+1;///若这个值不满足，就找左部分&#125; 下面是一个二分查找的样例 P1824 Aggressive Cows12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int stall[100005],cow_num,stall_num,ans;void finding(int,int);int main()&#123; cin&gt;&gt;stall_num&gt;&gt;cow_num; for(int i=1;i&lt;=stall_num;i++) cin&gt;&gt;stall[i]; sort(stall+1,stall+stall_num+1); finding(1,stall[stall_num]); cout&lt;&lt;ans; return 0;&#125;void finding(int m, int n)//看到一个符合要求的就填进去，最后看填进去的cow和一共有的是多是少&#123; int mid=(m+n)/2,now=1,pointer=1,cow_mid=1;///cow_mid 从1开始，如果从0开始实际上算的是间距，n+1才是牛的数量 while(pointer&lt;stall_num)&#123; pointer++; if(stall[pointer]-stall[now]&gt;=mid)&#123;///这里注意是 &gt;= 只要比最短的距离(mid)大，我们就可以放一头奶牛在这里 cow_mid++; now=pointer;&#125; &#125; if(m&lt;=n)&#123; if(cow_mid&gt;=cow_num) &#123;ans=mid; finding(mid+1,n);&#125; ///如果这次放的比我们需要放的多，说明我们的最短间距太小了，所以要增大最短间距 else finding(m,mid-1); &#125;&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"http://yao-lirong.github.io/tags/NOI/"}]},{"title":"P1090 合并果子","slug":"P1090 合并果子","date":"2019-05-30T04:00:00.000Z","updated":"2019-06-27T12:31:58.850Z","comments":true,"path":"P1090 合并果子/","link":"","permalink":"http://yao-lirong.github.io/P1090%20%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90/","excerpt":"题目来源： 洛谷P1090 合并果子 一维数组做法本题是一个简单的 Huffman树。Huffman编码 在 UTF-8 &amp; Unicode 中都有它思想的体现，即出现频率高的编码长度短，出现频率低的编码长度长，用以缩短整体编码长度 这里我也运用了前面 P1309 的思想：因为每次需要重新排序的时候只有一个数据需要被插入整个数列当中,所以并不需要假定数据无序的 quick sort，反而是线性的排序更快","text":"题目来源： 洛谷P1090 合并果子 一维数组做法本题是一个简单的 Huffman树。Huffman编码 在 UTF-8 &amp; Unicode 中都有它思想的体现，即出现频率高的编码长度短，出现频率低的编码长度长，用以缩短整体编码长度 这里我也运用了前面 P1309 的思想：因为每次需要重新排序的时候只有一个数据需要被插入整个数列当中,所以并不需要假定数据无序的 quick sort，反而是线性的排序更快 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n,berry[10005];long long ans=0; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;berry[i]; sort(berry+1,berry+1+n); for(int i=1;i&lt;=n-1;i++)&#123; berry[i+1]=berry[i]+berry[i+1];///计算每个果堆的重量 ans+=berry[i+1];///答案是每次搬的果堆的重量之和 if(berry[i+1]&gt;berry[i+2])&#123;///解决前两个数之和大于第三/四个数的情况（比如有 1 1 1 1）最优解为4而不是7 for(int j=i+1;j&lt;=n-1;j++)&#123; if(berry[j]&gt;berry[j+1]) swap(berry[j],berry[j+1]);///线性排序 &#125; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; 归并做法 据说是离散化算法 就是先把原本的从小到大排序排好。然后用两个队列，一个是存储原本的，另一个是存储合成的（由于原本的是从小到大所有新开的也是从小到大）。然后在两个队列的头取最小的，执行两次然后把这两个合并加入第二个队列中。 然后由于输入： (1≤ai≤20000)(1≤ai≤20000)(1≤ai≤20000) ，所以用桶排序就可以 O(n)O(n)O(n) 时间复杂度 要义是储存原本果堆的a1是按顺序排列的，所以存储两两合成的新果堆的a2也是按顺序排列的。取这两个果堆序列中最小的两个果堆，必定获得这一步能获得的最小的果堆。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int k,x,num,n1,n2,a1[30001],a2[30001],t[20001],w,sum;int main()&#123; scanf(&quot;%d&quot;,&amp;num); memset(a1,127/3,sizeof(a1)); memset(a2,127/3,sizeof(a2)); for (int i=1;i&lt;=num;i++) &#123; scanf(&quot;%d&quot;,&amp;x); t[x]++;//桶 &#125; for (int i=1;i&lt;=20000;i++) &#123; while (t[i])//通排序 &#123; t[i]--; a1[++n1]=i; &#125; &#125; int i=1,j=1; k=1; while (k&lt;num) &#123; if (a1[i]&lt;a2[j])//取最小值 &#123; w=a1[i]; i++; &#125; else &#123; w=a2[j]; j++; &#125; if (a1[i]&lt;a2[j])//取第二次 &#123; w+=a1[i]; i++; &#125; else &#123; w+=a2[j]; j++; &#125; a2[++n2]=w;//加入第二个队列 k++;//计算合并次数 sum+=w;//计算价值 &#125; printf(&quot;%d&quot;,sum);&#125; 二叉（小根）堆s 代表 son, p 代表 parent, size 代表整个二叉堆中存储的数据数量 完美二叉树, 完全二叉树和完满二叉树的区分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=10000+10;int n,heap[maxn],size=0;void up(int p) //二叉小根堆向上调整（子节点小于父节点就调整）&#123; while(p&gt;1) &#123; if(heap[p]&lt;heap[p/2]) &#123; swap(heap[p],heap[p/2]); p/=2; &#125; else break; &#125;&#125;void insert(int val) //二叉堆插入，新元素放在堆底，向上调整&#123; heap[++size]=val; up(size);&#125;void down(int p) //二叉小根堆向下调整&#123; int s=p*2; while(s&lt;=size) &#123; //下面这句话是从左右儿子中选一个更小的做交换 if(s&lt;size&amp;&amp;heap[s+1]&lt;heap[s]) s++; if(heap[s]&lt;heap[p]) &#123; swap(heap[s],heap[p]); p=s; s=p*2; &#125; else break; &#125;&#125;void extract() //二叉堆删除堆顶&#123; heap[1]=heap[size--]; //将堆底移至堆顶，向下调整 down(1);&#125;int gettop() //返回堆顶的值&#123; return heap[1];&#125;int main()&#123; cin&gt;&gt;n; for(int i=1; i&lt;=n; i++) &#123; int a; cin&gt;&gt;a; insert(a); //建立二叉堆 &#125; long long ans=0; //其实这里不会越界，但好像原题数据是3万 while(size&gt;=2) //如果还可合并 &#123; int top1=gettop(); //取出堆顶（堆中最小值）后删除堆顶 extract(); int top2=gettop(); //同上 extract(); ans+=(top1+top2); insert(top1+top2); //将两数之和加入二叉堆，重复运算 &#125; cout&lt;&lt;ans&lt;&lt;endl; //输出答案 return 0;&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"http://yao-lirong.github.io/tags/NOI/"}]},{"title":"P1309 瑞士轮","slug":"P1309 瑞士轮","date":"2019-05-30T04:00:00.000Z","updated":"2019-06-27T12:26:55.045Z","comments":true,"path":"P1309 瑞士轮/","link":"","permalink":"http://yao-lirong.github.io/P1309%20%E7%91%9E%E5%A3%AB%E8%BD%AE/","excerpt":"题目来源：洛谷P1309 瑞士轮 胜者组和败者组分别是有序的，使用 mergesort 将两个有序同向数组进行归并（严格上来说不是归并排序），大大降低了时间复杂度 = O(n)。如果我们使用 quicksort，则默认整个数据是无序的，对每个数据都重新排序所以会超时","text":"题目来源：洛谷P1309 瑞士轮 胜者组和败者组分别是有序的，使用 mergesort 将两个有序同向数组进行归并（严格上来说不是归并排序），大大降低了时间复杂度 = O(n)。如果我们使用 quicksort，则默认整个数据是无序的，对每个数据都重新排序所以会超时 一种可以替代结构体的方法：排名的时候我们可以只对每个选手的序号进行排序，这样做既可以保证我们有各个人的排序，又可以保证他们的成绩和实力得到记录（序号对应着成绩和实力，在对序号根据实力排序的同时，每个序号对应的成绩和实力的顺序是不变的） sort 函数中 cmp 的使用方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int num,round,inquiry,score[200005],power[200005],No[200005],winner[100005],loser[100005];///其中，No里每个下标代表选手的排名，power &amp; score 的下标代表选手的序号bool cmp(int, int);void mergesort();void compete();int main()&#123; cin&gt;&gt;num&gt;&gt;round&gt;&gt;inquiry; for(int i=1;i&lt;=2*num;i++) cin&gt;&gt;score[i]; for(int i=1;i&lt;=2*num;i++) cin&gt;&gt;power[i]; for(int i=1;i&lt;=2*num;i++) No[i]=i; //for(int i=1;i&lt;=2*num;i++) cout&lt;&lt;No[i]&lt;&lt;&quot; &quot;&lt;&lt;score[i]&lt;&lt;endl; sort(No+1,No+1+2*num,cmp); //for(int i=1;i&lt;=2*num;i++) cout&lt;&lt;No[i]&lt;&lt;&quot; &quot;&lt;&lt;score[i]&lt;&lt;endl; for(int i=1;i&lt;=round;i++) &#123; compete(); mergesort(); &#125; cout&lt;&lt;No[inquiry]; //while(true); return 0;&#125;bool cmp(int m, int n)&#123; ///cmp函数使用范例 if(score[m]==score[n]) return m&lt;n; else return score[m]&gt;score[n];&#125;void compete()&#123; for(int i=1;i&lt;=2*num;i=i+2) &#123; if(power[No[i]]&gt;power[No[i+1]]) &#123; score[No[i]]++; winner[i/2+1]=No[i]; loser[i/2+1]=No[i+1]; &#125; else if(power[No[i]]&lt;power[No[i+1]]) &#123; score[No[i+1]]++; winner[i/2+1]=No[i+1]; loser[i/2+1]=No[i]; &#125; &#125; /*cout&lt;&lt;&quot;compete&quot;&lt;&lt;endl; for(int i=1;i&lt;=num;i++) cout&lt;&lt;winner[i]&lt;&lt;&quot; &quot;&lt;&lt;loser[i]&lt;&lt;endl; cout&lt;&lt;endl;*/&#125;void mergesort()&#123; int i=1,j=1; while(i&lt;=num &amp;&amp; j&lt;=num) &#123; //if(score[winner[i]]&gt;score[loser[j]]) if(cmp(winner[i],loser[j])) ///完全无法理解这个地方只写一个cmp是怎么过的，难道不会有位于后面的相等score项实际比前面的相等score项序号更小这种情况吗 &#123; No[i+j-1]=winner[i]; i++; &#125; //else if(score[loser[j]]&gt;score[winner[i]]) else &#123; No[i+j-1]=loser[j]; j++; &#125; /*else if(score[loser[j]]==score[winner[i]]) &#123; int k=0,temp[200005]; while(score[winner[i]]==score[winner[i+1]]) temp[++k]=winner[i++]; while(score[loser[j]]==score[loser[j]]) temp[++k]=loser[j++]; sort(temp,temp+k); for(int a=1;a&lt;=k;a++) No[a+i+j-1]=temp[a]; &#125;*/ &#125; while(i&lt;=num) &#123; No[i+num]=winner[i]; i++; &#125; while(j&lt;=num) &#123; No[j+num]=loser[j]; j++; &#125; /*cout&lt;&lt;&quot;mergesort&quot;; for(int i=1;i&lt;=num*2;i++) cout&lt;&lt;No[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl;*/&#125;/*2 4 17 6 6 710 5 20 15*/","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"http://yao-lirong.github.io/tags/NOI/"}]},{"title":"Introduction to Git Command","slug":"Intro-to-Git-Command","date":"2019-02-10T05:00:00.000Z","updated":"2021-08-31T00:22:57.002Z","comments":true,"path":"Intro-to-Git-Command/","link":"","permalink":"http://yao-lirong.github.io/Intro-to-Git-Command/","excerpt":"Creating repository git init: create a repository git add File_Name: add “File_Name” to repository git add . : add all files git commit -m &quot;message&quot;: commit changes and tell others what changes have been made","text":"Creating repository git init: create a repository git add File_Name: add “File_Name” to repository git add . : add all files git commit -m &quot;message&quot;: commit changes and tell others what changes have been made Way-back Machine git status: tell you which files have been changed git diff: check what content exactly has been changed in each file Time Travelling commitID: git uses commit ID, a hex number calculated by SHA1 to record your commit history HEAD: HEAD is the current version, HEAD^ is the previous, HEAD^^ is the one before the previous, HEAD~100 is the last 100. git log: check the commit history git reflog: check the command history git reset --hard CommitID : Going back to the “Commit ID” version (e.g. git reset --hard HEAD^ : going back to the previous version) When you go back, the “future version” will no longer appear in “git log“. However, you can use “git reflog“ to trace “commit ID” from the future Undo Changes messed up with working directory: use git checkout -- File_Name to discard changes in working directory and make “File_Name” to go back to the latest “committed” or “added” version messed up with working directory but don’t want to delete all the changes: git stash saves your local modifications away and reverts the working directory to match the HEAD commit. messed up with working directory and added it to stage: use git reset HEAD File_Name to discard changes in stage but keep “File_Name” in working directory changed, therefore going back to situation 1 committed the mess to master branch: use the Time Traveling technique in the previous section Deleting FilesIf you want to delete files that are already committed to the master branch: delete the file in working directory: rm File_Name delete the file from git / restore the file delete the file from git: git rm File_Name &amp; git commit restore the file: git checkout -- File_Name Managing BranchCreating and Deleting Branch 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; Solving Conflicts","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"http://yao-lirong.github.io/tags/Logistics/"},{"name":"Git","slug":"Git","permalink":"http://yao-lirong.github.io/tags/Git/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-02-09T05:00:00.000Z","updated":"2020-08-04T09:29:47.857Z","comments":true,"path":"hello-world/","link":"","permalink":"http://yao-lirong.github.io/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Real Start实际上你应该使用 npx hexo &lt;command&gt; 来运行 hexo.","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yao-lirong.github.io/tags/Hexo/"}]}],"categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"http://yao-lirong.github.io/tags/Logistics/"},{"name":"Linux","slug":"Linux","permalink":"http://yao-lirong.github.io/tags/Linux/"},{"name":"Reading","slug":"Reading","permalink":"http://yao-lirong.github.io/tags/Reading/"},{"name":"20FA","slug":"20FA","permalink":"http://yao-lirong.github.io/tags/20FA/"},{"name":"Tsinghua","slug":"Tsinghua","permalink":"http://yao-lirong.github.io/tags/Tsinghua/"},{"name":"Cornell","slug":"Cornell","permalink":"http://yao-lirong.github.io/tags/Cornell/"},{"name":"C++","slug":"C","permalink":"http://yao-lirong.github.io/tags/C/"},{"name":"Python","slug":"Python","permalink":"http://yao-lirong.github.io/tags/Python/"},{"name":"Latex","slug":"Latex","permalink":"http://yao-lirong.github.io/tags/Latex/"},{"name":"CS4820","slug":"CS4820","permalink":"http://yao-lirong.github.io/tags/CS4820/"},{"name":"CS2024","slug":"CS2024","permalink":"http://yao-lirong.github.io/tags/CS2024/"},{"name":"CS4320","slug":"CS4320","permalink":"http://yao-lirong.github.io/tags/CS4320/"},{"name":"网络日志","slug":"网络日志","permalink":"http://yao-lirong.github.io/tags/%E7%BD%91%E7%BB%9C%E6%97%A5%E5%BF%97/"},{"name":"20SP","slug":"20SP","permalink":"http://yao-lirong.github.io/tags/20SP/"},{"name":"CS3110","slug":"CS3110","permalink":"http://yao-lirong.github.io/tags/CS3110/"},{"name":"CS2043","slug":"CS2043","permalink":"http://yao-lirong.github.io/tags/CS2043/"},{"name":"19FA","slug":"19FA","permalink":"http://yao-lirong.github.io/tags/19FA/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yao-lirong.github.io/tags/Hexo/"},{"name":"CS2112","slug":"CS2112","permalink":"http://yao-lirong.github.io/tags/CS2112/"},{"name":"Android","slug":"Android","permalink":"http://yao-lirong.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://yao-lirong.github.io/tags/Java/"},{"name":"NOI","slug":"NOI","permalink":"http://yao-lirong.github.io/tags/NOI/"},{"name":"Git","slug":"Git","permalink":"http://yao-lirong.github.io/tags/Git/"}]}