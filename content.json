{"meta":{"title":"Harmonyano's Blog","subtitle":null,"description":null,"author":"Harmonyano","url":"https://harmonyano.github.io","root":"/"},"pages":[{"title":"è‚¥è‚ æŠ±æ­‰ï¼Œå‡ºé”™äº†","date":"2019-06-27T14:43:00.207Z","updated":"2019-06-27T14:43:00.178Z","comments":true,"path":"404.html","permalink":"https://harmonyano.github.io/404.html","excerpt":"","text":""},{"title":"Hello, World","date":"2019-06-27T04:00:00.000Z","updated":"2020-10-19T15:57:12.971Z","comments":true,"path":"about/index.html","permalink":"https://harmonyano.github.io/about/index.html","excerpt":"","text":"æ²¡äººä¼šçœ‹çš„ä¸œè¥¿ï¼Œéšä¾¿ä»‹ç»ä¸‹ twitter ID åé¢è·Ÿçš„ emoji æ˜¯ä»€ä¹ˆå§ ğŸ¬ï¼šç™½æµ·è±šï¼Œç»„é•¿ï¼Œå¸¦æˆ‘çœŸæ­£å…¥å‘vtuberçš„å¥³äººï¼ˆé›»è„³å°‘å¥³ã‚·ãƒ­@SIROyoutuber ï¼‰ ğŸ¥•ï¼šä¸¤ä¸ªå–œæ¬¢ä¸­å›½çš„çŒ´å§¬ï¼ˆç”°ä¸­ãƒ’ãƒ¡@HimeTanaka_HH &amp; éˆ´æœ¨ãƒ’ãƒŠ@HinaSuzuki_HHï¼‰ ğŸ€*ï¼š vtuberå¼€åˆ›è€…ä¹‹ä¸€ï¼Œæ¿€åŠ±äººå¿ƒçš„è™šæ‹Ÿæ¢¦æƒ³å®ˆæŠ¤è€…ï¼ˆã®ã‚‰ãã‚ƒã£ã¨@VR_Girl_NoraCatï¼‰ ğŸ±ï¼šæˆäºèµ„æœ¬ï¼Œè´¥äºèµ„æœ¬ã€‚æ€€å¿µæˆ‘çš„æ‚é±¼åè¾ˆã€‚ï¼ˆã‚¢ã‚ºãƒãƒªãƒ @azuma_limï¼‰ ğŸŒ½ï¼šhololiveå°‘ä¸»ï¼Œä»…å‡­ä¸€äººä¹‹åŠ›æ‹¯æ•‘äº†ä¸€ä¸ªå…¬å¸çš„å¥³äººï¼Œè¿›å†›ä¸­å›½çš„å…ˆé”‹å†›ï¼ˆç™½ä¸Šãƒ•ãƒ–ã‚­@shirakamifubukiï¼‰ ğŸ‡ï¼šå½©è™¹ç¤¾çš„å”¯ä¸€æ¸…æ¥šï¼Œè¶…å¯çˆ±çš„çˆ±ä¸½ä¸(16/2)ï¼ˆç‰©è¿°æœ‰æ –@AliceMononobeï¼‰ æ³¨ï¼šæ ‡æœ‰*çš„ä»£è¡¨ç”±äºæœ¬äººæœªå®šä¹‰ç‰¹æœ‰emojiï¼Œæˆ–æœ¬äººå®šä¹‰çš„emojiè¿‡é•¿ï¼Œæ‰€ç”¨emojiéå®˜æ–¹æ‰¿è®¤çš„emojiè¡¨è¾¾æ–¹å¼ï¼Œè€Œæ˜¯åŸºäºè§’è‰²æ€§æ ¼äºŒæ¬¡åˆ›ä½œå¾—æ¥ 2019-11-23 æ›´æ–°ï¼šæ¢“ç’ƒå¤¢ç°å·²æ¢å¤æ´»åŠ¨ï¼›æ’¤ä¸‹äº†Aliceçš„ ğŸ‡ï¼Œä½†å› å®˜æ–¹æ ‡å¿—ï¼ˆâ™¥ â™  â™¦ â™£ ï¼‰å¤ªé•¿ä¸”æ¸²æŸ“æ•ˆæœä¸å¥½ï¼Œæ‰€ä»¥çˆ±ä¸½ä¸ä»æˆ‘çš„twitter handleä¸­æ¶ˆå¤±äº†ï¼ˆä¸ºäº†ç¾è§‚è€Œä¸æŠŠè‡ªå·±æ¨çš„äººåŠ åˆ°handleä¸Šçš„å±‘ï¼‰ 2020-10-09 æ›´æ–°ï¼šç™½ä¸Šå¹é›ªä¸ºäº†ç»´ç³»æ¸©æš–å¤§å®¶åº­ï¼Œä¸æƒœçˆ†ç ´äº†è‡ªå·±åœ¨ä¸­å›½çš„100ä¸‡ç²‰ä¸ï¼Œå¥¹è¿˜æ˜¯é‚£ä¸ªè¿ç­¹å¸·å¹„çš„ç‹ç‹¸ï¼Œä½†æ˜¯æˆ‘ä»¬å·²ç»ä¸æ˜¯å¥¹è¿½æ±‚çš„å¯¹è±¡äº†ï¼Œè¿™é‡Œæ˜¯é»„æ˜ï¼Œè€Œè¥¿æ–¹æœ‰åˆšåˆšå‡èµ·çš„å¤ªé˜³ï¼Œæ’¤ä¸‹äº†å¥¹çš„ğŸŒ½ã€‚"},{"title":"Hello, World","date":"2019-06-27T04:00:00.000Z","updated":"2020-10-19T15:57:12.971Z","comments":true,"path":"index.html","permalink":"https://harmonyano.github.io/index.html","excerpt":"","text":"æ²¡äººä¼šçœ‹çš„ä¸œè¥¿ï¼Œéšä¾¿ä»‹ç»ä¸‹ twitter ID åé¢è·Ÿçš„ emoji æ˜¯ä»€ä¹ˆå§ ğŸ¬ï¼šç™½æµ·è±šï¼Œç»„é•¿ï¼Œå¸¦æˆ‘çœŸæ­£å…¥å‘vtuberçš„å¥³äººï¼ˆé›»è„³å°‘å¥³ã‚·ãƒ­@SIROyoutuber ï¼‰ ğŸ¥•ï¼šä¸¤ä¸ªå–œæ¬¢ä¸­å›½çš„çŒ´å§¬ï¼ˆç”°ä¸­ãƒ’ãƒ¡@HimeTanaka_HH &amp; éˆ´æœ¨ãƒ’ãƒŠ@HinaSuzuki_HHï¼‰ ğŸ€*ï¼š vtuberå¼€åˆ›è€…ä¹‹ä¸€ï¼Œæ¿€åŠ±äººå¿ƒçš„è™šæ‹Ÿæ¢¦æƒ³å®ˆæŠ¤è€…ï¼ˆã®ã‚‰ãã‚ƒã£ã¨@VR_Girl_NoraCatï¼‰ ğŸ±ï¼šæˆäºèµ„æœ¬ï¼Œè´¥äºèµ„æœ¬ã€‚æ€€å¿µæˆ‘çš„æ‚é±¼åè¾ˆã€‚ï¼ˆã‚¢ã‚ºãƒãƒªãƒ @azuma_limï¼‰ ğŸŒ½ï¼šhololiveå°‘ä¸»ï¼Œä»…å‡­ä¸€äººä¹‹åŠ›æ‹¯æ•‘äº†ä¸€ä¸ªå…¬å¸çš„å¥³äººï¼Œè¿›å†›ä¸­å›½çš„å…ˆé”‹å†›ï¼ˆç™½ä¸Šãƒ•ãƒ–ã‚­@shirakamifubukiï¼‰ ğŸ‡ï¼šå½©è™¹ç¤¾çš„å”¯ä¸€æ¸…æ¥šï¼Œè¶…å¯çˆ±çš„çˆ±ä¸½ä¸(16/2)ï¼ˆç‰©è¿°æœ‰æ –@AliceMononobeï¼‰ æ³¨ï¼šæ ‡æœ‰*çš„ä»£è¡¨ç”±äºæœ¬äººæœªå®šä¹‰ç‰¹æœ‰emojiï¼Œæˆ–æœ¬äººå®šä¹‰çš„emojiè¿‡é•¿ï¼Œæ‰€ç”¨emojiéå®˜æ–¹æ‰¿è®¤çš„emojiè¡¨è¾¾æ–¹å¼ï¼Œè€Œæ˜¯åŸºäºè§’è‰²æ€§æ ¼äºŒæ¬¡åˆ›ä½œå¾—æ¥ 2019-11-23 æ›´æ–°ï¼šæ¢“ç’ƒå¤¢ç°å·²æ¢å¤æ´»åŠ¨ï¼›æ’¤ä¸‹äº†Aliceçš„ ğŸ‡ï¼Œä½†å› å®˜æ–¹æ ‡å¿—ï¼ˆâ™¥ â™  â™¦ â™£ ï¼‰å¤ªé•¿ä¸”æ¸²æŸ“æ•ˆæœä¸å¥½ï¼Œæ‰€ä»¥çˆ±ä¸½ä¸ä»æˆ‘çš„twitter handleä¸­æ¶ˆå¤±äº†ï¼ˆä¸ºäº†ç¾è§‚è€Œä¸æŠŠè‡ªå·±æ¨çš„äººåŠ åˆ°handleä¸Šçš„å±‘ï¼‰ 2020-10-09 æ›´æ–°ï¼šç™½ä¸Šå¹é›ªä¸ºäº†ç»´ç³»æ¸©æš–å¤§å®¶åº­ï¼Œä¸æƒœçˆ†ç ´äº†è‡ªå·±åœ¨ä¸­å›½çš„100ä¸‡ç²‰ä¸ï¼Œå¥¹è¿˜æ˜¯é‚£ä¸ªè¿ç­¹å¸·å¹„çš„ç‹ç‹¸ï¼Œä½†æ˜¯æˆ‘ä»¬å·²ç»ä¸æ˜¯å¥¹è¿½æ±‚çš„å¯¹è±¡äº†ï¼Œè¿™é‡Œæ˜¯é»„æ˜ï¼Œè€Œè¥¿æ–¹æœ‰åˆšåˆšå‡èµ·çš„å¤ªé˜³ï¼Œæ’¤ä¸‹äº†å¥¹çš„ğŸŒ½ã€‚"}],"posts":[{"title":"Intro to SQL","slug":"2021-09-16-Intro-to-SQL","date":"2021-09-16T04:00:00.000Z","updated":"2021-09-17T15:10:07.116Z","comments":true,"path":"2021-09-16-Intro-to-SQL/","link":"","permalink":"https://harmonyano.github.io/2021-09-16-Intro-to-SQL/","excerpt":"æäº¤å®ä¹ ç”³è¯·åå‘æ¥ä¸ªå°æµ‹éªŒï¼Œç»™æˆ‘åšå´©æºƒäº†ï¼Œç¬¬ä¸€ä¸ªè¦æˆ‘åšè¿™ç§çº§åˆ«çš„SQLï¼Œæˆ‘æœ€å¤šä¹Ÿå°±ä¼šä¸ª select from whereï¼Œè¶…çº²è¿‡äºä¸¥é‡ï¼Œåªèƒ½å›å¤´è¡¥ä¹ ","text":"æäº¤å®ä¹ ç”³è¯·åå‘æ¥ä¸ªå°æµ‹éªŒï¼Œç»™æˆ‘åšå´©æºƒäº†ï¼Œç¬¬ä¸€ä¸ªè¦æˆ‘åšè¿™ç§çº§åˆ«çš„SQLï¼Œæˆ‘æœ€å¤šä¹Ÿå°±ä¼šä¸ª select from whereï¼Œè¶…çº²è¿‡äºä¸¥é‡ï¼Œåªèƒ½å›å¤´è¡¥ä¹  Data Type åç§° ç±»å‹ è¯´æ˜ INT æ•´å‹ 4å­—èŠ‚æ•´æ•°ç±»å‹ï¼ŒèŒƒå›´çº¦+/-21äº¿ BIGINT é•¿æ•´å‹ 8å­—èŠ‚æ•´æ•°ç±»å‹ï¼ŒèŒƒå›´çº¦+/-922äº¿äº¿ REAL æµ®ç‚¹å‹ 4å­—èŠ‚æµ®ç‚¹æ•°ï¼ŒèŒƒå›´çº¦+/-1038 DOUBLE æµ®ç‚¹å‹ 8å­—èŠ‚æµ®ç‚¹æ•°ï¼ŒèŒƒå›´çº¦+/-10308 DECIMAL(M,N) é«˜ç²¾åº¦å°æ•° ç”±ç”¨æˆ·æŒ‡å®šç²¾åº¦çš„å°æ•°ï¼Œä¾‹å¦‚ï¼ŒDECIMAL(20,10)è¡¨ç¤ºä¸€å…±20ä½ï¼Œå…¶ä¸­å°æ•°10ä½ï¼Œé€šå¸¸ç”¨äºè´¢åŠ¡è®¡ç®— CHAR(N) å®šé•¿å­—ç¬¦ä¸² å­˜å‚¨æŒ‡å®šé•¿åº¦çš„å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ï¼ŒCHAR(100)æ€»æ˜¯å­˜å‚¨100ä¸ªå­—ç¬¦çš„å­—ç¬¦ä¸² VARCHAR(N) å˜é•¿å­—ç¬¦ä¸² å­˜å‚¨å¯å˜é•¿åº¦çš„å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ï¼ŒVARCHAR(100)å¯ä»¥å­˜å‚¨0~100ä¸ªå­—ç¬¦çš„å­—ç¬¦ä¸² BOOLEAN å¸ƒå°”ç±»å‹ å­˜å‚¨Trueæˆ–è€…False DATE æ—¥æœŸç±»å‹ å­˜å‚¨æ—¥æœŸï¼Œä¾‹å¦‚ï¼Œ2018-06-22 TIME æ—¶é—´ç±»å‹ å­˜å‚¨æ—¶é—´ï¼Œä¾‹å¦‚ï¼Œ12:20:59 DATETIME æ—¥æœŸå’Œæ—¶é—´ç±»å‹ å­˜å‚¨æ—¥æœŸ+æ—¶é—´ï¼Œä¾‹å¦‚ï¼Œ2018-06-22 12:20:59 Table StructureForeign KeyA foreign key is a field (or collection of fields) in one table, that refers to the primary key in another table. The foreign key constraint prevents invalid data from being inserted into the foreign key column, because it has to be one of the values contained in the parent table. 1234ALTER TABLE students ADD CONSTRAINT fk_class_id -- name the constraintFOREIGN KEY (class_id) -- use class_id column in students as FKREFERENCES classes (id); -- links to id in table classes Deleting the constraint wonâ€™t delete the column used as FK. 12ALTER TABLE studentsDROP FOREIGN KEY fk_class_id; IndexingWe can index frequently accessed columns to speed up querying. Indexes are based on hash, so the more spread out the data in index columns are, the better indexing performs. ç´¢å¼•çš„æ•ˆç‡å–å†³äºç´¢å¼•åˆ—çš„å€¼æ˜¯å¦æ•£åˆ—ï¼Œå³è¯¥åˆ—çš„å€¼å¦‚æœè¶Šäº’ä¸ç›¸åŒï¼Œé‚£ä¹ˆç´¢å¼•æ•ˆç‡è¶Šé«˜ã€‚åè¿‡æ¥ï¼Œå¦‚æœè®°å½•çš„åˆ—å­˜åœ¨å¤§é‡ç›¸åŒçš„å€¼ï¼Œä¾‹å¦‚genderåˆ—ï¼Œå¤§çº¦ä¸€åŠçš„è®°å½•å€¼æ˜¯Mï¼Œå¦ä¸€åŠæ˜¯Fï¼Œå› æ­¤ï¼Œå¯¹è¯¥åˆ—åˆ›å»ºç´¢å¼•å°±æ²¡æœ‰æ„ä¹‰ã€‚ 12345ALTER TABLE studentsADD INDEX idx_score (score); -- indexing named as idx_score; it indexes column score ALTER TABLE studentsADD INDEX idx_name_score (name, score); -- create a two-column indexing of name and score UniqueAdd a UNIQUE constraint to make sure the uniqueness of studentâ€™s name (Assume no two students have the same name). 12ALTER TABLE studentsADD CONSTRAINT uni_name UNIQUE (name); Queryingæ³¨æ„å­—ç¬¦ä¸²ç”¨çš„éƒ½æ˜¯å•å¼•å· &#39; &#39;. Conditionals =: equal &lt;&gt;: not equal LIKE: similar, % is wildcard. &#39;ab%&#39; matches &#39;ab&#39;ï¼Œ&#39;abc&#39;ï¼Œ&#39;abcd&#39; 12345678-- sometimes we don&#x27;t need FROM-- this is usually used to test connection to data baseSELECT 1SELECT 100 + 200SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender = &#x27;M&#x27;;SELECT * FROM students WHERE (NOT class_id &lt;&gt; 2) AND score LIKE &#x27;8%&#x27; ; Projections12-- rename column score as pointsSELECT id, score points, name FROM students; OrdersQuery results are usually ordered by PK. If we want to change the order, we can 1234567891011-- order by score (default in ascending order æ­£åº)SELECT id, name, score FROM students ORDER BY score;-- order by score and gender (descending score and ascending id)SELECT id, name, score FROM students ORDER BY score DESC, id;-- together with WHERESELECT id, name, gender, scoreFROM studentsWHERE class_id = 1ORDER BY score DESC; Partial ResultsQuery result is sometimes in huge amount. In this case, we only want to show part of the result. 1234567-- show only 3 resultSELECT id, name, gender, score FROM students ORDER BY score DESCLIMIT 3;-- show only 3 result, starting from the 7th.SELECT id, name, gender, score FROM students ORDER BY score DESCLIMIT 3 OFFSET 6; Groups12345-- return #records in TABLE students, and name it numSELECT COUNT(*) num FROM students;-- return #records whose gender is &#x27;M&#x27;, and name the result &quot;boys&quot;SELECT COUNT(*) boys FROM students WHERE gender = &#x27;M&#x27;; å’Œ COUNT ç±»ä¼¼çš„è¿˜æœ‰ä»¥ä¸‹å‡½æ•°ï¼š å‡½æ•° è¯´æ˜ SUM è®¡ç®—æŸä¸€åˆ—çš„åˆè®¡å€¼ï¼Œè¯¥åˆ—å¿…é¡»ä¸ºæ•°å€¼ç±»å‹ AVG è®¡ç®—æŸä¸€åˆ—çš„å¹³å‡å€¼ï¼Œè¯¥åˆ—å¿…é¡»ä¸ºæ•°å€¼ç±»å‹ MAX è®¡ç®—æŸä¸€åˆ—çš„æœ€å¤§å€¼ï¼Œå¦‚æœæ˜¯å­—ç¬¦ä¸²ç±»å‹åˆ™è¿”å›æ’åºæœ€åçš„å­—ç¬¦ MIN è®¡ç®—æŸä¸€åˆ—çš„æœ€å°å€¼ï¼Œå¦‚æœæ˜¯å­—ç¬¦ä¸²ç±»å‹åˆ™è¿”å›æ’åºæœ€å‰çš„å­—ç¬¦ å…¶ä¸­ï¼Œå¦‚æœ WHERE æ¡ä»¶æ²¡æœ‰åŒ¹é…åˆ°ä»»ä½•è¡Œï¼ŒCOUNT()ä¼šè¿”å›0ï¼Œè€ŒSUM()ã€AVG()ã€MAX()å’ŒMIN()ä¼šè¿”å›NULLã€‚ 12345678910-- æŒ‰ç…§ class_id åˆ†ç»„(class_id=1, 2, 3, ... å„ä¸€ç»„)ï¼Œ åˆ†åˆ«è¿”å›æ¯ä¸€ç»„çš„æ€»è®°å½•æ•°SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;-- å¯¹äºåƒ name è¿™ç§åœ¨ä¸€ä¸ªç»„å†…å¹¶ä¸æ˜¯ç›¸åŒçš„å€¼ï¼Œä¼šè¿”å› NULL / æŠ¥é”™-- å› æ­¤å¯¹äºèšåˆæŸ¥è¯¢ï¼Œæˆ‘ä»¬åªèƒ½æ”¾å…¥èšåˆæŸ¥è¯¢çš„ col åæˆ–è€…ä¸€äº›å…¶ä»–çš„èšåˆå‡½æ•°SELECT name, class_id, COUNT(*) num FROM students GROUP BY class_id;-- æŸ¥è¯¢æ¯ä¸ªç­çº§ç”·å¥³åˆ†åˆ«çš„å¹³å‡åˆ†SELECT class_id, gender, AVG(score) FROM students GROUP BY gender, class_id ORDER BY class_id, gender; Multiple TablesWhen you select from more than one table, database will return the Cartesian product of the results. 12345SELECT s.id sid, s.name, s.gender, s.score, c.id cid, c.name cnameFROM students s, classes cWHERE s.gender = &#x27;M&#x27; AND c.id = 1; JoinView12345create view current_demographic_dim(current_demographic_key, current_salary_range, current_age_range)asselect demographic_key, salary_range, age_rangefrom SAMPLES.DEMOGRAPHIC_DIM;","categories":[],"tags":[]},{"title":"Introduction to C","slug":"2021-08-31-Introduction-to-C","date":"2021-08-31T04:00:00.000Z","updated":"2021-09-16T01:47:09.234Z","comments":true,"path":"2021-08-31-Introduction-to-C/","link":"","permalink":"https://harmonyano.github.io/2021-08-31-Introduction-to-C/","excerpt":"","text":"Compiling C Program ```bashcompile hello.c and name the executable as default (a.out)gcc hello.ccompile hello.c and name the output executable â€œsayhelloâ€gcc hello.c -o sayhello1234567891011121314151617181920- We usually write `return 0`, this exit code 0 means `EXIT_SUCCESS`.- | Prototype | Definition || ------------------------------------------------------------ | ------------------------------------------------------------ || prototype - declare a function (write down its name) | definition - define a function (write down its content) || `.h` stand for &quot;header&quot; and it contains prototype of function | `.c` stand for &quot;code&quot; and it contains definition of function |## Complex &amp; Custom Data Types### struct```Cstruct rect_t &#123; int left; ... &#125;; struct rect_t myRect; typedefThe keyword typedef allows a programmer to create a new type. 12struct _rect_t &#123; ... &#125;;typedef struct _rect_t rect_t; Now we can create instance of the new type: (Note how this is different from a struct instance declaration) 123rect_t myRect;myRect.left = 1;... Dynamic Memory AllocationConsider the following program: 1234int * initArray(int howLarge) &#123; int myArray[howLarge]; for (int i = 0; i &lt; howLarge; i++) myArray[i] = i; return myArray; &#125; We cannot do this because the space allocated to myArray is only inside the scope of initArray and will be freed once we exit this function. So what we want is dynamic memory allocation so the memory will be allocated at a dynamic heap instead of the call stack. 123int *p = malloc(6 * sizeof(int)); // memory allocationp = realloc(p, 12 * sizeof(int)); // re-allocationfree(p); We can then rewrite the above function as: 1234int * initArray(int howLarge) &#123; int *myArray = malloc(howLarge * sizeof(int)); for (int i = 0; i &lt; howLarge; i++) myArray[i] = i; return myArray; &#125; Note the following when you use free: 12345678// you cannot free something on the stackint x = 3; int *p = &amp;x;free(p); // early termination// free can only be used to free address returned by mallocint *p = malloc(4*sizeof(int));p++;free(p); // early termination Debugging C in VSCode Install the extension â€œGDB Debugger - Beyondâ€ Replace whatâ€™s in launch.json - configurations with the following codes: 123456789&quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;by-gdb&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Launch(gdb)&quot;, &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;, &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot; &#125;]","categories":[],"tags":[]},{"title":"æ›´æ–°archerä¸»é¢˜ / è¿ç§»Hexoåšå®¢","slug":"2021-08-29-æ›´æ–°archerä¸»é¢˜--è¿ç§»Hexoåšå®¢","date":"2021-08-29T04:00:00.000Z","updated":"2021-08-31T21:56:08.304Z","comments":true,"path":"2021-08-29-æ›´æ–°archerä¸»é¢˜--è¿ç§»Hexoåšå®¢/","link":"","permalink":"https://harmonyano.github.io/2021-08-29-%E6%9B%B4%E6%96%B0archer%E4%B8%BB%E9%A2%98--%E8%BF%81%E7%A7%BBHexo%E5%8D%9A%E5%AE%A2/","excerpt":"é‡è¦æ–‡ä»¶ä¸å¤šï¼Œå…¨åœ¨ä¸‹é¢åˆ—å‡ºæ¥äº†ï¼Œè®°å¾—æŠŠå®ƒä»¬è¿ç§»å¥½å°±è¡Œ","text":"é‡è¦æ–‡ä»¶ä¸å¤šï¼Œå…¨åœ¨ä¸‹é¢åˆ—å‡ºæ¥äº†ï¼Œè®°å¾—æŠŠå®ƒä»¬è¿ç§»å¥½å°±è¡Œ 123456789101112. # ã€ŒHexo æ ¹ç›®å½•ã€â”œâ”€â”€ source # åšå®¢æºæ–‡ä»¶â”œâ”€â”€ themesâ”‚ â””â”€â”€ archer # ã€ŒArcher ä¸»é¢˜ç›®å½•ã€â”‚ â”œâ”€â”€ source # æ¸²æŸ“ç”¨æºæ–‡ä»¶â”‚ â”œâ”€â”€ assetsâ”‚ â””â”€â”€ favicon.ico # ç½‘ç«™ç¼©ç•¥å›¾æ ‡â”‚ â”œâ”€â”€ avatar # æ˜¾ç¤ºäººç‰©å¤´åƒâ”‚ â”œâ”€â”€ intro # ç½‘é¡µå¤´å›¾â”‚ â””â”€â”€ _config.yml # Archer ä¸»é¢˜é…ç½®æ–‡ä»¶â”‚â””â”€â”€ _config.yml # Hexo é…ç½®æ–‡ä»¶ å¦å¤–åˆ«å¿˜è®°æ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼Œå®‰è£…å¿…è¦æ’ä»¶ 123npm install hexo-generator-json-content --savenpm install hexo-wordcount --savenpm install hexo-generator-feed --save å› ä¸ºæ±‚èŒå­£æˆ‘æŠŠ å…³äºé¡µ æ¨ç‰¹ å‰¯æ ‡é¢˜ è¿˜æœ‰åº·ç±³çš„å¤´å›¾ å…¨æ¢ä¸‹æ¥äº†ï¼Œæ‰¾å®Œå·¥ä½œäº†å†æ”¾ä¸Šå»","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"https://harmonyano.github.io/tags/Logistics/"}]},{"title":"Install and Configure Aria2 on WSL","slug":"2021-06-28-Install-and-Configure-Aria2-on-Linux","date":"2021-06-28T04:00:00.000Z","updated":"2021-08-29T20:52:58.670Z","comments":true,"path":"2021-06-28-Install-and-Configure-Aria2-on-Linux/","link":"","permalink":"https://harmonyano.github.io/2021-06-28-Install-and-Configure-Aria2-on-Linux/","excerpt":"","text":"Tutorial Install Aria2c: sudo apt install aria2c and a web-based GUI: AriaNg Create configuration files: 123mkdir ~/.aria2touch ~/.aria2/aria2.session #ç”¨äºä¿å­˜æ—¥å¿—touch ~/.aria2/aria2.conf #åˆ›å»ºé…ç½®æ–‡ä»¶ A template for â€œaria2.confâ€ can be downloaded from aria2c.com. You should change the dir field to be download path, change input-file and save-session to be the path of aria2.session. aria2.conf doesnâ€™t support environment variable, so everything is at best written in absolute path. Run Aria2c with this configuration: aria2c --conf-path=/home/&lt;username&gt;/.aria2/aria2.conf. It will remember this as its configuration file and use it to start the service from now on. We can also add argument -D so Aria2c runs as daemon in the background. (Since the aria2câ€™s default configure file path is in ~/.aria2/, we donâ€™t really need the --conf-path argument; but use it to specify a conf path if you put it somewhere else) è®¾ç½® aria2c å¼€æœºè‡ªåŠ¨å¯åŠ¨ï¼šç¼–å†™è„šæœ¬ myStartUp.sh å¹¶æ”¾å…¥ /etc/init.d/. (Remember to change its privilege to everyone) 12345#!/bin/bash#Short-Description: My Startup Servicesaria2c -D --conf-path=/home/&lt;username&gt;/.aria2/aria2.conf More on Start Service on WSL startup, refer to this answer CautionOn WSL, when you start aria2 service the first time, note: (full command means the above command with --conf-path, but since our conf path is the same as default path, we can take ) use the full command aria2c --conf-path=/home/&lt;username&gt;/.aria2/aria2.conf and donâ€™t start it in the background with -D. start it immediately after Windows is booted, before you open anything else or tweak anything Anything else than this full command or use this full command some time after Windows boot could cause problem. The problem is showing â€œException: [SocketCore.cc:312] errorCode=1 Failed to bind a socket, cause: Permission deniedâ€ even though no process is using port 6800. The reason for this problem is not clear. After staring aria2 once with the full command, we can shut it down and then start it in the background with aria2c -D --conf-path=/home/&lt;username&gt;/.config/aria2/aria2.conf. Now everything will work fine. Reference Linuxä¸­é…ç½®Aria2 RPC Server linuxè®¾ç½®å¼€æœºè‡ªå¯åŠ¨ WSL æœåŠ¡è‡ªåŠ¨å¯åŠ¨çš„æ­£ç¡®æ–¹æ³•","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"https://harmonyano.github.io/tags/Logistics/"},{"name":"Linux","slug":"Linux","permalink":"https://harmonyano.github.io/tags/Linux/"}]},{"title":"On Intelligence","slug":"2021-06-23-On-Intelligence","date":"2021-06-23T04:00:00.000Z","updated":"2021-08-29T20:52:51.031Z","comments":true,"path":"2021-06-23-On-Intelligence/","link":"","permalink":"https://harmonyano.github.io/2021-06-23-On-Intelligence/","excerpt":"Complexity is a symptom of confusion, not a cause.","text":"Complexity is a symptom of confusion, not a cause. 1 Artificial Intelligence è®¡ç®—æœºå­¦ç•Œçš„ä¸»æµè§‚ç‚¹ï¼šä¸éœ€è¦å­¦ä¹ å¤§è„‘ æ­¤è§‚ç‚¹çš„èµ·å§‹ï¼šTuring Testï¼Œå³è®©äººä»¬è®¤ä¸ºå®ƒæ˜¯æ™ºèƒ½ï¼Œäº§ç”Ÿ intelligent behavior æ›´é‡è¦ the Chinese Room: åœ¨ä¸­æ–‡å±‹ä¸­æ™ºèƒ½æ²¡æœ‰äº§ç”Ÿï¼Œä½œè€…è®¤ä¸º Understanding cannot be measured by external behavior; it is instead an internal metric of how the brain remembers things and uses its memories to make predictions. ä½†ç»å¤§å¤šæ•°çš„æ‰€è°“â€AIâ€å’Œè¿™é‡Œçš„ä¸­æ–‡å±‹å’Œè¿™ä¸€å®šä¹‰æ— ä»»ä½•ç›¸ä¼¼ä¹‹å¤„ 2 Neural Networksä¸€äº›å¯èƒ½å·²ç»è¿‡æ—¶çš„è§‚ç‚¹ï¼š Neural Network æ²¡æœ‰è€ƒè™‘ feedback å’Œ time changing inputs Cognitive Scientist è™½ç„¶æƒ³è®°å½•å¤§è„‘ä¸­çš„ feedbackï¼Œä½†æ˜¯è¿«äºç°æœ‰æŠ€æœ¯(fMRI)åªèƒ½è®°å½•è„‘å†…æ´»åŠ¨çš„ä½ç½®ï¼Œæ— æ³•è®°å½•è¿ç»­çš„å˜åŒ– 3 The Human Brain Mind is the creation of the cells in the brain. The cortex is extremely flexible and that the inputs to the brain are just patterns. It doesnâ€™t matter where the patterns come from; as long as they correlate over time in consistent ways, the brain can make sense of them. Function Hierarchy: è„‘çš„æ¯ä¸ªåŠŸèƒ½éƒ¨åˆ†éƒ½è¢«åˆ’ä¸º hierarchyï¼Œä»¥è¾“å…¥çš„è§†è§‰ä¸ºä¾‹ V1 (primary sensory areas): rawest, most basic level V2, V4, IT: concerned with more specialized or more abstract aspects association area: receive inputs from more than one sense è™½ç„¶æ˜¯ä¸€ä¸ª hierarchyï¼Œä½†æ˜¯å®é™…ä¸Šå½“æˆ‘ä»¬ä»ä½å±‚èµ°å‘é«˜å±‚çš„è¿‡ç¨‹ä¸­ï¼Œinformation always flows in the opposite direction as well, and with more projections feeding back down the hierarchy than up. Uniformity of Cortex Parts: Mountcastle found that parts of cortex performing different function is very similar in appearance and structure. From there, he argues that all regions of the cortex are performing the same operation. The thing that makes the vision area visual and the motor area motoric is how the regions of cortex are connected to each other and to other parts of the central nervous system. Plasticity of Cortex: æˆ‘ä»¬å‘ç°å¦‚æœå¤§è„‘æŸä¸ªéƒ¨åˆ†æŸåï¼Œå¦ä¸€ä¸ªéƒ¨åˆ†å¯ä»¥æ¥ç®¡å®ƒåŸå…ˆçš„äººç‰©ï¼Œè¿™ä½è¯äº† Mountcastle çš„è§‚ç‚¹ã€‚å¦æœ‰ä¸€ä¸ª Thought Experimentï¼šå‡è®¾æˆ‘ä»¬çš„å¤§è„‘å¹¶ä¸å…·æœ‰å¦‚æ­¤çš„å¯å¡‘æ€§ï¼Œé‚£ä¹ˆè¿™å°±æ„å‘³ç€æˆ‘ä»¬çš„æŸä¸ªå¤§è„‘éƒ¨ä½æ˜¯ä¸“é—¨ç”¨æ¥å­¦ä¹ ä¸­æ–‡æ±‰å­—çš„ï¼Œä½†æ˜¯å¯¹äºç”Ÿç‰©è¿›åŒ–æ¥è¯´ï¼Œæ±‰å­—è¿›åŒ–åœ°å¤ªå¿«äº†ï¼Œå¤§è„‘æ ¹æœ¬ä¸å¯èƒ½é€‚åº”åœ°è¿™ä¹ˆå¿«ï¼ˆæˆ–è€…å¤–å›½äººä¹Ÿå¯ä»¥è¿…é€Ÿå­¦ä¸­æ–‡äº¦èƒ½ä½è¯è¿™ä¸€è§‚ç‚¹ï¼‰ Similarity of Inputs into Brain: ä¸ç®¡è§†è§‰å¬è§‰è¿˜æ˜¯ä»€ä¹ˆè¾“å…¥ï¼ŒçœŸæ­£è¿›äº†äººä½“éƒ½æ˜¯ Action Potentials. They are all the same - just patterns. ä¹Ÿç”¨æ¥ä½è¯ Mountcastle çš„è§‚ç‚¹ã€‚There are spatial and and temporal patterns: Spatial Patterns: coincident patterns in time; they are created when multiple receptors in the same sense organ are stimulated simultaneously Temporal Patterns: patterns entering your sensory organs are constantly changing over time è¿›ä¸€æ­¥ç»™å‡ºäº†å…³äºä»¥ä¸Šä¸¤ç‚¹çš„ä¾‹å­ï¼šè®¤ä¸ºåŒæ—¶åšå‡ºååº”çš„å‡æ‰‹æ˜¯è‡ªå·±çš„æ‰‹ / é•œå¤´è¿èˆŒå¤´ä¸Šçš„å‹æ„Ÿæ¥æ”¶å™¨ï¼Œç”¨èˆŒå¤´çœ‹ä¸œè¥¿ 4 Memory é©³æ–¥äººè„‘æ¯”è®¡ç®—æœºæ›´å¿«ï¼Œè®¡ç®—åŠ›æ›´é«˜ -&gt; äººè„‘èƒ½åšåˆ°æ¯”è®¡ç®—æœºå¿«æ˜¯å› ä¸ºè¿è¡ŒåŸç†æ ¹æœ¬ä¸åŒ -&gt; å¼•å‡ºæœ¬ç« ä¸»æ—¨: the brain doesnâ€™t â€œcomputeâ€ the answers to problems; it retrieves the answers from memory. Four attributes of neocortical memory that are fundamentally different from computer memory: The neocortex stores sequences of patterns -&gt; predictions of future events The neocortex recalls patterns auto-associatively -&gt; recall memories appropriate for prediction The neocortex stores patterns in an invariant form -&gt; apply knowledge of past to new situations that are similar but not identical The neocortex stores patterns in a hierarchy. æ¥ä¸‹æ¥æˆ‘ä»¬å°†è¯¦ç»†ä»‹ç»å‰ä¸‰ä¸ªç‰¹å¾å¹¶åœ¨ç¬¬6ç« ä»‹ç»æœ€åä¸€ä¸ªç‰¹å¾ â€œé˜¶å±‚â€ Sequential Pattern: story is stored in your head in a sequential fashion and can only be recalled in the same sequence. You canâ€™t remember the entire story at once. ä¸€ä¸ªæœ‰è¶£çš„è§‚ç‚¹: Truly random thoughts donâ€™t exist. Memory recall almost always follows a pathway of association. Self-Associativity: The memory system can recall complete patterns when given only partial or distorted inputs. This is a result of Hebbian Learning: Firing together Wires together, so when only a part of the cell is activated, the whole group of cells will be activated. Invariant Representation: äººè„‘ä¸æ˜¯CDæˆ–ç¡¬ç›˜ï¼Œwe donâ€™t remember or recall things with complete fidelity. Instead, the brain remembers the important relationships in the world, independent of the details. æˆ‘ä»¬å¸¸ç”¨è§†è§‰æ¥ä¸¾ä¾‹å­ï¼šsome set of the cells in the face recognition area remain active as long as your friendâ€™s face is anywhere in your field of vision, regardless of its size, position, orientation, scale, and expression. This stability of cell firing is an invariant representation. å°å¼•å­å¯¼å…¥ä¸‹ä¸€ç« ï¼šä¸‹ä¸€ç« çš„ä¸»æ—¨æ˜¯äººè„‘çš„ä¸»è¦åŠŸèƒ½å°±æ˜¯ make predictions using memoriesï¼Œbut given that the cortex stores invariant information, how can it make specific predictions? It combines knowledge of the invariant structure with the most recent details. 5 A New Framework of Intelligence Prediction is not just one of the things your brain does. It is the primary function of the neocortex, and the foundation of intelligence. The cortex is an organ of prediction. è¿™æ˜¯ä½œè€…æœ¬ä¹¦ä¸­æœ€åŸºæœ¬çš„è§‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯ä»–æ‰€è¯´çš„æ–°çš„æ™ºèƒ½æ¡†æ¶ (Memory-Prediction Framework of Intelligence) ã€‚å…·ä½“åœ°æ¥è§£é‡Š Prediction è¿™ä¸ªæ¦‚å¿µï¼šYour brain makes low-level sensory predictions about what it expects to see, hear, and feel at every given moment, and it does so in parallel. All regions of your neocortex are simultaneously trying to predict what their next experience will be. â€œPredictionâ€ means that the neurons involved in sensing your door become active in advance of them actually receiving sensory input. When the sensory input does arrive, it is compared with what was expected. Correct predictions result in understanding. Incorrect predictions result in confusion and prompt you to pay attention. ä¸å±€é™äº sensory inputï¼Œmotor output åœ¨æˆ‘ä»¬çš„å¤§è„‘ä¸­ä¹Ÿæ˜¯å’Œ sensory inputä¸€æ ·çš„ pattern, so neocortex can also remembers what behavior (pattern) leads to what sensory input (patter) and we can direct behavior to satisfy its predictions. ä½œè€…ä¸¾äº†å¾ˆå¤šå…³äº prediction çš„ä¾‹å­ï¼ˆé¢„çŸ¥ä¹æ›²çš„æ—‹å¾‹ï¼Œæœ‹å‹çš„æ ·å­ï¼Œä½ å¦ˆä¸‹ä¸€å¥è¯ä¼šè¯´ä»€ä¹ˆâ€¦ï¼‰å…¶ä¸­æœ€æœ‰æ„æ€çš„ä¾‹å­åº”è¯¥æ˜¯ â€œfilling inâ€ï¼Œå³æˆ‘ä»¬åŸæ¥äº†è§£è¿‡çš„äººè„‘çš„ â€œè‡ªåŠ¨è¡¥å…¨â€ åŠŸèƒ½ï¼šäººçœ¼è™½ç„¶æœ‰ç›²ç‚¹ä½†æˆ‘ä»¬è§†è§‰æ²¡æœ‰ç›²ç‚¹ï¼Œè‡ªåŠ¨å°†ä¸‰ä¸ªè§’è¡¥å…¨æˆä¸‰è§’å½¢ï¼Œæç»˜å‡ºè¢«æ ‘é®æŒ¡çš„å¤§æ¥¼çš„æ ·å­ï¼Œç­‰ç­‰ã€‚Your visual cortex is drawing on memories of similar patterns and is making a continuous stream of predictions that fill in for any missing input. Behavior Cortex Intelligence ä¹‹é—´åˆ°åº•æ˜¯ä¸ªä»€ä¹ˆå…³ç³»ï¼Ÿ ä»è¿›åŒ–å†ç¨‹æ¥çœ‹ï¼Œcortex èµ·åˆ°ä»€ä¹ˆä½œç”¨ï¼Ÿæˆ‘ä»¬ä¸ºä»€ä¹ˆè¦è¿›åŒ–å‡º Cortex: in the beginning, the cortex served to make more efficient use of existing behaviors, not to create entirely new behaviors. ä½†æ˜¯åæ¥åœ¨è¿›åŒ–è¿‡ç¨‹ä¸­æœ‰äº† new behaviorï¼Ÿ Reptile: Keen senses and well-developed brains endowed them with complex behavior, but relatively rigid Mammals: Neocortex covering the old brain (reptile brain) Now sensory patterns are simultaneously fed into the neocortex and the old brain. The recalled memory is compared with the sensory input stream. It both â€œfills inâ€ the current input and predicts what will be seen next. Humans: large front part of cortex for high-level planning and thought, so it could store more sophisticated types of memories and make predictions based on complex relationships motor cortex makes more connections with our muscles so cortex usurps motor control from other parts of the brain (old brain) and now the cortex can direct behavior to satisfy its predictions. æœ¬éƒ¨åˆ†ä¹Ÿåé©³äº†ç¬¬ä¸€ç« ä¸­æ‰€è°“çš„äººå·¥æ™ºèƒ½å­¦è€…çš„ behavior determines intelligence è§‚ç‚¹ï¼šæ—©åœ¨ reptile æ—¶æœŸï¼ŒåŠ¨ç‰©å°±æœ‰äº†ç”Ÿå­˜æœ¬èƒ½çš„ behaviorï¼Œä½†æ˜¯ç›´åˆ° cortex å‡ºç°ï¼Œå®ƒä»¬æ‰æœ‰äº† intelligenceã€‚è€Œ cortex çš„æ ¸å¿ƒåŠŸèƒ½å°±æ˜¯ prediction. To make predictions of future events, your neocortex has to store sequences of patterns. To recall the appropriate memories, it has to retrieve patterns by their similarity to past patterns (auto-associative recall). And, finally, memories have to be stored in an invariant form so that the knowledge of past events can be applied to new situations that are similar but not identical to the past. How the physical cortex accomplishes these tasks, plus a fuller exploration of its hierarchy, is the subject of the next chapter. 6 How the Cortex Works invariant representation: Light receptors in retina concentrate in fovea and sparse out in periphery, so retinal image relayed onto V1 is highly distorted. However, we donâ€™t perceive any retinal pattern change at all. This is a result of invariant representation. In the course of spanning four cortical stages from retina to IT: cells in retina and V2 are rapidly changing, spatially specific, tiny-feature recognition cells. When we go to IT region, something magical happens and the cells become constantly firing, spatially nonspecific, object recognition cells. (They now fire when seeing a face, no matter itâ€™s on the left or on the right) Integrating the Senses: æˆ‘ä»¬åˆ°ç°åœ¨ä¸ºæ­¢éƒ½æ˜¯è®¨è®ºåŒä¸€ç±»å‹è¾“å…¥é¢„æµ‹åŒä¸€ç±»å‹ç»“æœï¼Œå®é™…ä¸Š association area ä½¿å¾—æˆ‘ä»¬ä¹Ÿå¯ä»¥é¢„æµ‹å…¶ä»–ç±»å‹çš„ç»“æœï¼Œæ¯”å¦‚è§†è§‰è¾“å…¥ç”¨æ¥é¢„æµ‹å¬è§‰ï¼Œå—…è§‰ç­‰ç­‰çš„ç»“æœï¼Œäº¦å¯ä»¥ç”¨æ¥æŒ‡å¯¼åŠ¨ä½œ A New View of V1: å‰æ–‡çš„æ¨¡å‹æœ‰ä¸¤ä¸ªé—®é¢˜ï¼šä»…å½“åˆ°äº† IT è¿™ä¸€å±‚æ—¶ï¼Œæˆ‘ä»¬å¥‡è¿¹èˆ¬åœ°è·å¾—äº† invariant representationï¼›å¤§è„‘ä¸­å¤§éƒ¨åˆ†åŒºåŸŸéƒ½æ˜¯åƒ association area ä¸€æ ·å¾—åˆ°å¤šä¸ªè¾“å…¥ï¼Œä½†æˆ‘ä»¬çš„æ¨¡å‹ä¸­å¥½åƒ V2 åªæœ‰ V1 ä¸€ä¸ªè¾“å…¥ï¼ŒV4 åªæœ‰ V2 ä¸€ä¸ªã€‚ To answer these questions, we propose a new model: V1, V2, V4 are not single cortical regions. Rather, each is a collection of many smaller subregions. V1 has largest number of little cortical areas. V2 has fewer, but larger subregions, each connecting to a number of V1â€™s subregions. Same for V4 and we have a single IT which has a birdâ€™s eye view of the entire visual world. Now the job of any cortical region is to find out how its inputs are related, to memorize the sequence of correlations between them, and to use this memory to predict how the inputs will behave in the future. We can say each region of cortex forms invariant representation drawn from the input areas hierarchically below it. A Model of the World: ä½œè€…è®¤ä¸ºä¸–ç•Œä¸­ Every object is composed of a collection of smaller objects, and most objects are part of larger objects. In an analogous way, memories are stored in the hierarchical structure of the cortex. Time really matters and information flowing into the brain arrives as a sequence of patterns. å¯¹äºæ¯ä¸ª cortical regionï¼Œå®ƒè¯†åˆ«å‡ºæ¥è¿™ä¸ª sequenceï¼Œå°†å…¶æŠ½è±¡æˆä¸€ä¸ª name - a constant pattern of cell firingï¼Œå¹¶å°†è¿™ä¸ªåå­—å‘ç»™ä»–çš„ä¸Šçº§ã€‚æ‰€ä»¥æˆ‘ä»¬ä¹Ÿå¯ä»¥è¯´å¤§è„‘å­˜å‚¨çš„æ˜¯ Sequence of Sequences. By collapsing predictable sequences into â€œnamed objectsâ€ at each region in our hierarchy, we achieve more and more stability the higher we go. This creates invariant representations. Sequences of Sequences: Two processes are at the essence of learning. Assume we are sorting out colored papers. bottom-up classification: deciding what color this paper is top-down sequence recognition: deciding which sequence are we reading in Notice these two processes help each other. 1. If you know the most likely sequence for this series of inputs, you will use this knowledge to decide how to classify the ambiguous input. 2. recognizing any sequence would be impossible if you hadnâ€™t first classified each piece of paper. When we have finally recognized a color sequence, say â€œred red blue greenâ€, we just pass this name to the next higher region; just like the colors to this region, the name is just a pattern to be combined with other inputs, classified, and then put into yet a higher-order sequence. The next higher up region doesnâ€™t have to know what it means. What a Region of Cortex Looks Like: æˆ‘ä»¬è¯´è¿‡æ¯ä¸ª cortical region æœ‰å…­å±‚ (six layers ä»ä¸Šåˆ°ä¸‹åˆ†åˆ«ä¸º L1, L2, â€¦, L6 ä¸è¦è·Ÿè§†è§‰çš„ V1 V4 ææ··) ä½†æˆ‘ä»¬ä¸€èˆ¬ä¸æŠŠæ¯ä¸€å±‚çœ‹åšäººè„‘çš„åŸºæœ¬å•ä½ï¼Œè€Œæ˜¯æŠŠ columns running perpendicular to the layer çœ‹åš basic unit of computation in the cortex. ä½œè€…è®¤ä¸ºå®ƒæ˜¯ basic unit of prediction. æˆ‘ä»¬æ¥ä¸‹æ¥è®¨è®º How cortical regions communicate with each other å…±æœ‰ä¸‰ç§æ–¹æ³•ï¼š Upward Flow: Converge inputs from lower regions goes to the input layer of the next region through axons Downward Flow: Axons in layer 1 spread over long distances, so information flowing down the hierarchy from one column has the potential to activate many columns in the regions below it. Lateral Flow: L1 ç»™ L4,5 å‘æŒ‡ä»¤è¿åŠ¨ï¼ŒL4,5 æ”¶åˆ°æŒ‡ä»¤çš„åŒæ—¶ï¼Œä¸ä»…å‘ä¸‹ç»™è‚Œè‚‰å‘æ”¾è¿åŠ¨ä¿¡å·ï¼Œä¹ŸæŠŠè¿™ä¸ªæ¶ˆæ¯å‘Šè¯‰ thalamusï¼Œthalamus è¿‡ä¸€ä¼šåä¼šæŠŠè¿™ä¸ªæ¶ˆæ¯é‡æ–°ä¼ å›ç»™ L1ã€‚å…¶ä¸­ thalamus æ”¶åˆ°æ¥è‡ªè®¸å¤šä¸åŒ L4, L5 çš„ä¿¡æ¯ï¼Œç„¶åå†æŠŠè¿™äº›ä¿¡æ¯ä¸€èµ·è¿”å›ç»™æ‰€æœ‰ L1 ï¼Œè¿™æ ·æœ¬ column å°±çŸ¥é“çŸ¥é“å‘¨å›´å…¶ä»–äººç°åœ¨æ”¶åˆ°çš„ä¿¡æ¯ã€‚Column not only knows the sequence name (downward flow from above), but also where we are within the sequence (activity from other columns) How a Region of Cortex Works - The Details: How does a cortical region classifies inputs? Itâ€™s too complicated, we assume it does How does it learn sequences of patterns? Input from lower region -&gt; layer 4 fires -&gt; layers 2,3,5 fire -&gt; layer 1 fires to tell the region up some input has come. Fire together Wire together, so 2,3,5,1 wire together. 2,3,5 now can fire without a layer 4 input, so they learn to â€œanticipateâ€ when they should fire based on firing of 1. Half of input to layer 1 comes from layer 5 in neighboring columns. This information represents what was happening moments before. It represents columns that were active prior to your column becoming active. The other half of the input to layer 1 comes from layer 6 cells in hierarchically higher regions. This information is more stationary. It represents the name of the sequence you are currently experiencing. Combining these two information, a prediction/sequence is formed. How does it form a constant â€œnameâ€ for a sequence? constant names = constant input to the next region during learned sequences = need to turn off the output of the layer 2 and layer 3 cells when a column predicts its activity, or, alternately, to make these cells active when the column canâ€™t predict its activity. Layer 2 cell represent the name of the sequence and they stay on when we are within the sequence. Layer 3b cell represents donâ€™t fire when our column successfully predicts its input but do fire when it doesnâ€™t predict its activity. How does it make specific predictions? If you expect a fifth (prediction / invariant representation) and hear a D (specific input). In layer 2 we fire all intervals of fifth. In layer 4 we fire all intervals starting with D. The intersection between the two is our specific prediction. Flowing Up and Flowing Down: ä¸Šå±‚ç»™ä¸‹å±‚ prediction å½“ä¸‹å±‚å¾—åˆ°çš„è¾“å…¥ä¸ prediction ä¸ç¬¦ (unexpected)ï¼Œæˆ‘ä»¬å°†æ­¤ç‰¹å¾ä¼ å¯¼ç»™æ›´ä¸Šä¸€å±‚ï¼Œç›´åˆ° some higher region can interpret it as part of its normal sequence of events. That higher region generates a new prediction and propagates it down Can Feedback Really Do that? Feedback synapses are all far away from cellâ€™s body, so itâ€™s doubted whether the feedback currents can really make a difference. ä½†æ˜¯æ–°ç ”ç©¶å‘ç°ç¦»å¾—è¿œçš„ synapse å¯èƒ½æœ‰å…¶ä»–ç‰¹æ®Šçš„æ•ˆæœï¼ˆå¹¶ä¸ç¡®åˆ‡è¯å®ï¼‰ How the Cortex Learns: æ¯”å¦‚æˆ‘ä»¬æœ‰1,2,3å±‚ï¼Œä¸€å¼€å§‹å•ä¸ªæ–‡å­—åœ¨ç¬¬3å±‚ï¼Œéšç€æˆ‘ä»¬æŒç»­å­¦ä¹ å’Œä¸æ–­ç»ƒä¹ å•ä¸ªæ–‡å­—ç§»åˆ°äº†ç¬¬2å±‚ï¼Œç›¸å¯¹çš„ï¼Œæˆ‘ä»¬åœ¨ç¬¬3å±‚ä¹ å¾—çŸ­è¯­è¿™ä¸ª patternã€‚This ensures that we free up the top for learning more subtle, more complex relationships. è¿™ä¹Ÿæ˜¯æˆ‘ä»¬å˜å¾—æ›´ç†Ÿç»ƒçš„åŸå› ã€‚ The Hippocampus: æˆ‘ä»¬å¸¸è®¤ä¸ºæµ·é©¬ä½“æ˜¯ç”Ÿæˆæ–°è®°å¿†çš„ä¸­å¿ƒï¼Œåœ¨ä½œè€…çš„æ¨¡å‹ä¸­ï¼ŒHippocampus is the top region of neocortex. æˆ‘ä»¬åˆšåˆšè¯´ unexpected input è¢«ä¼ è¾“ç»™ä¸Šå±‚ï¼Œso if something gets to the top of the cortical pyramid, it is the information that canâ€™t be understood by previous experience, the input that is truly new and unexpected. Thatâ€™s what stored in Hippocampus, but it wonâ€™t be stored forever. Itâ€™s either transferred down to the cortex (é•¿æœŸè®°å¿†) or eventually lost (é—å¿˜) æ‰€è°“äººåœ¨å£®ä¸­å¹´æ—¶å¯¹â€æ–°äº‹ç‰©â€çš„è®°å¿†æ²¡æœ‰é‚£ä¹ˆå¥½å®é™…ä¸Šæ˜¯å› ä¸ºè¿™äº›â€æ–°â€çš„ä¸œè¥¿å®é™…ä¸Šæ—©å·²åœ¨ä»¥å‰çš„ç”Ÿæ´»ä¸­å‡ºç°è¿‡ï¼Œæ‰€ä»¥äººå¯¹ç¬¬ä¸€æ¬¡è®°å¿†ç‰¹åˆ«æ·±åˆ»ï¼Œå¯¹ä¹‹åçš„ç±»ä¼¼äº‹ç‰©å°±æ²¡é‚£ä¹ˆå¥½è®°æ€§ã€‚ï¼ˆå®ƒç«Ÿç„¶å’Œ How the Cortex Learns è¿™å¾ˆæ‰¯çš„ä¸€èŠ‚è”èµ·æ¥äº†ï¼‰ An Alternative Path up the Hierarchy: è¿™é‡Œè¦ä»‹ç»çš„æ˜¯ä» Layer5 -&gt; thalamus çš„è·¯å¾„ã€‚è¿™æ¡è·¯å¾„å¯å¼€å¯å…³ï¼Œå®ƒè¦ä¹ˆè¢«ä¸Šå±‚æ¿€æ´»æ‰“å¼€ï¼Œè¦ä¹ˆè¢«ä¸‹å±‚çš„ unexpected input æ¿€æ´»ã€‚æˆ‘ä»¬è®¤ä¸ºè¿™æ¡è·¯å¾„ä»£è¡¨æ³¨æ„åŠ›ï¼Œä¸¤ç§å¼€å¯æ–¹å¼åˆ†åˆ«å¯¹åº”ä¸»åŠ¨å…³æ³¨(pay attention)ï¼Œä»¥åŠå› ä¸ºå¥‡æ€ªçš„ç°è±¡è€Œè¢«åŠ¨å…³æ³¨ (attention is caught) Closing Thoughts: åˆ†äº«äº†ä½œè€…ä»é›¶æƒ³ç»“æ„å†™ä»£ç æœ€åç«Ÿç„¶èƒ½è·‘çš„ä¾‹å­ï¼Œä½†æ˜¯ç›¸å¯¹çš„å¦‚æœåˆ«äººåªç»™ä½ çœ‹ä¸€å †ä»£ç ç»“æ„è§„åˆ’ï¼Œä½ å¯èƒ½ä¼šæ€€ç–‘è¿™ä¸œè¥¿åˆ°åº•èƒ½ä¸èƒ½è·‘ï¼Œç±»æ¯”åˆ°è„‘ç»“æ„ä¸­ï¼Œæ€€ç–‘çš„åŸå› æ˜¯ it is because our intuitive sense of the capacity of the cortex and the power of its hierarchical structure is inadequate. 7 Consciousness and Creativity Animals and Human Intelligence: Memory and Prediction are the core of â€œIntelligenceâ€ and they are used by all livings. There is just a continuum of methods and sophistication in how they do it. One-cell animal: They used DNA as the medium for memory. Individuals could not learn and adapt within their lifetimes. They could only pass on the DNA-based memory of the world to their offspring through their genes. Modifiable Nervous System: An individual could now learn about the structure of its world and adapt its behavior accordingly within its lifetime. But an individual still could not communicate this knowledge to its offspring other than by direct observation. Neocortex was also created at this time. Human Intelligence: It begins with the invention of language and the expansion of our large neocortex. The more important is language. We humans can learn a lot of the structure of the world within our lifetimes, and we can effectively communicate this to many other humans via language. What is Creativity? Recall that we make predictions by combining the invariant memory recall of what should happen next with the details pertaining to this moment in time. All cortical predictions are predictions by analogy. We are being creative when our memory-prediction system operates at a higher level of abstraction, when it makes uncommon predictions, using uncommon analogies. æ³¨æ„ GEB ä¸­ä¹Ÿæåˆ°è¯´ analogy æ˜¯æ™ºæ…§çš„æ ¸å¿ƒ What is Consciousness? æœ‰äººè®¤ä¸º consciousness/mind åœ¨èº«ä½“ä¹‹å¤–ï¼Œä½†æ˜¯å®é™…ä¸Šå®ƒå°±åœ¨è„‘ä¸­ã€‚Your thoughts, which are located in the brain, are physically separate from the body and the rest of the world. Mind is independent of body, but not of brain. 8 The Future of Intelligence Because I have been immersed in the neuroscience and computer fields for over two decades, perhaps my brain has built a high-level model of how technological and scientific change occurs, and that model predicts rapid progress. Now is the turning point. General Direction of Intelligent Machine: Our intelligent machine may have a set of senses that differ from a humanâ€™s. attachto these senses a hierarchical memory system that works on the same principles as the cortex. We will then have to train the memory system much as we teach children. Over repetitive training sessions, our intelligent machine will build a model of its world as seen through its senses. The intelligent machine must learn via observation of its world. Once our intelligent machine has created a model of its world, it can then see analogies to past experiences, make predictions of future events. è¿™ä¸ªæ™ºèƒ½æœºå™¨çš„æ•´ä½“è¿ä½œæ–¹æ³•å’Œå¤§è„‘ç›¸åŒï¼Œä½†æ˜¯å®ƒå¹¶ä¸éœ€è¦ä¸å¤§è„‘é•¿å¾—ç›¸ä¼¼æˆ–å¾—åˆ°å’Œå¤§è„‘ç›¸åŒçš„è¾“å…¥ï¼Œå®ƒåªéœ€è¦å¤åˆç»“æ„çš„ï¼Œèƒ½å¤Ÿç”¨æ¥ä½œâ€œé¢„æµ‹â€çš„è¾“å…¥å³å¯ã€‚What makes it intelligent is that it can understand and interact with its world via a hierarchical memory model and can think about its world in a way analogous to how you and I think about our world. Ethical Problems? No. The strongest applications of intelligent machines will be where the human intellect has difficulty, areas in which our senses are inadequate, or in activities we find boring. In general, these activities have little emotional content. In the following areas, Intelligent Machines will exceed we humans: Speed: Transistor switch is much faster than human brainâ€™s electrical signals. Capacity: we can add capacity to machineâ€™s mind by doing the followings (these are also what we do in DL/ML) Adding depth to the hierarchy will lead to deeper understanding: the ability to see higher-order patterns. Enlarging the capacity within regions will allow the machine to remember more details, or perceive with greater acuity. Adding new senses and sensory hierarchies permits the device to construct better models of the world Replicability: we humans learn knowledge and form our own model of the world rather slowly. However, an intelligent machine need not undergo this long learning curve, since chips and other storage can be replicated endlessly and the contents transferred easily. Sensory Systems: Input patterns to the machine donâ€™t have to be analogous to animal senses, or even to derive from the real world at all. In fact, the author suspects that out inability to tackle issue may be related to a mismatch between the human senses and the physical phenomena we want to understand. Intelligent machines can have custom senses moresensitive than our own, or senses that are distributed, or senses for very small phenomena. They might think in three, four, or more dimensions. Appendix: The Thousand Brain TheoryNotes from Microsoft Research - The Thousand Brains Theory by Jeff Hawkins Local Cortical CircuitInside a local cortical circuit, neurons are organized in layers. Most connections go vertically across the layers; limited connections go horizontally within layer. Recent find: all layers have a motor output. So itâ€™s always sensorimotor input, no pure sensory input. Vernon Mountcastle: neocortex is remarkably uniform in appearance and structure because they are actually performing the same basic intrinsic function. A cortical column is the unit of replication. If you understand one of it, you understand the whole brain. Layer 2,3 - object Layer 4 - main input layer Layer 6 - location relative to the object L6 sends information to L4, L4 processes these information with its own other input. Over time it forms a representation of what the object itself is in layer L2,3. On top of that, if we have multiple cortical involved (imagine multiple fingers touching the cup instead of only one), we can instantly build a mental image of the cup by the connections across cortical units happened in L2,3. This is like a voting mechanism where each finger has a guess of its feeling and they settle what the object really is by talking to each other. Building a Reference MapA reference map is the sense of relative location as we are touching the cup Contrast to the classical view, the vast majority of connections between cortical regions are not hieratical at all. Hypothesis: the grid cells in entorhinal cortex also exist in every cortical column of every neocortex region. They donâ€™t create reference frames for location but reference frames for the objects we interact (the cup). In the classical view, we have a hierarchy in our neocortex. The real structure is similar, ä½†æˆ‘ä»¬å¹¶ä¸æ˜¯ æ¯æŸ„ -&gt; æ¯èº« -&gt; æ•´ä¸ªæ¯å­ è¿™ç§çœŸæ­£çš„é˜¶æ¢¯å¼å»ºæ¨¡ï¼Œè€Œæ˜¯æ¯ä¸ªâ€œå±‚çº§â€éƒ½å½¢æˆä¸€ä¸ªè‡ªå·±çš„æ¯å­æ¨¡å‹ï¼Œè¿™äº›æ¨¡å‹å¹¶ä¸ç›¸åŒ. This model allows all models to â€œvoteâ€. Everyone tries to guess whatâ€™s going on.","categories":[],"tags":[{"name":"Reading","slug":"Reading","permalink":"https://harmonyano.github.io/tags/Reading/"}]},{"title":"Introduction to TensorFlow 1.x","slug":"2021-05-28-Introduction-to-TensorFlow-1.x","date":"2021-05-28T04:00:00.000Z","updated":"2021-09-04T22:15:58.360Z","comments":true,"path":"2021-05-28-Introduction-to-TensorFlow-1.x/","link":"","permalink":"https://harmonyano.github.io/2021-05-28-Introduction-to-TensorFlow-1.x/","excerpt":"æµ·å°”å®ä¹ æœŸé—´è®°å½•ä¸‹çš„ TensorFlow ç¬”è®°","text":"æµ·å°”å®ä¹ æœŸé—´è®°å½•ä¸‹çš„ TensorFlow ç¬”è®° Basic Notion Graph: often refers to Computation Graph, which describes how to compute the output Eager execution: evaluates operations immediately, without building graphs Enabling eager execution changes how TensorFlow operations behaveâ€”now they immediately evaluate and return their values to Python. tf.Tensorobjects reference concrete values instead of symbolic handles to nodes in a computational graph. Since there isnâ€™t a computational graph to build and run later in a session, itâ€™s easy to inspect results using print() or a debugger. Evaluating, printing, and checking tensor values does not break the flow for computing gradients. Operation: å›¾ä¸­çš„èŠ‚ç‚¹, takes Tensor object as input, and produces Tensor objects as output Tensor: multi-dimensional arrays with a uniform type (called dtype), åŒ…å«ä¸€ä¸ª n ç»´çš„æ•°ç»„æˆ–åˆ—è¡¨. ä¸€ä¸ªé™æ€ç±»å‹ rank, å’Œ ä¸€ä¸ª shape. It does not hold the values of that operationâ€™s output, but instead provides a means of computing those values. It is a symbolic handle of input/output of Operation. å›¾ä¸Šæ“ä½œé—´ä¼ é€’çš„æ•°æ®éƒ½æ˜¯ Tensor: A Tensor can be passed as an input to another Operation. This builds a dataflow connection between operations, which enables TensorFlow to execute an entire Graph that represents a large, multi-step computation. Session: launch the computation of a graph InteractiveSession: a better graph runner that allows you to compute each operation step by step instead of only giving out the final result, as in Session 12345678910# Build a dataflow graph.a = tf.constant([[1.0, 2.0], [3.0, 4.0]])b = tf.constant([[1.0, 1.0], [0.0, 1.0]])c = tf.matmul(a, b)# Construct a `Session` to execute the graph.sess = tf.compat.v1.Session()# Execute the graph and store the value that `e` represents in `result`.result = sess.run(e) a, b, c are Tensor here. c = tf.matmul(a, b) creates an Operation of type â€œMatMulâ€ (Matrix Multiplication) that takes tensors a and b as input, and produces c as output. Variable: represent shared, persistent state your program manipulates (parameters of the model) it is a tf.Tensor whose value can be changed by running ops on it Placeholder: a tensor whose value will later be fed. Operations on Tensors tf.reduce_xxx(t, axis=i): If we have a tensor t of dimension $d_1 \\times d_2 \\times â€¦ \\times d_n $, apply r = reduce_xxx(t, axis = i), Each entry along axis i will be collapsed into a single entry, so r will have dimension $d_1 \\times d_2 \\times â€¦ d_{i-1} \\times d_{i+1} â€¦ \\times d_n $: 1234567891011121314151617a=np.random.randint(1,10,(2,3,4))&#x27;&#x27;&#x27;2 arrays of dimension 3 X 4[[[8 5 7 1] [9 7 2 2] [7 7 4 6]] [[7 7 8 4] [7 4 3 6] [5 3 2 8]]]&#x27;&#x27;&#x27;sess = tf.Session()with sess.as_default(): r = (tf.reduce_sum(a, axis=1)).eval() # reduce along axis of length 3&#x27;&#x27;&#x27;[[24 19 13 9] [19 14 13 18]]&#x27;&#x27;&#x27; tf.reshape(t, list): Reorder all the elements in t so that we have a new dimension in r: $d_1â€™ = list[0], d_2â€™ = list[1], â€¦$ If we have $dâ€™_i = -1$ as one of the dimension, $d_iâ€™ = \\frac{d_1 \\times d_2 \\times â€¦ \\times d_n}{list[0] \\times list[1]\\timesâ€¦list[i-1]\\times list[i+1] â€¦ \\times list[n-1]} $, so 1r = tf.reshape(a, [-1,2,2]).eval() # r will havee shape (6, 2, 2) tf.concat([t1, t2, ...], axis = i): pile all the arrays along axis i. These arrays must have the same length along the other axis. In the result, only the length along axis i will increase, the length of other axis remain the same. tf.tile(t, [m1,m2,...]): multiple axis i with mi, so the result tensor dimension is $(d_1\\times m_1, d_2\\times m_2, â€¦)$ Debug with Tensorboard tf.summary: Follow the official guide tf.estimator: Specify model_dir when initializing your estimator. Everything about the trained model will be stored in this directory, including event files logging training process. Reference Utility Sometimes we encounter module &#39;tensorflow&#39; has no attribute ... because TensorFlow changed/refactored its function name. We can use this list to manually update all changed names or directly use this script.","categories":[],"tags":[]},{"title":"2021 ç½‘ç»œæ—¥å¿—","slug":"2021-03-26-2021-ç½‘ç»œæ—¥å¿—","date":"2021-03-26T04:00:00.000Z","updated":"2021-09-14T15:18:55.444Z","comments":true,"path":"2021-03-26-2021-ç½‘ç»œæ—¥å¿—/","link":"","permalink":"https://harmonyano.github.io/2021-03-26-2021-%E7%BD%91%E7%BB%9C%E6%97%A5%E5%BF%97/","excerpt":"","text":"VScodeæ ¹æ®ä¸åŒè¯­è¨€è®¾ç½®ä¸åŒtabä»£è¡¨çš„ç©ºæ ¼ä¸ªæ•° åœ¨LINUXç³»ç»Ÿä¸‹ä½¿ç”¨SSHç™»é™†ä¸Šè·¯ç”±å™¨: æ³¨æ„å¯ä»¥ä½¿ç”¨flagfoxçœ‹ä¸€çœ¼è·¯ç”±å™¨çš„IP addressåˆ°åº•æ˜¯ä»€ä¹ˆï¼Œusernameå°±æ˜¯ç™»é™†è·¯ç”±å™¨ä½¿ç”¨çš„ç”¨æˆ·åï¼Œå¦‚æœä¸¤ä¸ªéƒ½å¡«å†™æ­£ç¡®æ˜¯ä¸ä¼šå‡ºç° â€œport XX refused connectionâ€è¿™ç§æƒ…å†µçš„ 1ssh &lt;username&gt;@&lt;IP_address&gt; BTæœ¯è¯­çš„è§£é‡Š å¤§çœ¼ä»”æ—­, è½å°˜ä¹‹æœ¨, 423down Adobe å¤§ç¥ç ´è§£ç‰ˆ by vposy, å¤©æä¸‹è½½ PC è½¯ä»¶å†å²ç‰ˆæœ¬, apkdownload(æ¯” apkpure å…¨) ä¼Šæœ—PCè½¯ä»¶ç ´è§£, from èƒ¡èåœå‘¨ ç½‘ç«™æ¨è æ‰¹é‡åˆæˆbilibiliçš„m4sç¼“å­˜æ–‡ä»¶ä¸ºMP4æ ¼å¼ Pot+LAV+madVRé…ç½®æ•™ç¨‹: ä½¿ç”¨ Icaros æ˜¾ç¤ºå¤šç§è§†é¢‘æ–‡ä»¶ç¼©ç•¥å›¾ ç¦ç”¨Windows Terminalå¤šè¡Œç²˜è´´çš„è­¦å‘Š apt vs apt-get: ç®€å•æ¥è¯´ï¼Œaptæ˜¯æ›´æ–°çš„é›†åˆç‰ˆçš„apt-getï¼Œåº”è¯¥å°½é‡ä½¿ç”¨apt FFmpeg åˆå¹¶ flv: 12for f in *.flv; do echo &quot;file &#x27;$f&#x27;&quot; &gt;&gt; mylist.txt; doneffmpeg -f concat -i mylist.txt -c copy output.flv æ›´è¯¦ç»†çš„å®˜æ–¹æ–‡æ¡£åœ¨è¿™é‡Œã€‚å…·ä½“åœ°æ¥çœ‹ï¼Œæˆ‘ä»¬è¿™é‡Œç”¨çš„æ˜¯ concat demuxer, è¿™é¡¹åè®®æ”¯æŒä¸åŒçš„å®¹å™¨æ ¼å¼ï¼Œç”šè‡³æ˜¯æœ¬èº«ä¸æ”¯æŒ concat æ“ä½œçš„å®¹å™¨æ ¼å¼çš„åˆå¹¶ (å‚è€ƒ stackoverflow ç­”æ¡ˆ) FFmpegæŸ¥çœ‹åª’ä½“ä¿¡æ¯: ä½¿ç”¨ ffprobe ä¼˜ç§€çš„ä»˜è´¹æ–°é—»èµ„è®¯ï¼šFTä¸­æ–‡ç½‘ï¼Œè´¢æ–°ç½‘ï¼Œè´¢ç»ç½‘ï¼Œ èƒ½å¤„çš„æ—¥æœ¬æ–°é—»ï¼šæ—¥æœ¬ç»æµæ–°é—», æœæ—¥æ–°é—», åœ¨äº”ç§ä¸åŒç³»ç»Ÿä¸Šéƒ¨ç½²Rimeå¹¶åŒæ­¥ èµå¹ï½œé”¤å­æ‰‹æœºæœªå¿…æœ€å¥½ï¼Œä½†ä»–ä»¬çš„è®¾è®¡å¸ˆéƒ½å€¼å¾—è‡´æ•¬ ä¸ºæ—¥æ–‡æ–‡æ¡£æ·»åŠ æŒ¯ã‚Šä»®åçš„wordå® ç¦ç”¨Win10è‡ªåŠ¨æ›´æ–°:configure automatic updates æ¿å— CodeBlocks è¿è¡Œé—®é¢˜è§£å†³: ld.exe: cannot open output file â€¦ : Permission denied Disable Firefox Auto-Update: Go to about:policies to check flags that could be set. Create a policies.json, create a directory called distribution where the EXE is located, and place the json file there on Windows. åè®®æ··ä¹±çš„ USB-C Web Annotation Tools: diigo: è¶…äº†æœ€é«˜å®¹é‡äº† weava: æ­£åœ¨ç”¨ beanote: å¯ä»¥è¯•è¯•ï¼Œè®°å½•ä¿å­˜åœ¨æœ¬åœ°ï¼Œæ— äº‘ç«¯æœåŠ¡ additor, Hypothesis: é‡ç‚¹å¹¶ä¸åœ¨è‡ªå·±çš„æœåŠ¡ä¿å­˜ï¼Œè€Œæ˜¯åœ¨åä½œï¼Œæƒ³ç­‰ä»–ä»¬ä¸€é˜µå­çœ‹çœ‹å‘å±•æ•ˆæœï¼Œç»“æœæœ€è¿‘åˆç”¨äº†ä¸€æ¬¡è¿˜æ˜¯ä¸å¥½ç”¨","categories":[],"tags":[]},{"title":"Tsinghua DSA ä½œä¸šæ€»ç»“ (3)","slug":"2021-02-11-Tsinghua-DSA-ä½œä¸šæ€»ç»“-(3)","date":"2021-02-11T05:00:00.000Z","updated":"2021-02-10T19:55:00.443Z","comments":true,"path":"2021-02-11-Tsinghua-DSA-ä½œä¸šæ€»ç»“-(3)/","link":"","permalink":"https://harmonyano.github.io/2021-02-11-Tsinghua-DSA-%E4%BD%9C%E4%B8%9A%E6%80%BB%E7%BB%93-(3)/","excerpt":"CSTæ•°æ®ç»“æ„ï¼ˆ2020ç§‹ï¼‰PA3","text":"CSTæ•°æ®ç»“æ„ï¼ˆ2020ç§‹ï¼‰PA3 3.1 Not Foundç®—æ³•è¦æ‰¾äºŒè¿›åˆ¶å­—ç¬¦ä¸² A ä¸­æœ€çŸ­çš„æœªå‡ºç°è¿‡çš„å­ä¸² Bï¼Œæˆ‘ä»¬å…ˆè€ƒè™‘ä¸€ä¸ªæ¯”è¾ƒé•¿çš„å­ä¸²ï¼Œå…¶é•¿åº¦ä¸º 24ã€‚ æ³¨æ„åˆ° A çš„é•¿åº¦æœ€é•¿ä¸º 16777216 = 2^24ã€‚å› ä¸ºè¿˜è¦æå¤´å»å°¾ï¼Œæ‰€ä»¥ A ä¸­é•¿åº¦ä¸º 24 çš„å­ä¸²çš„æ€»æ•°å¿…å®šå°äº 2^24 ä¸ªï¼Œè€Œé•¿åº¦ä¸º 24 çš„å­—ç¬¦ä¸²æ€»å…±æœ‰ 2^24 ç§ï¼Œæ‰€ä»¥ A ä¸­å¿…å®šæœ‰æŸä¸ªé•¿åº¦ä¸º 24 çš„å­—ç¬¦ä¸²æ˜¯ä¸å­˜åœ¨çš„ã€‚ æˆ‘ä»¬ç”¨ bitmap è¾¹è¯»å…¥ï¼Œè¾¹è®°å½•ä¸‹æ‰€æœ‰å‡ºç°è¿‡çš„é•¿ä¸º 24 çš„å­ä¸²ã€‚è¿™ä¸ª bitmap åªå­˜é•¿åº¦ä¸º 24 çš„å­ä¸²ï¼Œæˆ‘ä»¬å«å®ƒ bitmap24ã€‚è¯»å…¥å®Œæˆåï¼Œæ³¨æ„åˆ°ä»»ä½•ä¸€ä¸ªåœ¨ A ä¸­å‡ºç°çš„é•¿ä¸º 23 çš„å­ä¸²å¿…å®šæ˜¯æŸä¸€ 24 å­ä¸²æå¤´æˆ–å»å°¾å¾—åˆ°çš„ï¼Œäºæ˜¯æˆ‘ä»¬éå†æ‰€æœ‰åœ¨ 24 å­ä¸²ï¼Œå¯¹ä»–ä»¬æå¤´å»å°¾ï¼Œå°†å¾—åˆ°çš„ä¸¤ä¸ªç»“æœå­˜å…¥ bitmap23 ä¸­ï¼Œå¦‚æ­¤åšç›´åˆ° bitmap1 å­˜å®Œã€‚ æœ€åæˆ‘ä»¬ä»é•¿åº¦ 24 å¼€å§‹éå†ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªé•¿åº¦ n ä½¿å¾—æ‰€æœ‰é•¿åº¦ä¸º n çš„å­ä¸²éƒ½åœ¨ A ä¸­å‡ºç°äº†ï¼Œé‚£ä¹ˆæ‰€è¦æ‰¾çš„â€œæœ€çŸ­æœªå‡ºç°å­ä¸²â€ B å¿…ç„¶æœ‰é•¿åº¦ n+1ï¼Œæˆ‘ä»¬åªéœ€è¦å†éå†ä¸€é bitmap(n+1) æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸å­˜åœ¨çš„å­—ç¬¦ä¸²å³å¯ ç»†èŠ‚ è¯»å…¥å­—ç¬¦ä¸²çš„æ—¶å€™å½“æ€»é•¿åº¦è¾¾åˆ° 24 ä»¥åï¼Œæˆ‘ä»¬å°±è¦è¯»ä¸€ä¸ªæ–°çš„å¼ƒä¸€ä¸ªæ—§çš„ï¼Œå› ä¸ºæ ¹æ®é¢˜ç›®åˆ†æ B æœ€é•¿ä¹Ÿå°±æ˜¯ 24 ä¸€ä¸ª int æ˜¯ 4 byte = 32 bit = 2^5 bitï¼Œæ‰€ä»¥ bitmap24 éœ€è¦ $2^{24}/2^5 = 2^{19}$ ä¸ª intï¼Œbitmap1 â€¦ bitmap 5 å„è‡ªä»…éœ€ 1ä¸ª int å› ä¸ºæˆ‘ä»¬æ˜¯å°†äºŒè¿›åˆ¶å­—ç¬¦ä¸²ç”¨ int æ–¹å¼å­˜åœ¨ bitmap ä¸­ï¼Œå¦‚æœè¿™ä¸ªå­—ç¬¦ä¸²æœ‰ leading 0s, å®ƒä»¬åœ¨è¾“å‡ºæ—¶ä¼šè¢«å¿½ç•¥æ‰ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦æ ¹æ® bitmap-n è¿™ä¸ªé•¿åº¦ n æ¥è¡¥å…¨ leading 0s ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;// int_size[i] is the number of ints needed to store all strings of length iconst int int_size[25] = &#123; 1, // there should be no bitmap for string of length 0, // but we give it 1 to make the whole program consistent 1, 1, 1, 1, 1, // 2^1 2^2 2^3 2^4 2^5 each only needs one int 2, 4, 8, 16, 32, // 2^6, ... 10 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288 &#125;;// ones[i] is 2^i - 1const int ones[25] = &#123; 0, 1, 3, 7, 15, 31, 63, 127, 255, 511, //10 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, //20 1048575, 2097151, 4194303, 8388607, 16777215&#125;;// bitmap[i] is the bitmap for binary strings of length iunsigned int *bitmap[25];// make our bitmap contain a binary string x of length nvoid setbit(int n, unsigned int x);// returns true if our bitmap contains a binary string x of length nbool checkbit(int n, unsigned int x);// print a binary string x of length nvoid print_binary(int n, unsigned int x);int main()&#123; for (int i = 0; i &lt;= 24; i++) &#123; bitmap[i] = new unsigned int[int_size[i]]; for (int j = 0; j &lt; int_size[i]; j++) bitmap[i][j] = 0; &#125; // n is the total number of characters we read in // s is the string at our sliding window // c is the character we just read in // input is 0 if c is &#x27;0&#x27;, is 1 if c is &#x27;1&#x27; unsigned int n = 0, s = 0, input = 0; char c = getchar(); n = 1; // read till nothing more to read or the string is 24 char long for (; c!=&#x27;\\n&#x27; &amp;&amp; n&lt;24; c = getchar()) &#123; input = c - &#x27;0&#x27;; s = (s &lt;&lt; 1) | input; n += 1; &#125; // n is the number of characters read in, including the line feed // n-1 is the actual length of s setbit(n-1, s); // we probably halted because n==24, so we read in 24 valid 0 1 characters // If so, there can be more to be read, so we try to read more but keep the string at 24 characters long // skip this loop if the string is finished with a space for (; c!=&#x27;\\n&#x27;; c = getchar()) &#123; input = c - &#x27;0&#x27;; s = (s &lt;&lt; 1) | input; s = s &amp; 0xFFFFFF; // keeps only the first 24 characters setbit(24, s); n += 1; &#125; n -= 1; // n is the number of characters read in, including the line feed // delete 1 to obtain the actual string length // len is the length of answer string // ans is the binary string in int representation // full is true if all the strings of length i is in our bitmap unsigned int len = 0, ans = 0; bool full = false; for (int i = n&gt;24 ? 24 : n; i&gt;0 &amp;&amp; !full; i--) &#123; full = true; // we assume this level is full for (int j = 0; j &lt; ones[i] + 1; j++) &#123; // iterate all strings 0 ~ 2^i if (checkbit(i, j)) &#123; // percolate down to its substring setbit(i - 1, j &gt;&gt; 1); setbit(i - 1, j &amp; ones[i - 1]); &#125; else if (full) &#123; // current substring doesn&#x27;t exist, and all the previous substrings do exist // so this is the FIRST substring that doesn&#x27;t exist ans = j; len = i; full = false; &#125; &#125; &#125; print_binary(len, ans);&#125;void setbit(int n, unsigned int x) &#123; // x%32 å°±æ˜¯å­˜å‚¨ x çš„ bitï¼Œå³ä»å·¦å‘å³ x%32 ä¸ªä½ç½®çš„é‚£ä¸ª bit // ä½†ç”±äºè®¡ç®—æœºä¸­å­˜å‚¨æ•°æ˜¯ä»å³å‘å·¦å­˜çš„ï¼Œæˆ‘ä»¬éœ€è¦è®© 1 ä»å³ç«¯å¼€å§‹ç§»åŠ¨ ( 31- x%32 ) ä¸ªä½ç½®æ‰å¯ä»¥ // è¿™æ ·æˆ‘ä»¬å¾—åˆ°ä¸€ä¸ªç¬¬ x%32 ä¸º1ï¼Œå…¶ä»–ä½ä¸º 0 çš„äºŒè¿›åˆ¶æ•°ï¼Œé€šè¿‡ or ä¸åŸ bitmap å‚¨å€¼åˆå¹¶ // bitmap[x/32] |= (1&lt;&lt;(31 - x%32)); bitmap[n][x&gt;&gt;5] |= (1&lt;&lt;(31 - x&amp;31));&#125;;bool checkbit(int n, unsigned int x) &#123; // bitmap[x/32] &amp; (1&lt;&lt;(31 - x%32)) is determined solely by the x%32 bit of this int chunk // If that bit is 0, the whole expression is 0 // If that bit is 1, the whole expression is greater than 1 and thus evaluate to true // return bitmap[x/32] &amp; (1&lt;&lt;(31 - x%32)); return bitmap[n][x&gt;&gt;5] &amp; (1&lt;&lt;(31 - x&amp;31));&#125;void print_binary(int n, unsigned int x) &#123; // int æ˜¯ä»å³å¾€å·¦å­˜çš„ï¼Œä¸”æˆ‘ä»¬åªèƒ½è®¿é—®æœ€å³è¾¹çš„ least-significant digit // æˆ‘ä»¬è¦ä»å·¦å¾€å³æ‰“å°ï¼Œåªèƒ½å°†ä»å³å‘å·¦çš„æ¯ä¸ª bit é¡ºåºå­˜èµ·æ¥å†å€’åºæ‰“å° int ans[25]; int m = 0; while (x != 0) &#123; ans[m] = x &amp; 1; x = x &gt;&gt; 1; m++; &#125; // è¡¥å…¨ leading 0s for (int i = m; i &lt; n; i++) &#123; ans[i] = 0; &#125; for (int i = n - 1; i &gt;= 0; i--) &#123; printf(&quot;%d&quot;,ans[i]); &#125; printf(&quot;\\n&quot;);&#125; å¤æ‚åº¦åˆ†æè¯»å…¥é•¿åº¦ä¸º n çš„å­—ç¬¦ä¸²ï¼Œè€—æ—¶ O(n) å¦‚æœ n &gt;24 åˆ™ä» bitmap24 å¼€å§‹éå†ï¼Œå¦‚æœ n&lt;=24 åˆ™ä» bitmap(n) å¼€å§‹éå†ï¼Œè€—æ—¶ $O(2^{min(24,n)})$ å½“ n è¾¾åˆ° 2^24 çº§åˆ«æ—¶ï¼Œæ•´ä½“å¤æ‚åº¦è¿˜æ˜¯ O(n) Reference ç”¨C++å®ç°bitmap 3.3 Kthç®—æ³•é¢˜ç›®è¦æ±‚æ‰¾å‡º a,b,c ä¸‰ä¸ªæ•°ç»„å¯¹åº”çš„ä¸‰å…ƒæ•°å¯¹ä¸­å’Œä¸ºç¬¬ k å¤§çš„é‚£ä¸ªä¸‰å…ƒæ•°å¯¹ï¼Œè§‚å¯Ÿåˆ°å¦‚æœ a,b,c æ˜¯æœ‰åºæ•°å¯¹ï¼Œé‚£ä¹ˆå¿…æœ‰ a[i]+b[j]+c[k] &lt; a[i+1]+b[j]+c[k], a[i]+b[j]+c[k] &lt; a[i]+b[j+1]+c[k], a[i]+b[j]+c[k] &lt; a[i]+b[j]+c[k+1]. äºæ˜¯ï¼Œæˆ‘ä»¬ç»´æŠ¤ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—ï¼Œæ¯æ¬¡å‡ºé˜Ÿ (i,j,k) å°±å…¥é˜Ÿ (i+1,j,k) (i,j+1,k) (i,j,k+1)ã€‚å¦‚æ­¤åš k æ¬¡ï¼Œå‡ºé˜Ÿçš„å°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„ä¸‰å…ƒå¯¹ã€‚æˆ‘ä»¬ç°åœ¨å°†â€œæ‰¾ç¬¬ k å¤§â€è½¬å˜æˆäº†ä¸€ä¸ªä¸‰ç»´å›¾çš„éå†é—®é¢˜ã€‚ å®ç°ä¸­è¦æ³¨æ„çš„æ˜¯ä¸èƒ½è®©åŒä¸€ä¸ªç‚¹å¤šæ¬¡å…¥é˜Ÿï¼Œæˆ‘ä»¬å¯ä»¥å¼€ä¸€ä¸ª vis æ•°ç»„ï¼Œä½†æ˜¯æ¯ä¸ªæ•°ç»„æœ€å¤šæœ‰ 500000 ä¸ªå…ƒç´ ï¼Œä¸‰ç»´ vis æ•°ç»„ç©ºé—´ç»å¯¹ä¸å¤Ÿã€‚äºæ˜¯æˆ‘ä»¬æƒ³ä¸€ç§éå†é¡ºåºï¼Œä½¿å¾—æ¯ä¸ªç‚¹åªè¢«éå†ä¸€æ¬¡ã€‚é¦–å…ˆè€ƒè™‘æœ€ç®€å•çš„ä¸€ç»´ï¼Œå•ä¸ªçš„ x è½´ï¼Œå°±æ˜¯ä¸åœåœ°éå†ä¸‹ä¸€ä¸ªè€Œå·² i, i+1, i+2, ... ï¼›æ‰©å±•åˆ°äºŒç»´å…¶å®å°±æ˜¯å¤šä¸ªä¸€ç»´æƒ…å†µï¼Œæˆ‘ä»¬é€šè¿‡ (0,j), (1,j), ... (i-1,j) åˆ°è¾¾ (i,j) é‚£æˆ‘ä»¬å¦‚ä½•åˆ°è¾¾ (0,j) å‘¢ï¼Ÿé€šè¿‡ (0,0) çš„ä¸€ç»´æ‰©å¼ ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå½“ x è½´ä¸º 0 æ—¶ï¼Œæˆ‘ä»¬æ—¢å‘ x æ–¹å‘æ‰©å¼ ï¼Œä¹Ÿå‘ y æ–¹å‘æ‰©å¼ ï¼Œè€Œå½“ x è½´ä¸ä¸º 0 æ—¶ï¼Œæˆ‘ä»¬åªå‘ x æ–¹å‘æ‰©å¼ ã€‚ å¯¹äºä¸‰ç»´æƒ…å†µï¼Œæƒ³è±¡ x,y,z æ­£æ–¹å‘ä¸ºå³ï¼Œå‰ï¼Œä¸‹ã€‚åˆ™åœ¨ä»»æ„æ—¶åˆ»ï¼Œæˆ‘ä»¬éƒ½å‘ x æ‰©å¼ ï¼›ä»…å½“ x=0 æ—¶ï¼Œæˆ‘ä»¬å‘ y æ–¹å‘æ‰©å¼ ï¼›ä»…å½“ x=0 ä¸” y=0 æ—¶ï¼Œæˆ‘ä»¬å‘ z æ–¹å‘æ‰©å¼ ã€‚å¹¶ä¸”ç”±äºæˆ‘ä»¬æ ¹æ®ä¼˜å…ˆçº§é€‰å–æ¯ä¸€æ¬¡çš„æ‰©å¼ è¾¹ç•Œï¼Œæˆ‘ä»¬ä¸€å®šä¹Ÿæ˜¯ä¼˜å…ˆçº§æœ€é«˜çš„å…ˆè¢«æ‰¾åˆ°ã€‚ ç»†èŠ‚ Heap çš„å®ç°ï¼šsink æ—¶é¦–å…ˆåˆ¤æ–­å­©å­å­˜ä¸å­˜åœ¨ï¼ˆå­©å­åæ ‡ä¸å…ƒç´ æ€»æ•°æ¯”è¾ƒï¼‰å¦‚æœå·¦å­©å­å­˜åœ¨ä¸”â€œå³å­©å­ä¸å­˜åœ¨ï¼Œæˆ–å·¦å­©å­ä¼˜å…ˆçº§æ¯”å³å­©å­é«˜â€ï¼Œåˆ™ä¸å·¦å­©å­äº’æ¢ï¼›å¦‚æœå³å­©å­å­˜åœ¨ä¸”å³å­©å­ä¼˜å…ˆçº§æ›´é«˜ï¼Œåˆ™ä¸å³å­©å­äº’æ¢ ä¸‰ç»´çš„éå†é¡ºåºï¼šå°è¯•å‘ y æ–¹å‘æ‰©å¼ æ—¶ï¼Œå¦‚æœ x!=0ï¼Œè·³è¿‡æ­¤æ¬¡æ‰©å¼ ï¼›å°è¯•å‘ z æ–¹å‘æ‰©å¼ æ—¶ï¼Œå¦‚æœ x!=0 || y!=0ï¼Œè·³è¿‡æ­¤æ¬¡æ‰©å¼  æ•°ç»„çš„æ’åºï¼šåœ¨æœ¬é¢˜æä¾›æ¥å£ä¸­ï¼Œæˆ‘ä»¬æ— æ³•ç›´æ¥è®¿é—®æ•°ç»„ a,b,c ä¸­çš„å…ƒç´ ï¼Œæ‰€ä»¥æˆ‘ä»¬è‡ªå·±å¼€å¦å¤–ä¸‰ä¸ªæ•°ç»„ s,u,t å…¶ä¸­ s[i] è¡¨ç¤º a ä¸­ç¬¬ i å¤§çš„å…ƒç´ æ‰€å¯¹åº”åœ¨ a ä¸­çš„ä½ç½®ã€‚å³ s,u,t å­˜ 1â€¦nï¼Œ ä»£è¡¨ a,b,c ä¸­çš„ä¸‹æ ‡ã€‚ä¸ºå–å¾— sï¼Œæˆ‘ä»¬ä½¿ç”¨ sort(s,n) ä½†æ¯”è¾ƒå™¨ç”¨çš„å´æ˜¯ a çš„æ¯”è¾ƒå™¨ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &quot;kth.h&quot;#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int N = 500007, K = 2000003;int dir[3][3] = &#123; &#123;1,0,0&#125;, &#123;0,1,0&#125;, &#123;0,0,1&#125; &#125;;// sort x-axis by only comparing sums along x-axisint sortx_cmp(const void* a, const void* b) &#123; if (compare(*(int*)a, 1, 1, *(int*)b, 1, 1) == 1) return -1; else if (compare(*(int*)b, 1, 1, *(int*)a, 1, 1) == 1) return 1; else return 0;&#125;int sorty_cmp(const void* a, const void* b) &#123; if (compare(1, *(int*)a, 1, 1, *(int*)b, 1) == 1) return -1; else if (compare(1, *(int*)b, 1, 1, *(int*)a, 1) == 1) return 1; else return 0;&#125;int sortz_cmp(const void* a, const void* b) &#123; if (compare(1, 1, *(int*)a, 1, 1, *(int*)b) == 1) return -1; else if (compare(1, 1, *(int*)b, 1, 1, *(int*)a) == 1) return 1; else return 0;&#125;struct triple &#123; int x, y, z; triple() &#123; x = 0; y = 0; z = 0; &#125;; triple(int a, int b, int c) &#123; x = a; y = b; z = c; &#125; triple(const triple&amp; from) &#123; this-&gt;x = from.x; this-&gt;y = from.y; this-&gt;z = from.z; &#125;&#125;;// myPQ is my priority queuetriple myPQ[K*2];const triple INF = triple(10e7, 10e7, 10e7);// a, b, c is the array given in problem int a[N], b[N], c[N];inline bool operator&lt;(const triple&amp; t1, const triple&amp; t2) &#123; return compare(a[t1.x], b[t1.y], c[t1.z], a[t2.x], b[t2.y], c[t2.z]);&#125;inline bool operator&gt;(const triple&amp; t1, const triple&amp; t2) &#123; return compare(a[t2.x], b[t2.y], c[t2.z], a[t1.x], b[t1.y], c[t1.z]);&#125;// refactorred PQ that only uses strictly greater/lesser to be consistent with compare functionclass PriorityQueue &#123; int n = 0; triple* a = myPQ;public: void add(triple x) &#123; a[++n] = x; swim(n); &#125; triple extract() &#123; if (n == 0) throw &quot;Nothing to extract&quot;; triple result = a[1]; swap(a[1], a[n]); a[n--] = INF; sink(1); return result; &#125; bool isEmpty() &#123; return n == 0; &#125; void print() &#123; for (int i = 1; i &lt;= n; i++) &#123; printf(&quot;%d in heap: (%d, %d, %d)\\n&quot;, i, ::a[a[i].x], b[a[i].y], c[a[i].z]); &#125; &#125;private: void swim(int i) &#123; while (i &gt; 1 &amp;&amp; !(a[i / 2] &lt; a[i])) &#123; swap(a[i / 2], a[i]); i = i / 2; &#125; &#125; void sink(int i) &#123; int l = i * 2, r = i * 2 + 1; while ((l &lt;= n &amp;&amp; !(a[i] &lt; a[l])) || (r &lt;= n &amp;&amp; !(a[i] &lt; a[r]))) &#123; if (l &lt;= n &amp;&amp; (r &gt; n || !(a[l] &gt; a[r]))) &#123; // l is in the heap and (r is not in the heap, or l is the better choice compared to r) swap(a[i], a[l]); i = l; l = i * 2; r = i * 2 + 1; continue; &#125; else if (a[l] &gt; a[r] &amp;&amp; r &lt;= n) &#123; swap(a[i], a[r]); i = r; l = i * 2; r = i * 2 + 1; continue; &#125; else return; &#125; &#125;&#125;;void get_kth(int n, int k, int *x, int *y, int *z) &#123; for (int i = 0; i &lt;= n; i++) &#123; a[i] = b[i] = c[i] = i; &#125; qsort(a+1, n, sizeof(int), sortx_cmp); qsort(b+1, n, sizeof(int), sorty_cmp); qsort(c+1, n, sizeof(int), sortz_cmp); PriorityQueue q; q.add(triple(1, 1, 1)); for (int i = 1; i &lt; k; i++) &#123; // extract k-1 triples triple now = q.extract(); int nowx = now.x, nowy = now.y, nowz = now.z; for (int j = 0; j &lt; 3; j++) &#123; int nextx = nowx + dir[j][0], nexty = nowy + dir[j][1], nextz = nowz + dir[j][2]; if (nextx &gt; n || nexty &gt; n || nextz &gt; n) continue; if ((j == 1 &amp;&amp; nowx != 1) || (j == 2 &amp;&amp; (nowx != 1 || nowy != 1))) continue; q.add(triple(nextx, nexty, nextz)); &#125; &#125; triple result = q.extract(); *x = a[result.x]; *y = b[result.y]; *z = c[result.z];&#125; å¤æ‚åº¦åˆ†æå…±æœ‰ä¸‰ä¸ªæ•°ç»„ï¼Œä¸€ä¸ªæ•°ç»„ä¸­æœ‰ n ä¸ªå…ƒç´ ï¼Œæ‰¾å¤§å°ä¸º k å¯¹çš„ä¸‰å…ƒæ•°å¯¹ã€‚é¦–å…ˆå¯¹ä¸‰ä¸ªæ•°ç»„è¿›è¡Œæ’åº O(nlogn)ï¼Œæ¯æœ‰ä¸€ä¸ªæ•°å¯¹å‡ºä¼˜å…ˆé˜Ÿåˆ—ï¼Œå°±æœ‰æœ€å¤šä¸‰ä¸ªå…¥ä¼˜å…ˆé˜Ÿåˆ—ï¼Œå…±æ“ä½œ k æ¬¡ï¼Œæ¯æ¬¡æ“ä½œ O(logk)ï¼Œæ€»å…± O(klogk)ã€‚æ€»æ—¶é—´ O(nlogn + klogk) 3.4 Componentç®—æ³•å †çš„åˆå¹¶ å·¦åæ ‘ é¢˜ç›®çš„è¯¢é—®æ°¸è¿œæ˜¯æŸä¸€è”é€šåˆ†é‡ä¸­ç¬¬ k å¤§çš„ç‚¹çš„æƒå€¼ï¼Œk æ˜¯ä¸€ä¸ªå¸¸æ•°ã€‚ç¬¬ k å¤§åˆå¯ä»¥çœ‹åšå‰ k ä¸ªæœ€å¤§å…ƒç´ ä¸­æœ€å°çš„å…ƒç´ ï¼Œå³å¦‚æœæˆ‘ä»¬ç»´æŠ¤ä¸€ä¸ªå°æ ¹å †ï¼Œä½¿å®ƒæ’æœ‰ k ä¸ªå…ƒç´ ï¼ˆn&lt;k æ—¶è¾“å‡º -1ï¼Œn&gt;k æ—¶å¼¹å‡º n-k æ¬¡æœ€å°çš„å…ƒç´ ï¼‰é‚£ä¹ˆè¿™ k ä¸ªå…ƒç´ å¿…ç„¶æ˜¯è¿é€šå—ä¸­å‰ k å¤§çš„å…ƒç´ ï¼Œå †é¡¶å…ƒç´ å°±æ˜¯æˆ‘ä»¬çš„è¯¢é—®ã€‚ å½“åŠ å…¥çš„æ–°è¾¹ (u,v) è”é€šä¸¤ä¸ªä¸æ›¾è”é€šçš„è¿é€šå—æ—¶ï¼Œå¯¹åº”çš„ä¸¤ä¸ªå †å¿…é¡»åˆå¹¶ã€‚æ”¯æŒå¿«é€Ÿåˆå¹¶æ“ä½œçš„ä¼˜å…ˆé˜Ÿåˆ—ï¼Œæˆ‘ä»¬é€‰æ‹©å·¦å¼å †ã€‚(u,v) å°†å—è”é€šï¼Œå®é™…ä¸Šæ˜¯å°†å…¶æ‰€åœ¨çš„å †åˆå¹¶èµ·æ¥ï¼Œæˆ‘ä»¬å¿…é¡»èƒ½å¤Ÿé«˜æ•ˆæ‰¾åˆ° (u,v) æ‰€å±å“ªä¸ªå †ï¼Œå³å…¶æ‰€å±å †çš„æ ¹æ˜¯è°ï¼Œä½¿ç”¨å¹¶æŸ¥é›†å­˜å‚¨è¿™ä¸ªä¿¡æ¯ã€‚ ç»†èŠ‚æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ç¼–å·ï¼Œæˆ‘ä»¬ä¸ç”¨ä¼ ç»Ÿçš„ class å»ºä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œè€Œç›´æ¥ç”¨æ•°ç»„å­˜æ¯ä¸ªç‚¹å¯¹åº”çš„ä¿¡æ¯ï¼Œé€Ÿåº¦æ›´å¿«ï¼Œè®¿é—®æ›´æ–¹ä¾¿ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;iomanip&gt;using namespace std;const bool DEBUG = false;const int N = 1000007;int n, m, k, q;// We use a min-heap å°æ ¹å † to store the points// delMax getMax refers to the &quot;max priority&quot; element, which has the smallest value// value[i] is the value of the point i// father[i] is the root of the heap i belongs to// lchild[i], rchild[i] is the left and right child of the point i in heap// npl[i] is the null-path-length of heap i// sze[i] is the size of heap iint value[N], father[N], lchild[N], rchild[N], npl[N], sze[N];// find(i) returns the root of the heap i belongs toinline int find(int x) &#123; return x == father[x] ? x : (father[x] = find(father[x]));&#125;// merge heap b into heap aint merge(int a, int b) &#123; if (a == 0) return b; if (b == 0) return a; if (value[a] &gt; value[b]) swap(a,b); rchild[a] = merge(rchild[a], b); father[rchild[a]] = find(a); if (lchild[a] == 0 || npl[lchild[a]] &lt; npl[rchild[a]]) &#123; int temp = lchild[a]; lchild[a] = rchild[a]; rchild[a] = temp; &#125; npl[a] = rchild[a] == 0 ? 1 : npl[rchild[a]] + 1; sze[a] = sze[lchild[a]] + sze[rchild[a]] + 1; return a;&#125;// getMax(x) returns the value of root of the heap x represents// Requires: x is the root of a heapint getMax(int x) &#123; // x is the root, root is the max, so we just return the value of x return value[x];&#125;// delMax(x) returns the new root after deleting root in heap x// Requires: x is the root of a heapint delMax(int x) &#123; int ans = value[x]; sze[x] -= 1; int new_root = merge(lchild[x], rchild[x]); father[new_root] = new_root; // new root is now a root, so its father is itself father[x] = new_root; // this deleted node, and all the nodes pointing to the deleted node should now point to the new root return ans;&#125;// deletes the Max element until this heap has no more than k elementsvoid prune(int x) &#123; if (sze[x] &lt;= k) return; delMax(find(x)); // needs to find(x) because delMax requires a root prune(find(x)); // after being deleted, x becomes a stranded point // prune must take in the new root of the heap&#125;// print all points and their informationvoid print() &#123; if (!DEBUG) return; cout &lt;&lt; &quot;# value Parent Lchild Rchild npl size &quot; &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; setw(2) &lt;&lt; i; cout &lt;&lt; setw(6) &lt;&lt; value[i]; cout &lt;&lt; setw(6) &lt;&lt; father[i]; cout &lt;&lt; setw(8) &lt;&lt; lchild[i]; cout &lt;&lt; setw(8) &lt;&lt; rchild[i]; cout &lt;&lt; setw(6) &lt;&lt; npl[i]; cout &lt;&lt; setw(6) &lt;&lt; sze[i]; cout &lt;&lt; endl; &#125;&#125;int main() &#123; scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;k, &amp;q); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, value + i); father[i] = i; lchild[i] = rchild[i] = npl[i] = 0; // points to null sze[i] = 1; &#125; sze[0] = 0; npl[0] = 0; father[0] = lchild[0] = rchild[0] = 10e9; for (int i = 1; i &lt;= m; i++) &#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); if (find(a) == find(b)) continue; // already connected, another edge doesn&#x27;t make a difference int merged = merge(find(a), find(b)); prune(merged); &#125; for (int i = 1; i &lt;= q; i++) &#123; int op, a, b; scanf(&quot;%d&quot;, &amp;op); if (op == 1) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); if (find(a) == find(b)) continue; int merged = merge(find(a), find(b)); prune(merged); &#125; else if (op == 2) &#123; scanf(&quot;%d&quot;, &amp;a); if (sze[find(a)] &lt; k) printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;, getMax(find(a))); &#125; &#125;&#125; å¤æ‚åº¦åˆ†æåˆå§‹åŒ–åï¼Œæ¯ä¸ªç‚¹æœ€å¤šè¢«å…¥å †ä¸€æ¬¡ï¼ˆæ‰€åœ¨è¿é€šå—ä¸ä»–äººè”é€šï¼‰ï¼Œå‡ºå †ä¸€æ¬¡ï¼ˆå› ä¸ºä¸å±äºå‰ k å¤§è€Œè¢«å¼¹å‡ºå †ï¼‰æ¯æ¬¡å‡ºå…¥å †æ“ä½œæ˜¯ä¸¤ä¸ªå·¦å¼å †çš„ mergeï¼Œå¤æ‚åº¦ O(logn)ã€‚å…± n ä¸ªç‚¹ï¼Œæ‰€ä»¥æ€»ä½“å¤æ‚åº¦æ˜¯ O(n logn) Reference é¢˜è§£ P3377 ã€æ¨¡æ¿ã€‘å·¦åæ ‘(å¯å¹¶å †) è¯¾ç¨‹ä»£ç ","categories":[],"tags":[{"name":"20FA","slug":"20FA","permalink":"https://harmonyano.github.io/tags/20FA/"},{"name":"Tsinghua","slug":"Tsinghua","permalink":"https://harmonyano.github.io/tags/Tsinghua/"}]},{"title":"Tsinghua DSA ä½œä¸šæ€»ç»“ (2)","slug":"2021-02-10-Tsinghua-DSA-ä½œä¸šæ€»ç»“-(2)","date":"2021-02-10T05:00:00.000Z","updated":"2021-02-10T19:54:44.675Z","comments":true,"path":"2021-02-10-Tsinghua-DSA-ä½œä¸šæ€»ç»“-(2)/","link":"","permalink":"https://harmonyano.github.io/2021-02-10-Tsinghua-DSA-%E4%BD%9C%E4%B8%9A%E6%80%BB%E7%BB%93-(2)/","excerpt":"CSTæ•°æ®ç»“æ„ï¼ˆ2020ç§‹ï¼‰PA2a","text":"CSTæ•°æ®ç»“æ„ï¼ˆ2020ç§‹ï¼‰PA2a 2-1 Buildå¿ƒå¾—List -&gt; ç¼–å·å­˜æ ‘ æˆ‘ç”¨çš„æ˜¯è‡ªå·±å†™çš„ List å­˜æ ‘ï¼Œå¯¹äºä¸€ä¸ªèŠ‚ç‚¹ï¼Œå®ƒæœ‰ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘åŒ…å«å®ƒæ‰€æœ‰å­©å­çš„ Listï¼Œå¹¶æœ‰ height size å­˜å‚¨è¯¥ç‚¹çš„é«˜åº¦åŠå­æ ‘è§„æ¨¡ï¼Œå½“å‘ç”ŸèŠ‚ç‚¹ç§»åŠ¨æ—¶ï¼Œé€’å½’åœ°å‘ä¸Šæ›´æ–°ã€‚ä½†æ˜¯è¿™æ ·çš„è¯æ¯æ¬¡æ›´æ–°æ—¶ï¼Œå¿…é¡»éå†å½“å‰èŠ‚ç‚¹çš„æ‰€æœ‰å­©å­ï¼Œæ‰èƒ½ç¡®è®¤æ˜¯å¦éœ€è¦æ›´æ–°è¯¥ç‚¹çš„é«˜åº¦æˆ–å­æ ‘è§„æ¨¡ï¼Œè¿™æ ·ä¸ç¬¦åˆé¢˜ç›®ä¸­ â€œå¤æ‚åº¦ä¸ cost æˆçº¿æ€§â€ çš„è¦æ±‚ã€‚æ‰€ä»¥ä¼šTLEï¼Œè§£å†³æ–¹æ³•æ˜¯åœ¨æ¯ä¸€ä¸ªç‚¹éƒ½å­˜ä¸€ä¸ªå®ƒå‘åçœ‹èƒ½çœ‹åˆ°çš„æœ€å¤§å­æ ‘é«˜åº¦ä»¥åŠå®ƒåé¢æ‰€æœ‰ç‚¹çš„å­æ ‘è§„æ¨¡å’Œï¼Œè¿™æ ·æ¯æ¬¡åˆ é™¤æŸä¸€ç‚¹æ—¶ï¼Œåªéœ€è¦æ›´æ–°å®ƒå‰é¢å…„å¼Ÿçš„è¿™ä¸¤ä¸ªå€¼å°±å¥½äº†ï¼Œç¬¦åˆæˆ‘ä»¬å¯¹ cost çš„å®šä¹‰ã€‚ List å­˜è¿˜ä¼šå‘ç”Ÿ MLE çš„é—®é¢˜ã€‚æ—¢ç„¶é¢˜ç›®ä¸­å·²ç»ç»™å‡ºæ¯ä¸ªåº—çš„åºå·ï¼Œå…¶å®æˆ‘ä»¬ä¸éœ€è¦ç”¨ List å­˜ï¼Œåªéœ€è¦ç”¨å¤šä¸ªæ•°ç»„å­˜å‚¨ç›¸å¯¹åº”çš„ä¿¡æ¯ï¼ˆå‰åèŠ‚ç‚¹ï¼Œçˆ¶å­èŠ‚ç‚¹ï¼Œæœ¬ä¹¦è§„æ¨¡åŠé«˜åº¦ï¼Œå…¶å‘åçœ‹æ‰€æœ‰å…„å¼Ÿçš„æœ€å¤§é«˜åº¦å’Œå­—æ•°è§„æ¨¡å’Œï¼‰å³å¯ï¼Œè¿™æ ·ä¹Ÿè§£å†³äº†æˆ‘ä»¬ä¸€å¼€å§‹è¯»å…¥æ—¶éœ€è¦è‡ªå»ºé‚»æ¥è¡¨çš„é—®é¢˜ 2-4-2 Kiddç®—æ³•çº¿æ®µæ ‘ï¼Œç¦»æ•£åŒ–ã€‚ çº¿æ®µæ ‘çš„æ¯ä¸ªèŠ‚ç‚¹æ‰€ä»£è¡¨çš„åŒºé—´å¿…é¡»ä¸€é—­ä¸€å¼€ï¼ˆæˆ‘çš„å®ç°ä¸­æ˜¯å·¦é—­å³å¼€çš„ï¼‰ï¼Œå¦‚æœæ˜¯é—­åŒºé—´ä¼šä½¿åŒä¸€ä¸ªç‚¹è¢«å‚¨å­˜åœ¨ç›¸é‚»çš„åŒºé—´ä¸­ä¸¤æ¬¡ã€‚ çº¿æ®µæ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹è¦å­˜ä¸¤ä¸ªä¸œè¥¿ï¼š1. æœ¬èŠ‚ç‚¹å¯¹åº”çš„åŒºé—´è¢«ç¿»è½¬çš„æ¬¡æ•° 2. æœ¬èŠ‚ç‚¹æ‰€åŒ…å«çš„ä¸Šæ‰€æœ‰å­åŒºé—´ï¼ˆåŒ…æ‹¬å®ƒè‡ªå·±ï¼‰è¢«ç¿»è½¬çš„æ¬¡æ•°ã€‚å…¶ä¸­ 2 é€šè¿‡ æœ¬èŠ‚ç‚¹è¢«ç¿»è½¬çš„æ¬¡æ•° * æœ¬èŠ‚ç‚¹ä»£è¡¨çš„åŒºé—´çš„å¤§å° + ä¸¤ä¸ªå­©å­åŒºé—´çš„æ‰€æœ‰å­åŒºé—´è¢«ç¿»è½¬çš„æ¬¡æ•° å¾—æ¥ã€‚ æ‰€ä»¥åœ¨æ¯æ¬¡æŸ¥è¯¢æ—¶ï¼Œå¦‚æœåªæ˜¯å•çº¯çš„ç›¸äº¤ï¼Œç›¸äº¤éƒ¨åˆ†ä¹Ÿåœ¨è¿™ä¸ªåŒºé—´è¢«å½“åšä¸€ä¸ªæ•´ä½“ç¿»è½¬æ—¶æ‰€ç¿»è½¬äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬è®¡ç®—å‡ºç›¸äº¤èŒƒå›´çš„å¤§å°ï¼Œä¹˜ä¸Šæ­¤åŒºé—´è¢«ç¿»è½¬çš„æ¬¡æ•°ï¼›å¦‚æœæŸ¥è¯¢åŒºé—´åŒ…å«åœ¨å½“å‰åŒºé—´é‡Œé¢ï¼ˆæ°å¥½æ˜¯å½“å‰åŒºé—´ï¼‰ï¼Œæˆ‘ä»¬åªéœ€è¦åŠ ä¸Šå½“å‰åŒºé—´åŠå…¶æ‰€æœ‰å­åŒºé—´è¢«åè½¬çš„æ¬¡æ•°å°±å¥½äº† ä»£ç ç¦»æ•£åŒ–éƒ¨åˆ†æœ‰ä¸¥é‡é”™è¯¯ï¼Œæ—¢ç„¶ç¬¬ä¸€æ­¥å°±æœ‰é”™æ‰€ä»¥å‰©ä¸‹çš„å¯¹ä¸å¯¹å’±å…¶å®ä¹Ÿä¸çŸ¥é“ã€‚ä½†æ˜¯æ€è·¯å¤§æ¦‚å°±è¿™ä¹ˆä¸ªæ€è·¯ï¼ˆ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int sort_cmp (const void * a, const void * b) &#123; return ( *(int*)a - *(int*)b );&#125;const int N = 200003;// isQuery[i] is true if the ith operation is a query &#x27;Q&#x27;, is false if the ith operation is a flip &#x27;H&#x27;bool isQuery[N]; int interval[N][2];// a stores the unique discretized intervalint a[N*2], unique_num = 0;struct treeNode&#123; bool isNode = false; // true if this is a leaf in segment tree int l, r; // this node represents the interval [l,r) int v; // this node stores value v; this interval *only* has been flipped v times long long total; // the points in this interval and all its subintervals have been flipped total times&#125;st[(N*2)&lt;&lt;1];void build(int li, int ri, int x);void update(int li, int ri, int x);long long query(int li, int ri, int x);int bisearch(int li, int ri, int g);int original_to_discrete(int x);int discrete_to_original(int y);int temp[N*4];int main()&#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); cin.ignore(100,&#x27;\\n&#x27;); char o; int l, r; for(int i=0; i&lt;m; i++)&#123; scanf(&quot;%c%d%d&quot;, &amp;o, &amp;l, &amp;r); isQuery[i] = (o==&#x27;Q&#x27;); interval[i][0] = l; interval[i][1] = r; temp[i*4 + 0] = l; temp[i*4 + 1] = l+1; temp[i*4 + 2] = r; temp[i*4 + 3] = r+1; cin.ignore(100,&#x27;\\n&#x27;); &#125; qsort(temp, 4*m, sizeof(int), sort_cmp); a[unique_num++] = temp[0]; for(int i=1; i&lt;4*m; i++) &#123; if(temp[i]!=temp[i-1]) a[unique_num++] = temp[i]; &#125; build(0, unique_num, 0); for(int i=0; i&lt;m; i++)&#123; if(isQuery[i])&#123; cout&lt;&lt;query(original_to_discrete(interval[i][0]), original_to_discrete(interval[i][1]), 0)&lt;&lt;endl; &#125; else &#123; update(original_to_discrete(interval[i][0]), original_to_discrete(interval[i][1]), 0); &#125; &#125; return 0;&#125;// node x in s-tree represents the interval [li,ri)void build(int li, int ri, int x)&#123; st[x].isNode = true; st[x].l = li; st[x].r = ri; st[x].v = 0; //cout&lt;&lt;&quot;building node &quot;&lt;&lt;x&lt;&lt;&quot;represents [&quot;&lt;&lt;st[x].l&lt;&lt;&quot;, &quot;&lt;&lt;st[x].r&lt;&lt;&quot;)&quot;&lt;&lt;endl; if(li+1 != ri) &#123; int mid = (li+ri)/2; build(li,mid,(x&lt;&lt;1) + 1); build(mid,ri,(x&lt;&lt;1) + 2); &#125; return;&#125;// currently at s-tree node x, updating interval [li,ri]void update(int li, int ri, int x)&#123; int dis = discrete_to_original(st[x].r-1) - discrete_to_original(st[x].l) + 1; if(li&lt;=st[x].l &amp;&amp; ri&gt;=st[x].r-1)&#123; // interval(x) \\subseteq [li,ri] st[x].v += 1; st[x].total += dis; return; // we should immediately stop updating any children of this node, because that will do a duplicate update &#125; if(!st[(x&lt;&lt;1)+1].isNode) return; // if this is a leaf node, return if(st[(x&lt;&lt;1)+1].isNode &amp;&amp; li &lt;= st[(x&lt;&lt;1)+1].r-1)&#123; // intersects left child update(li, ri, (x&lt;&lt;1)+1); &#125; if(st[(x&lt;&lt;1)+2].isNode &amp;&amp; ri &gt;= st[(x&lt;&lt;1)+2].l)&#123; // intersects right child update(li, ri, (x&lt;&lt;1)+2); &#125; // &#x27;st[x].v * dis&#x27; is the number of flips caused by &quot;this&quot; interval being flipped // st[(x&lt;&lt;1)+1].total is the total number of flips this node&#x27;s left child has // st[(x&lt;&lt;1)+2].total is the total number of flips this node&#x27;s right child has st[x].total = st[x].v * dis + st[(x&lt;&lt;1)+1].total + st[(x&lt;&lt;1)+2].total; return;&#125;long long query(int li, int ri, int x)&#123; long long res = 0; if(li&lt;=st[x].l &amp;&amp; ri&gt;=st[x].r-1)&#123; // interval(x) \\subseteq [li,ri] res += st[x].total; return res; &#125; int dis = discrete_to_original(min(st[x].r-1, ri)) - discrete_to_original(max(st[x].l, li)) + 1; res += st[x].v * dis; if(st[(x&lt;&lt;1)+1].isNode &amp;&amp; li &lt;= st[(x&lt;&lt;1)+1].r-1)&#123; res += query(li, ri, (x&lt;&lt;1)+1); &#125; if(st[(x&lt;&lt;1)+2].isNode &amp;&amp; ri &gt;= st[(x&lt;&lt;1)+2].l)&#123; res += query(li, ri, (x&lt;&lt;1)+2); &#125; return res;&#125;int bisearch(int li, int ri, int g)&#123; int mid = 0; while(ri &gt; li+1)&#123; mid = (li+ri)&gt;&gt;1; if(a[mid]&lt;=g) li = mid; else ri = mid; &#125; return li;&#125;int discrete_to_original(int y)&#123; return a[y];&#125;int original_to_discrete(int x)&#123; return bisearch(0, unique_num, x);&#125; 2.7 Viruså¿ƒå¾—å †çš„ sink çš„è¾¹ç•Œæ¡ä»¶åº”è¯¥æ˜¯ 1234int l=i*2, r=i*2+1;while((l&lt;=n &amp;&amp; a[i]&gt;=a[l]) || (r&lt;=n &amp;&amp; a[i]&gt;=a[r]))&#123; ...&#125; è€Œä¸æ˜¯ 12345678int height(int x)&#123; if(x==0) return 1; int digit=0; while(x&gt;0) &#123;x=x&gt;&gt;1; digit++;&#125; return digit;&#125;while((a[i]&gt;=a[l]||a[i]&gt;=a[r])&amp;&amp;i&lt;pow(2,height(n)))&#123; ...&#125; å †æ˜¯ä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘ (Complete Binary Tree) è€Œä¸æ˜¯ä¸€ä¸ªå®Œç¾äºŒå‰æ ‘ (Perfect Binary Tree) ä»£ç ä»…å±•ç¤ºäº†å †çš„å®ç°éƒ¨åˆ† 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788const int M=1000007;const int INF=10e7;const int N = 1007;struct point &#123; int id; // id = x*N + y int t; point(int x, int y, int ti) &#123; id = x*N + y; t = ti; &#125; point() &#123; id = 0; t = 0; &#125; point(int n) : point() &#123;&#125; point(const point &amp;from) &#123; this-&gt;id = from.id; this-&gt;t = from.t; &#125;&#125;;point myPQ[M];inline bool operator&lt;(const point &amp;p1, const point &amp;p2) &#123; return p1.t &lt; p2.t;&#125;inline bool operator&gt;(const point &amp;p1, const point &amp;p2) &#123; return p1.t &gt; p2.t;&#125;inline bool operator&lt;=(const point &amp;p1, const point &amp;p2) &#123; return p1.t &lt;= p2.t;&#125;inline bool operator&gt;=(const point &amp;p1, const point &amp;p2) &#123; return p1.t &gt;= p2.t;&#125;class PriorityQueue &#123; int n = 0; point *a = myPQ;public: void add(point x) &#123; a[++n] = x; swim(n); &#125; point extract() &#123; point result = a[1]; swap(a[1],a[n]); a[n--]=INF; sink(1); return result; &#125; bool isEmpty() &#123;return n == 0;&#125;private: void swim(int i) &#123; while(i&gt;1 &amp;&amp; a[i/2]&gt;=a[i])&#123; swap(a[i/2],a[i]); i = i/2; &#125; &#125; void sink(int i) &#123; int l=i*2, r=i*2+1; while((l&lt;=n &amp;&amp; a[i]&gt;=a[l]) || (r&lt;=n &amp;&amp; a[i]&gt;=a[r]))&#123; if(a[l]&lt;=a[r]&amp;&amp;l&lt;=n)&#123; swap(a[i],a[l]); i = l; l=i*2; r=i*2+1; continue; &#125; else if (a[l]&gt;a[r]&amp;&amp;r&lt;=n)&#123; swap(a[i],a[r]); i = r; l=i*2; r=i*2+1; continue; &#125; else return; &#125; &#125;&#125;;","categories":[],"tags":[{"name":"20FA","slug":"20FA","permalink":"https://harmonyano.github.io/tags/20FA/"},{"name":"Tsinghua","slug":"Tsinghua","permalink":"https://harmonyano.github.io/tags/Tsinghua/"}]},{"title":"Tsinghua DSA ä½œä¸šæ€»ç»“ (1)","slug":"2021-02-09-Tsinghua-DSA-ä½œä¸šæ€»ç»“-(1)","date":"2021-02-09T05:00:00.000Z","updated":"2021-02-10T19:55:17.231Z","comments":true,"path":"2021-02-09-Tsinghua-DSA-ä½œä¸šæ€»ç»“-(1)/","link":"","permalink":"https://harmonyano.github.io/2021-02-09-Tsinghua-DSA-%E4%BD%9C%E4%B8%9A%E6%80%BB%E7%BB%93-(1)/","excerpt":"CSTæ•°æ®ç»“æ„ï¼ˆ2020ç§‹ï¼‰PA1a","text":"CSTæ•°æ®ç»“æ„ï¼ˆ2020ç§‹ï¼‰PA1a 1-1 A*B Problemå¿ƒå¾— æ¯ä¸ªæ•°ç»„å­˜ä¸€ä½çš„è¯é€Ÿåº¦å¤ªæ…¢è¿‡ä¸äº†ï¼Œå¿…é¡»å‹ä½ 10e5 æ˜¯ 10 * 10^5 æ‰€ä»¥æ˜¯ 10^6 â€¦ æˆ‘ä»¬æŠŠä¸€ä¸ªå¤§æ•´æ•°åˆ†æˆå‡ å—å­˜åœ¨æ•°ç»„é‡Œçš„æ—¶å€™ï¼Œå¦‚æœè¿™ä¸ªæ•°å¤´ä¸Šæœ‰0çš„è¯ï¼Œ0å°±ä¼šè¢«å¿½ç•¥äº†ï¼ˆä¸å‹ä½çš„è¯æ²¡æœ‰è¿™ä¸ªé—®é¢˜ï¼Œå› ä¸º0ä¹Ÿå°±æ˜¯1ä½ï¼‰æ¯”å¦‚4ä½4ä½å­˜ï¼Œ100046000303025ä¼šå˜æˆ[3025, 30, 460, 100]ï¼Œç›´æ¥è¾“å‡ºä¼šå˜æˆ100460303025ï¼Œæ˜æ˜¾ä¸å¯¹ï¼Œæ‰€ä»¥æˆ‘ä»¬è¾“å‡ºçš„æ—¶å€™è¦è®°å¾—è¡¥å…¨0 ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;// N is the maximum number of digits of the input, M is the maximum number of digits of the productconst int N = 5007, M = 10023;// we multiply each 10000 together and store them in a single entry, 10e3 has 4 0s .const int ten = 10e3, d_ten = 4;// a is input A in e4 base, b is input B in e4 base, c is their product in e4 base.int a[N], b[N], c[M];// a_len is the number of entires in a needed to store input A, so it&#x27;s the digit needed to store A in e4 base; b_len is that for Bint a_len, b_len;// digit is a helper array we will need during multiplicationint digit[] = &#123;1,10,100,1000,10000&#125;;// inputA and inputB is A and B read in from streamchar inputA[N], inputB[N];// multiplies e4 base A and B together and store the result in Mvoid multiply();// returns the length of product in e4 baseint get_clen();// print padding zero in each entry of array C when outputting the resultvoid print_padding_zero(int,int);int main()&#123; int n = 0; scanf(&quot;%d&quot;,&amp;n); for (int i=0; i&lt;n; i++)&#123; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); memset(c,0,sizeof(c)); memset(inputA,0,sizeof(inputA)); memset(inputB,0,sizeof(inputB)); scanf(&quot;%s&quot;,inputA); int ina_len = strlen(inputA); a_len = (ina_len-1)/d_ten + 1; scanf(&quot;%s&quot;,inputB); int inb_len = strlen(inputB); b_len = (inb_len-1)/d_ten + 1; // store the number in reverse order and e4 baes in array a,b for (int i=ina_len-1; i&gt;=0;)&#123; int tostore = 0; for (int j=0; j&lt;d_ten &amp;&amp; i-j&gt;=0 ; j++)&#123; int ASCII = inputA[i-j] - &#x27;0&#x27;; tostore += ASCII*digit[j]; &#125; a[a_len-1 - i/d_ten] = tostore; i = i-d_ten; &#125; for (int i=inb_len-1; i&gt;=0;)&#123; int tostore = 0; for (int j=0; j&lt;d_ten &amp;&amp; i-j&gt;=0 ; j++)&#123; int ASCII = inputB[i-j] - &#x27;0&#x27;; tostore += ASCII*digit[j]; &#125; b[b_len-1 - i/d_ten] = tostore; i = i-d_ten; &#125; multiply(); int c_index = get_clen(); printf(&quot;%d&quot;, c[c_index]); for (int i=c_index-1; i&gt;=0; i--)&#123; print_padding_zero(c[i], ten/10); printf(&quot;%d&quot;, c[i]); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125;void multiply()&#123; for(int i=0; i&lt;a_len; i++)&#123; for(int j=0; j&lt;b_len; j++)&#123; int product = a[i] * b[j]; c[i+j] += product; c[i+j+1] += c[i+j] / ten; // carry over digit c[i+j] %= ten; // only stores e4 base number &#125; &#125;&#125;inline int get_clen()&#123; int n = a_len + b_len + 3; while (c[n]==0 &amp;&amp; n&gt;0) n--; return n;&#125;/** * Each entry in array C should store an e4 base number, but sometimes it stores a number smaller than that. * That&#x27;s because it ignores the leading 0s (leading 0s in reversely stored C) when in this case 00XX. * Example: 1004 0030 57 stored in C has form [57, 30, 1004], this function helps print out the first 00 in 0030 **/inline void print_padding_zero(int n, int digit)&#123; if (n&lt;digit) printf(&quot;0&quot;); if (digit == 10) return; print_padding_zero(n,digit/10);&#125; Reference é«˜ç²¾åº¦ä¹˜æ³• é«˜ç²¾åº¦ä¹˜æ³•çš„å‹ä½ 1-3 Filenameå¿ƒå¾—ç¼–è¾‘è·ç¦»ï¼Œç§»åŠ¨çª—å£èŠ‚çœç©ºé—´ å­—ç¬¦ä¸²çš„è¯»å…¥ï¼šä¸€å¼€å§‹ä»¥ä¸ºæ˜¯ getline çš„é—®é¢˜ï¼Œè¯»ä¸è¿›æ¥å­—ç¬¦ä¸²ï¼Œå®é™…ä¸Šæ˜¯å› ä¸ºä»…ç”¨ scanf è¯»å…¥3ä¸ªæ•´æ•°åä¼šç•™ä¸‹ä¸€ä¸ªæ¢è¡Œç¬¦åœ¨ buffer ä¸­ã€‚ä½¿ç”¨ cin.ignore(100,&#39;\\n&#39;) åˆ é™¤æ¢è¡Œç¬¦ï¼ˆå¿½ç•¥ 100 ä¸ªå­—ç¬¦ï¼Œæˆ–è€…å¿½ç•¥1ä¸ª &#39;\\n&#39;ï¼›å¿½ç•¥æ‰€æœ‰è¯»å…¥ï¼Œç›´åˆ°æ€»å…±å¿½ç•¥äº† 100 ä¸ªå­—ç¬¦ï¼Œæˆ–è€…å¿½ç•¥äº† 1 ä¸ªæ¢è¡Œç¬¦ï¼‰ dpæ•°ç»„å¼€åˆ° $1001^2$ ä¼šçˆ†ç‚¸ï¼Œæ”¹ç”¨æ»šåŠ¨çª—å£ï¼Œdp[0][j] è¡¨ç¤º $ x_1x_2â€¦x_{i-1}$ åˆ° $y_1 y_2 â€¦ y_j$ ï¼ˆå‰ä¸€æ­¥ï¼‰æ‰€éœ€è¦çš„æ“ä½œï¼Œdp[1][j] è¡¨ç¤º $ x_1x_2â€¦x_{i-1}$ åˆ° $y_1 y_2 â€¦ y_j$ ï¼ˆè¿™ä¸€æ­¥ï¼‰æ‰€éœ€è¦çš„æ“ä½œã€‚å‡ ä¸ªå®ç°ç»†èŠ‚åœ¨æ³¨é‡Šä¸­å·²æ ‡å‡º TLE: ç¬¬ä¸€æ„Ÿè§‰æƒ³çš„æ˜¯åœ¨æ¯æ¬¡è®¡ç®— $i, s.t. x_1x_2â€¦x_i$ å˜æˆ $y$ æ‰€éœ€è¦çš„æ“ä½œåï¼ˆå³è®¡ç®—å®Œæˆ dp[i][0...m]åï¼‰ï¼Œæ‰«ä¸€éæ•°ç»„ï¼Œå¦‚æœæ‰€æœ‰å€¼éƒ½å¤§äº k çš„è¯ï¼Œå°±åœæ­¢æŸ¥æ‰¾ã€‚ä½†æ˜¯è¿™æ ·ä¸ä¼šå¯¹æ•°æ®è§„æ¨¡æœ‰ä»»ä½•å¯è§‚çš„ç¼©å‡ï¼Œå› ä¸ºå¦‚æœè¯´æˆ‘ä»¬æœ‰é•¿ä¸º $10^5$ çš„ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œå¹¶ä¸”ä»–ä»¬å¯ä»¥åœ¨ k æ“ä½œå†…äº’ç›¸è½¬æ¢ï¼ˆæç«¯æƒ…å†µä¸¤ä¸ªç›¸åŒçš„å­—ç¬¦ä¸²ï¼‰ï¼Œæˆ‘ä»¬ä»ç„¶éœ€è¦è¿›è¡Œ $O(mn) = 10^5 \\times 10^5$ æ¬¡æ“ä½œã€‚ æ ¹æ®ä¹ é¢˜è¯¾çš„è§£å†³æ–¹æ³•ï¼Œå…¶å®å½“ä¸¤ä¸ªæ•°ç»„é—´çš„é•¿åº¦å·®è¶…è¿‡ k æ—¶å°±ç»å¯¹ä¸å¯èƒ½ä»ä¸€ä¸ªè½¬æ¢æˆå¦ä¸€ä¸ªäº†ã€‚æ‰€ä»¥ï¼Œå¯¹äºæ¯ä¸ª $x$ çš„å­ä¸² $x_1x_2â€¦x_i$ï¼Œæˆ‘ä»¬åªéœ€è¦çœ‹ $y_{i-k} y_{i-k+1} â€¦ y_{i+k}$ å°±å¯ä»¥äº†ã€‚å½“ç„¶è¿˜è¦æ³¨æ„ $i-k, i+k$åˆ«è¶Šç•Œï¼Œæ‰€ä»¥å®é™…ä¸Šæ˜¯çœ‹ $y_{min(1,i-k)} â€¦ y_{max(m,i+k)}$ è¿™ä¸ªå­åºåˆ— è¿™ä¸ªæ”¹åŠ¨ä¼šé€ æˆä¸€äº› WAï¼Œç›´è§‰ä¸€ä¸‹å­æƒ³åˆ°æ˜¯æœ‰å¯èƒ½åœ¨æœ€åé€€å‡ºå¾ªç¯æ—¶ï¼Œæˆ‘ä»¬å› ä¸º k çš„é™åˆ¶å‹æ ¹å°±æ²¡æ‰«åˆ° dp[n][m](= dp[1][m])ã€‚å®é™…ä¸Šé—®é¢˜å·®ä¸å¤šï¼Œæ˜¯å› ä¸º dp[i][j] = min(dp[i-1][j], dp[i][(j-1)]) + 1; è¿™å¥è¯ä¸­ dp[0][j] æˆ‘ä»¬ä¸€å¼€å§‹å…¨åˆå§‹åŒ–ä¸º0ï¼Œå¯¹äº dp[i][i+k] è¿™ä¸ªä½ç½®ï¼Œå®ƒçš„ä¸€ç§æ–¹æ¡ˆ dp[i-1][i+k] æ°¸è¿œä¸ä¼šè¢«ä¸Šä¸€æ­¥æ›´æ–°åˆ°ï¼Œå› ä¸ºä¸Šä¸€æ­¥åªæ›´æ–° dp[i-1][(i-1)-k] ~ dp[i-1][(i-1)+k] å³ dp[i-1][i+k] æ’ç­‰äº0ï¼Œå³ dp[i][i+k] æ°¸è¿œä¼šé‡‡å– dp[i-1][i+k] è¿™ä¸€æ–¹æ¡ˆã€‚å°† dp[0][j] åˆå§‹åŒ–ä¸º infinity è§£å†³ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int N = 501007, Inf = 501; // Inf is &quot;effective infinite&quot; : k&lt;=500char a[N], b[N]; // a, b store the string x, yint dp[2][N]; // For each iteration i, dp[0] is equivalent to dp[i-1], dp[1] is equivalent to dp[i]int main()&#123; int n,m,k; //length of x, length of y, max number of operations scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); cin.ignore(100,&#x27;\\n&#x27;); cin.getline(a+1, n+1); cin.getline(b+1, m+1); // initialize dp[0][j] to be the operations needed to edit an empty string to y1y2...yj // initialize the rest of the array to be infinite for(int j=0;j&lt;=m;j++) dp[0][j] = j, dp[1][j] = Inf; for(int i=1; i&lt;=n; i++) &#123; // start from the 1st character // dp[0][0] represents dp[i-1][0] in an ordinary dp array // dp[i-1][0] represents the distance between x1x2...x_&#123;i-1&#125; to the empty string dp[0][0] = i-1; for(int j=max(1, i-k);j&lt;=min(m,i+k);j++)&#123; // only looks at y[i-k] to y[i+k] if(a[i]==b[j]) dp[1][j] = dp[0][(j-1)]; else dp[1][j] = min(dp[0][j], dp[1][(j-1)]) + 1; &#125; // &quot;previous&quot; of next iteration i+1 is current value from this iteration i for(int j=max(1, i-k);j&lt;=min(m,i+k);j++) dp[0][j] = dp[1][j]; &#125; printf(&quot;%d\\n&quot;, dp[1][m]&lt;=k ? dp[1][m] : -1); return 0;&#125; Reference C++ cin.ignore()çš„ç”¨æ³•è¯¦è§£ C++ cin&gt;&gt; cin.get() cin.getline() 1.4 Riskå¿ƒå¾—Queap, äºŒåˆ†æœç´¢ æ¯æ¬¡è¯¢é—®çš„æ—¶å€™ï¼Œå‡è®¾æˆ‘ä»¬è¦çœ‹å‰ m å¤©ï¼Œç°åœ¨çš„ Queap ä¸­å­˜äº† qsize å¤©ï¼Œå¦‚æœ qsize&gt;m çš„è¯ï¼Œæˆ‘ä»¬å­˜äº†ä¸€äº›æ²¡å¿…è¦çœ‹çš„å¤©ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±éœ€è¦æŠŠè¿™äº›æ²¡å¿…è¦çš„å¤©ç»™æ¨å‡ºå»ï¼Œæ‰€ä»¥çœ‹å‡ºæ¥æˆ‘ä»¬éœ€è¦æ¨å‡º qsize-m ä¸ªæ²¡å¿…è¦çš„å¤©ã€‚ç„¶è€Œæˆ‘çš„å®ç°åœ¨ dequeap å’Œ enqueap æ—¶ä¼šå®æ—¶æ›´æ–° qsize æ‰€ä»¥å®é™…ä¸Š Queap åªä¼šå¼¹å‡ºå¤§æ¦‚ä¸€åŠçš„å…ƒç´ ï¼Œä¼šé€ æˆå¾ˆå¤§çš„é—®é¢˜ã€‚æ‰€ä»¥æˆ‘ä»¬å¿…é¡»å…ˆè®°å½• qsize-m ç„¶åå†æ›´æ–° æœ€åçš„Tæ¬¡è¯¢é—®æ˜¯å¯¹å·²ç»æœ‰çš„æ•°æ®ï¼Œè¯¢é—®æœ‰å¤šå°‘åœ¨ç›¸åº”çš„åŒºé—´å†…ã€‚æˆ‘ä»¬è¿™é‡Œå¯ä»¥ä½¿ç”¨æ’åºåäºŒåˆ†æŸ¥æ‰¾åŒºé—´åˆ†ç•Œç‚¹çš„ä½ç½®ï¼Œè€Œä¸æ˜¯å¯¹äºæ¯ä¸ªå…ƒç´ éƒ½çœ‹æ˜¯åœ¨å“ªä¸ªåŒºé—´å†…ã€‚è¿™æ ·å¯ä»¥å¤§å¤§ç¼©çŸ­æ—¶é—´ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;// elements in queue/queap are the number of infections of previous days// size of queue/queap is the number of days we need to keep track of// Queue Nodestruct qNode &#123; long long value; qNode* next, * prev;&#125;;qNode *qHead = new qNode, * qTail = new qNode;// Queap Node; Invariant: node n in a queap [h...n...t] is the max element in interval in [h...n]struct pNode &#123; long long value, num; pNode* next, * prev;&#125;;pNode *pHead = new pNode, * pTail = new pNode;long long qsize = 0;// enqueue value v into Q;// update &quot;max value available&quot; in queap Pvoid enqueap(long long v) &#123; qNode* q = new qNode; pNode* p = new pNode; qsize += 1; q-&gt;value = v, q-&gt;next = qHead-&gt;next; q-&gt;prev = qHead; qHead-&gt;next-&gt;prev = q; qHead-&gt;next = q; pNode* i = pHead-&gt;next; int num = 0; while (i != pTail) &#123; if (v &gt;= i-&gt;value) &#123; num += i-&gt;num; i = i-&gt;next; delete i-&gt;prev;&#125; else break; &#125; // i is the first interval max greater than inserted value // replace everything between pHead and i with the newly inserted value if (num &gt; 0) &#123; p-&gt;value = v; p-&gt;num = num+1; p-&gt;next = i; p-&gt;prev = pHead; i-&gt;prev = p; pHead-&gt;next = p; &#125; else &#123; // num==0 says v &lt; pHead-&gt;next, insert p in between Head and Head-&gt;next p-&gt;value = v; p-&gt;num = 1; p-&gt;next = i; p-&gt;prev = pHead; i-&gt;prev = p; pHead-&gt;next = p; &#125; return;&#125;// dequeue one element from Q and from Pvoid dequeap() &#123; if (qsize &lt;=0) return; qsize -= 1; qNode *qDel = qTail-&gt;prev; qTail-&gt;prev = qTail-&gt;prev-&gt;prev; qTail-&gt;prev-&gt;next = qTail; delete qDel; pNode *pDel = pTail-&gt;prev; if (pDel-&gt;num &gt; 1) pDel-&gt;num--; //there is still element after deletion else if (pDel-&gt;num == 1)&#123; //only one element left, there will be 0 elements after this deletion, so let&#x27;s just delete this node altogether pTail-&gt;prev = pDel-&gt;prev; pDel-&gt;prev-&gt;next = pTail; delete pDel; &#125; else throw &quot;0 element in pNode error&quot;; // there is no element in the top node, which is not supposed to happen return;&#125;// returns the Max value in the Queap; returns 0 if Queap is emptyinline long long getMax() &#123; return qsize&gt;0 ? pTail-&gt;prev-&gt;value : 0;&#125;// print both queue and queap for debugging purposesvoid printQueue() &#123; qNode* q = new qNode; q = qHead-&gt;next; pNode* p = new pNode; p = pHead-&gt;next; cout&lt;&lt;&quot;printing out queue Q:&quot;&lt;&lt;endl; while (q != qTail) &#123; cout &lt;&lt; q-&gt;value &lt;&lt; &quot; &quot;; q = q-&gt;next; &#125; cout &lt;&lt; endl; cout&lt;&lt;&quot;printing out queap P:&quot;&lt;&lt;endl; while (p != pTail) &#123; long long v = p-&gt;value; for (int i = 0; i &lt; p-&gt;num; i++) &#123; cout &lt;&lt; v &lt;&lt; &quot; &quot;; &#125; p = p-&gt;next; &#125; cout &lt;&lt; endl;&#125;// cmp function for qsortinline int sort_cmp (const void * a, const void * b)&#123; return ( *(long long*)a - *(long long*)b );&#125;//returns the last element &lt;=g in [l,r]int bisearch(const long long a[], int l, int r, long long g) &#123; int mid = -1; while(l&lt;r) &#123; mid = (l+r)&gt;&gt;1; a[mid] &lt;= g ? l=mid+1 : r=mid; &#125; return l-1;&#125;long long observed[1000007]; int input[1000007];int main()&#123; // initializes Q and P qHead-&gt;next = qTail, qTail-&gt;prev = qHead; pHead-&gt;next = pTail, pTail-&gt;prev = pHead; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;input[i]); &#125; // For each day, we first check which day is the earliest day we have to keep track of // If there are some days we no longer have to keep track of, we dequeue them from the queap and queue // Then record the maximum infection number maintained by queap and enqueue the infection number of today for (int i = 0; i &lt; n; i++) &#123; long long m; scanf(&quot;%lld&quot;, &amp;m); long long num = qsize-m; for(long long j=0; j &lt; num; j++)&#123; dequeap(); &#125; observed[i] = getMax(); enqueap(input[i]); &#125; qsort(observed, n, sizeof(long long), sort_cmp); // There are T queries, always on already observed infection number // We only care about number of days in a certain range, not the date or any other information // Therefore, we can use binary search to get the number of days in this given range. int T; scanf(&quot;%d&quot;, &amp;T); for (int i=0; i&lt;T; i++)&#123; long long p,q; scanf(&quot;%lld%lld&quot;, &amp;p, &amp;q); int pnum = 0, qnum = 0; pnum = bisearch(observed,0,n,p-1) + 1; // &lt;p \\equiv &lt;=p-1; returns the index of the last element &lt;p, so there are index+1 elements qnum = bisearch(observed,0,n,q-1) - pnum + 1; // similarly, &lt;q \\equiv &lt;=q-1; bisearch(observed,0,n,q-1) - bisearch(observed,0,n,p-1) gives the number of elements in range [p,q) printf(&quot;%d %d\\n&quot;, pnum, qnum); &#125; return 0;&#125; Reference åŒå‘é“¾è¡¨(ç»“æ„ä½“+æŒ‡é’ˆ) å®šä¹‰ç»“æ„ä½“å˜é‡åŠåˆå§‹åŒ–; ç»“æ„ä½“å®šä¹‰å˜é‡çš„ä¸‰ç§æ–¹æ³• unsigned long long int scanf","categories":[],"tags":[{"name":"20FA","slug":"20FA","permalink":"https://harmonyano.github.io/tags/20FA/"},{"name":"Tsinghua","slug":"Tsinghua","permalink":"https://harmonyano.github.io/tags/Tsinghua/"}]},{"title":"Cornell/Tsinghua 20FA æ€»ç»“","slug":"2021-01-11-CornellTsinghua-20FA-æ€»ç»“","date":"2021-01-11T05:00:00.000Z","updated":"2021-02-10T20:00:33.516Z","comments":true,"path":"2021-01-11-CornellTsinghua-20FA-æ€»ç»“/","link":"","permalink":"https://harmonyano.github.io/2021-01-11-CornellTsinghua-20FA-%E6%80%BB%E7%BB%93/","excerpt":"CS4820 Intro Analysis of Algorithms I got to do all the stuff I want. â€¦ Iâ€™m actually one of the Ithacaâ€™s firefighters now and on average we have a really big and nice fire each year so I got to work when that comes. â€“ Dexter Kozen, 2020/12/16","text":"CS4820 Intro Analysis of Algorithms I got to do all the stuff I want. â€¦ Iâ€™m actually one of the Ithacaâ€™s firefighters now and on average we have a really big and nice fire each year so I got to work when that comes. â€“ Dexter Kozen, 2020/12/16 å› ä¸ºç½‘è¯¾çš„åŸå› ä¸æƒ³ä¸Šå†™ä»£ç çš„è¯¾ï¼Œ4820æ˜¯æˆ‘æœ¬å­¦æœŸä¸Šçš„å”¯ä¸€ä¸€èŠ‚CSè¯¾ï¼Œä¹Ÿæ˜¯æ‹¿çš„ç¬¬ä¸€ä¸ªCS A+ã€‚ä½†æ˜¯æ€»ä½“æ¥è¯´ 4820 å’Œ 3110 ä¸Šåˆ°æœ€åéƒ½æ²¡æœ‰ 2112 å’Œ 2802 æœ‰ä¸€ç§æˆ‘çœŸçš„æˆé•¿äº†çš„æˆå°±æ„Ÿï¼Œå¯èƒ½æ˜¯å› ä¸º 4820 è¦†ç›–çš„ä¸œè¥¿å¤ªå¤šï¼Œå¯¼è‡´çŸ¥è¯†é—´æ¯”è¾ƒå‰²è£‚ï¼Œç”¨æ¥è¯æ˜ä¸€ä¸ªç®—æ³•çš„æŠ€å·§åœ¨å¦ä¸€ä¸ªæ¨¡å—å°±ç”¨ä¸å¤ªä¸Šäº†ã€‚ ä»–ä»¬è¯´ä»€ä¹ˆä¸Šå®Œ 4820 å¯¹é¢è¯•æœ‰å¸®åŠ©ï¼Œæˆ‘è§‰å¾—è¿™å®Œå…¨å°±æ˜¯æ‰¯æ·¡çš„ï¼Œå¯èƒ½ç¡®å®åˆ·é¢˜çš„æ—¶å€™ä½ æ›´å®¹æ˜“çœ‹å‡ºæ¥è¿™åº”è¯¥ç”¨ä»€ä¹ˆç®—æ³•äº†ï¼Œä½†æ˜¯è¿™é—¨è¯¾æ‰€æœ‰çš„ç¼–ç¨‹è®­ç»ƒåªèƒ½è¯´æ˜¯éå¸¸åˆçº§ï¼ˆåˆ°è¿æˆ‘éƒ½è§‰å¾—ä¸éš¾çš„æ°´å¹³ï¼‰è¯¾ç¨‹é‡ç‚¹è¿˜æ˜¯åœ¨ç®—æ³•çš„åˆ†æå’Œè¯æ˜ä¸Šï¼Œå’Œè¯æ˜é¢˜ä¸€å¯¹æ¯”ï¼Œç»™çš„ç¼–ç¨‹é¢˜çœŸå°±è·Ÿè¿‡å®¶å®¶ä¸€æ ·ã€‚æœ€åä¸€æ¬¡ä½œä¸šå¤åˆ»äº† sxy çš„å£®ä¸¾äº¤æˆäº† releaseï¼Œå¹¸äºè¿˜æœ‰ä¸ªç¼–ç¨‹é¢˜çš„ 10 åˆ†ä¿åº•ï¼Œè¿™æ¬¡ä½œä¸šå°±æ‹¿äº† 10/30 åˆ†ã€‚ä½†æ˜¯ç”±äºå‰é¢ä½œä¸šè€ƒè¯•éƒ½ä¸é”™ï¼Œè€Œä¸”å»ä¸äº†è·¨æ—¶å·® Office Hour å¯¼è‡´æˆ‘æ‰€æœ‰é—®é¢˜éƒ½åœ¨ Piazza ä¸Šé—®äº†ï¼Œparticipation grade ç‰¹åˆ«é«˜ã€‚xzy åœ¨è¯¾ç¨‹ä¸­é—® participation grade æ€ä¹ˆç®—æ—¶å‘ç°äº†ä»¥åæˆ‘æ‰å»çœ‹çš„ï¼Œæˆ‘çš„ Piazza è´¡çŒ®æ˜¯æ•´ä¸ªç­çš„ç¬¬äºŒï¼Œäººå®¶ç¬¬ä¸€æ˜¯æˆå¤©å›ç­”é—®é¢˜ï¼Œæˆ‘æ˜¯æˆå¤©ä»€ä¹ˆéƒ½æ²¡ææ‡‚åœ¨ä¸Šé¢é—®é—®é¢˜ã€‚ä¸è¿‡ç”¨ Kozen çš„è¯è¯´ï¼Œè¿™ä¹Ÿæ˜¯ä¸€ç§ â€œcontribute to the intellectual content of the courseâ€ æ–¹å¼ã€‚æ‰€ä»¥å¤§æ¦‚æ˜¯å› ä¸ºæé«˜çš„ participation grade ä»¥åŠå¯¹ Kozen çš„è¯šæ³è¯·æ±‚ï¼Œè€äººå®¶æœ€åé«˜æŠ¬è´µæ‰‹ç»™æˆ‘äº†ä¸ª A+ ï¼ˆä¸è¿‡è¦æ˜¯æ²¡è¯¯äº¤ä½œä¸šä¹Ÿæ˜¯æˆ‘åº”å¾—çš„å•¦ï¼‰ å¯¹äº Dexter Kozenï¼Œè¯´å®è¯æ„Ÿè§‰ä»–çš„æ•™å­¦æ°´å¹³å¹¶ä¸å¦‚ Myers å’Œ Halpernï¼Œæœ‰çš„æ—¶å€™åŸºæœ¬ä¸Šæ˜¯å®Œå…¨ç…§ç€è¯¾æœ¬æ¥çš„ï¼Œå¦‚æœä»–æ˜¯å®Œå…¨æŒ‰ç…§è¯¾æœ¬æ¥çš„ï¼Œé‚£ä¹ˆä¸€èˆ¬çœ‹è¯¾æœ¬ç”šè‡³æ¯”ä»–è®²å¾—å¥½ï¼›ä½†æ˜¯å½“ä»–æŒ‰ç…§è‡ªå·±çš„è¯æ˜æ–¹æ³•è®²çš„æ—¶å€™ï¼Œä»–çš„æ–¹æ³•åˆæ¯”ä¹¦ä¸Šçš„å¥½ç†è§£å¾ˆå¤šâ€¦ä¸è¿‡æ¯”ä¸‹è‚¯å®šæ˜¯æœ‰ä½™çš„ï¼Œæ¯”å…¶ä»–å‡ ä¸ªæˆ‘ä¸Šè¿‡è¯¾ä½†æ˜¯æ²¡åœ¨è¿™æåçš„å«å…½å¥½å¤šäº†ã€‚è€Œä¸” Dexter Kozen è¿˜ä¼šåœ¨æœ€åä¸€èŠ‚è¯¾ç»™ä½ å¼¹å‰ä»–å¬ï¼Œå°±è¿™è¿˜è¦å•¥è‡ªè¡Œè½¦ï¼Ÿ è¯¾ç¨‹å†…å®¹åˆ†å¸ƒæ–¹é¢ï¼ˆå¯èƒ½ä¸æ˜¯ Kozen è€Œæ˜¯ä¹¦æœ¬çš„é—®é¢˜ï¼‰åˆ†æ²»å’ŒåŠ¨æ€è§„åˆ’ä¸¤ç« ï¼Œæˆ‘å¹¶ä¸è®¤ä¸ºç¬¬ä¸€æ¬¡æ¥è§¦è¿™äº›æ¦‚å¿µçš„åŒå­¦èƒ½å¬æ‡‚ä»»ä½•ä¸œè¥¿ï¼Œåˆ†æ²»ç›´æ¥ç»™çš„æ˜¯ FFT å’Œæ‰¾å¹³é¢ä¸­æœ€è¿‘ç‚¹çš„ä¸¤ä¸ªå¾ˆå˜æ€çš„ä¾‹å­ï¼ŒåŠ¨è§„ç›´æ¥æ˜¯ä»å¤šç»´åŠ¨è§„å¼€å§‹è®²çš„ï¼ˆä¹¦ä¸Šæ˜¯æŒ‰ç»´åº¦é¡ºåºæ¥çš„ï¼Œè¿™ç¡®å®æ˜¯Kozenä¸€æ—¶å…´èµ·ï¼‰ç½‘ç»œæµè¿™ä¸€èŠ‚ ä½œä¸º Jon Kleinberg å’Œ Eva Tardos çš„ä¸»åœºï¼Œè®²å¾—ä¾‹å­éƒ½éå¸¸æœ‰æ„æ€ã€‚ MATH4710 Basic Probabilityå‚»é€¼ä¸­çš„å‚»é€¼è¯¾ï¼Œæˆ‘ä¸è®¤ä¸ºåœ¨ä¸Šå®Œè¿™èŠ‚è¯¾ä»¥åæˆ‘å¯¹æ¦‚ç‡å’Œç»Ÿè®¡çš„ç†è§£å¯¹æ¯”2802ä¹‹åæœ‰ä»»ä½•è¿›æ­¥ã€‚å½“æ—¶æ˜¯ä¸ºäº†æ‰“ç®—æ˜¥å­£ä¸Šæœºå™¨å­¦ä¹ ï¼Œæ‰€ä»¥å³ä½¿çŸ¥é“è¿™æ³•å›½äººè®²å¾—å±ä½†ä¹Ÿæ˜¯é¡¶ç€å¤´ä¸Šè½å±çš„é£é™©ä¸Šçš„ã€‚æ²¡æƒ³åˆ°äººå®¶æ³•å›½äººè¿™ä¹ˆå®è¯šï¼Œä½ è§‰å¾—æˆ‘è®²å¾—å±ï¼Œæˆ‘å°±çœŸå°±ç”¨å®é™…è¡ŒåŠ¨è¯æ˜è€å­è®²å¾—å°±æ˜¯å±ï¼Œä½ è¿˜æ‹¿ä»–æ²¡åŠæ³•ï¼Œä½ è¯´æ°”ä¸æ°”ï¼Ÿä¸Šè¿™ä¸ªæ³•å›½äººçš„è¯¾ä¸Šåˆ°å­¦æœŸæœ«ï¼Œæˆ‘ç”šè‡³éƒ½ä¸çŸ¥é“ Poisson æˆ–è€…å…¶ä»–æ¦‚ç‡åˆ†å¸ƒçš„å›¾åƒé•¿ä»€ä¹ˆæ ·ï¼Œæˆ‘å¯¹æ¯ä¸€ä¸ªåˆ†å¸ƒçš„è®¤çŸ¥å®Œå…¨æ˜¯å‰²è£‚çš„ï¼Œç›´åˆ°æœŸæœ«è€ƒè¯•æˆ‘è¿˜è¦ä¸€ä¸ªä¸ªæŸ¥æåˆ°çš„åˆ†å¸ƒçš„ distribution function åˆ°åº•æ˜¯ä»€ä¹ˆã€‚æ¯ä¸€æ¬¡çš„ä½œä¸šå’Œè€ƒè¯•éƒ½åœ¨éå¸¸ç¦»è°±çš„åœ°æ–¹ç»™æˆ‘æ‰£åˆ†ï¼Œæœ€åæˆç»©ä¹Ÿè´¼éš¾çœ‹ï¼Œå®Œå®Œå…¨å…¨åœ°æ‰“å‡»äº†æˆ‘å­¦ä¹ æ•°å­¦çš„ä¿¡å¿ƒï¼Œä¸å¦‚è¯´æ•´ä¸ªåº·å¥ˆå°”æ•°å­¦é™¢çš„å­˜åœ¨ï¼Œé™¤äº†å°‘æ•°å‡ ä¸ªæ•™æˆä»¥å¤–ï¼Œå°±æ˜¯ä¸ºäº†æ‰“å‡»ä½ å­¦ä¹ æ•°å­¦çš„ä¿¡å¿ƒã€‚æ•´ä¸ªé™¢é‡Œé¢ï¼Œé™¤äº†ç ”ç©¶åšä¸å‡ºæ¥æ‰€ä»¥åªèƒ½æŠ˜ç£¨å­¦ç”Ÿå–ä¹çš„æ•™æˆï¼Œè¿˜æœ‰ç ”ç©¶åšä¸å‡ºæ¥è€Œä¸”æœ¬èº«å®åŠ›å°±ä¸è¡Œæ‰€ä»¥åœ¨è¯»åšæœŸé—´å¿…é¡»å…¼èŒåŠ©æ•™äºæ˜¯å°±ä¹Ÿè·Ÿç€è™å¾…å­¦ç”Ÿçš„å˜æ€åšå£«ç”Ÿã€‚ä¸åŒ–ç®€æ‰£1åˆ†ï¼Œä½ è¯´100åˆ†æ»¡åˆ†ï¼Œä¸­ä½æ•° 7,80 ä½ æ‰£ä¹Ÿå°±ç®—äº†ï¼Œ60æ»¡åˆ†ä¸­ä½æ•°58çš„è€ƒè¯•ä½ å› ä¸ºä¸åŒ–ç®€ç»™æˆ‘æ‰£2åˆ†ï¼Œè€Œä¸”è®©æˆ‘åŒ–ç®€çš„è¿˜æ˜¯ä¸€ä¸ªå¸¦äº†å››é¡¹ç»„åˆæ•°çš„è¶…æ¶å¿ƒå¼å­ï¼Œä½ æ€ä¹ˆä¸ç›´æ¥è®©æˆ‘é»˜å†™ Ï€ çš„å1000ä½å‘¢ï¼Ÿ EAS1540 Introductory Oceanographyå¤§å¤šæ•°äººå¼ºæ¨çš„ç§‘å­¦è¯¾ï¼Œè¯´å®åœ¨è¯æ²¡ä»€ä¹ˆæ„æ€ã€‚ä¸ªäººæ„Ÿè§‰ä¸å¦‚ DEA1500ï¼ˆè™½ç„¶æ˜¯ä¸ä¸€æ ·çš„ distribution requirementï¼‰Gary Evansåœ¨æˆ‘å¿ƒé‡Œè¿˜æ˜¯æš‚æ—¶çš„é€‰ä¿®è¯¾ä¹‹ç¥çš„åœ°ä½ã€‚å¤§å®¶éƒ½è¯´è¿™é—¨ç§‘å­¦è¯¾è®²å¾—ä¸œè¥¿ç®€å•ï¼ˆæ¯•ç«Ÿæ˜¯è¿ç¾å›½äººéƒ½æ¨èçš„ç§‘å­¦è¯¾ï¼‰å®é™…ä¹Ÿç¡®å®å¦‚æ­¤ï¼Œä½†æ˜¯ç®€å•çš„éƒ¨åˆ†ä»–è®²çš„æˆ‘éƒ½ä¼šï¼Œé¡¶å¤šä¹Ÿå°±æ˜¯é«˜ä¸­åœ°ç†é«˜ä¸€æ°´å¹³ï¼›éš¾çš„éƒ¨åˆ†å‘¢ä»–è¯´å®è¯åˆæ²¡è®²æ˜ç™½ï¼Œè€Œä¸” Bruce Monger åœ¨æ•´ä¸ªå­¦æœŸéƒ½åœ¨ä¸åœçš„è®²ç¯ä¿ç¯ä¿ï¼Œæ‰€ä»¥æ¥çš„æ²¡æœ‰ Gary æœ€åä¸€è¯¾ç”»é¾™ç‚¹ç›é‚£æ ·ä»¤äººå°è±¡æ·±åˆ»ï¼Œä¸è¿‡ Bruce Monger çš„ç›®æ ‡ä¹Ÿè¾¾åˆ°äº†ï¼Œç°åœ¨æˆ‘ç¡®å®æ¸…æ¥šåœ°æ„è¯†åˆ°å¦‚æœ 2030 å’Œ 2050 æ§æ¸©ç›®æ ‡æ²¡è¾¾åˆ°çš„è¯ï¼Œåœ°çƒçœŸçš„ä¼šç­äº¡ã€‚ INFO1998 Freshmen Team Projects (Intro to Machine Learning)æ²¡æ„æ€ï¼Œæ•™ä½ æ€ä¹ˆç”¨ sklearn åº“çš„è¯¾ CS2024 C++ Programmingè¿˜æ˜¯æŒºä¸é”™çš„ï¼Œäº”å…­å¹´ä»¥åï¼Œæˆ‘ç»ˆäºç¬¬ä¸€æ¬¡æ­£å¼å­¦ä¹ äº†C++è¿™é—¨è¯­è¨€ï¼Œå°±æ˜¯ä½œä¸šæœ‰äº›æ— èŠã€‚ CS4320 Introduction to Database Systemsæˆ‘dropäº†è¿™é—¨è¯¾ ä¸€é—¨æ•™æ•°æ®åº“çš„è¯¾ï¼Œå¼€è¯¾ä¸¤ä¸ªç¤¼æ‹œç«Ÿç„¶ä»ç„¶æ²¡æ•™å­¦ç”Ÿä»¬å¦‚ä½•åœ¨ä½ çš„ç”µè„‘ä¸Šå®‰è£…æ•°æ®åº“æ¥ä½¿ç”¨åŸºæœ¬çš„ SQL æŒ‡ä»¤ï¼›è€å¸ˆæ“ç€ä¸€å£è°ä¹Ÿå¬ä¸æ‡‚çš„å¾·å›½å£éŸ³ï¼Œè®©æˆ‘æ¢¦å›æˆ‘æ‰˜ç¦æ°´å¹³åªæœ‰80åˆ†çš„æ—¶å€™å…ƒç´ å¬æ‰˜ç¦å¬åŠ›çš„é‚£ä¸ªç§‹å¤©ï¼›å½•åƒä¸Šä¼  youtube å…¬å¼€ï¼Œå°±å¥½åƒé™¤äº†ä½ çš„å­¦ç”Ÿä»¥å¤–è°è¿˜ä¼šé—²ç€æ²¡äº‹ä¸å»ä¸ŠCMUçš„æ•°æ®åº“ï¼Œæ¥ä¸Šæ‚¨çš„è¯¾ç»ƒä¹ å¾·è¯­ä¸€æ ·ï¼ˆä½†è¿˜æ˜¯è¦èµæ‰¬ä¸€ä¸‹è¿™ä¸ªè€å¸ˆå…¬å¼€ä¸Šä¼ ï¼Œä»–å®é™…ä¸Šä¹Ÿå°†è¿‘å‡ å¹´çš„æ‰€æœ‰è¯¾ç¨‹å½•åƒä¸Šä¼ åˆ°äº† Cornell VODï¼Œåªæ˜¯æˆ‘ä¸æ¸…æ¥šåˆ°åº•è°ä¼šå»çœ‹è®²å¾—è¿™ä¹ˆçƒ‚çš„è¯¾ï¼‰ åœ¨æ¸…åè®¤è¯†çš„åŒå­¦ Leo ç«Ÿç„¶è·Ÿæˆ‘è¯´ä»–æœ€åè¿™é—¨è¯¾å¾—äº†ä¸€ä¸ª A+ï¼Œè€Œä»–å¾— A+ çš„è¯€çªå°±æ˜¯è‡ªå·±åŸæ¥æ¥è§¦è¿‡æ•°æ®åº“ï¼Œä¸å»ä¸Šè¯¾ï¼Œä½œä¸šå‘ä¸‹æ¥ä»¥åè‡ªå·±æŸ¥æ‰¾ç›¸å…³èµ„æ–™è¿›è¡Œå­¦ä¹ ï¼Œä¹Ÿæ˜¯éå¸¸ç¦»è°±ï¼Œä¸çŸ¥é“å¾·å›½äººå‘ç°åŸæ¥ä»–è§‰å¾—åšå¾—ä¸é”™çš„å­¦ç”Ÿéƒ½æ˜¯é€šè¿‡è¿™ç§æ–¹å¼â€œåšçš„ä¸é”™â€çš„ä¼šä½œä½•æ„Ÿæƒ³ã€‚ ä¸¤å¹´ä»¥æ¥ï¼Œæˆ‘é¦–æ¬¡æ„Ÿè§‰åˆ°æˆ‘çš„å­¦è´¹èŠ±å¾—å€¼ï¼Œå°±æ˜¯åœ¨è¿™ä¸ªåŠ¨è¡çš„2020å¹´ï¼ŒCornell å¯¹å®ƒçš„ä¸­å›½å­¦ç”Ÿè¯´ï¼Œä½ å¯ä»¥å»æ¸…åŒ—ä¸Šäº¤ä¸­çš„ä¸€æ‰€å­¦æ ¡è¿›è¡Œä½ çš„çº¿ä¸‹ç§‹å­£å­¦æœŸï¼Œå…¶ä»–çš„æ‰€è°“ Ivy å’Œ Ivy+ ä»¬ï¼Œå¤§æ°”éƒ½ä¸æ•¢å‡ºä¸€ä¸ªï¼Œæ›´åˆ«è¯´å»æ¸…åŒ—ä¸Šäº¤äº†ã€‚åº·å¥ˆå°”ç‰›é€¼ï¼ å…¶å®ä¸€å¼€å§‹æˆ‘æ˜¯å½•çš„ä¸Šæµ·äº¤é€šå¤§å­¦ï¼Œåæ¥å¥½åƒè¢«è¡¥å½•çš„æ¸…åï¼Œæœ‰äº†TOP2ï¼Œè°è¿˜ä¼šå»ä¸Šæµ·ä¸€ä¸ªä¸çŸ¥åçš„å°å­¦æ ¡å‘¢ï¼Ÿ 30240184 æ•°æ®ç»“æ„ ç°åœ¨æˆ‘ä»¬è¦æ¥è¯æ˜ä¸€ä¸‹å®ƒçš„æ­£ç¡®æ€§â€¦â€¦â€¦â€¦â€¦ä¸ºä»€ä¹ˆè¦è¯æ˜å‘¢ï¼Ÿå°±å¥½åƒä½ ä¸èƒ½è¯´è‡ªå·±æ˜¯ä¸–ç•Œä¸€æµå¤§å­¦ä½ å°±æ˜¯äº†ï¼Œä½ è‚¯å®šå¾—è¯æ˜ä¸€ä¸‹è‡ªå·±ç¡®å®æœ‰åŒ¹é…çš„å®åŠ›æ‰è¡Œ â€“ é‚“ä¿Šè¾‰ï¼Œäºä¸ºä»€ä¹ˆè¦è¯æ˜äºŒåˆ†æŸ¥æ‰¾çš„æ­£ç¡®æ€§ è¿™æ˜¯ä¸€é—¨ç¥å¥‡çš„è¯¾ç¨‹ï¼Œæ— è®ºè®²å¾—æ¦‚å¿µæ˜¯ç®€å•çš„é“¾è¡¨è¿˜æ˜¯éš¾çš„çº¿æ®µæ ‘ï¼Œéƒ½èƒ½è®©å­¦ç”Ÿå—ç›Šï¼Œé‚“ä¿Šè¾‰è€å¸ˆæ˜¯ä¼Ÿå¤§çš„è€å¸ˆï¼Œä»–è®©æˆ‘ä¸€ä¸ªåŸæ¥è§‰å¾—çº¿æ®µæ ‘æˆ–kdæ ‘è¿™ç§ä¸œè¥¿ç¦»æˆ‘å¾ˆè¿œçš„äººï¼Œæ„Ÿå—åˆ°äº†åŸæ¥æˆ‘ä¹Ÿèƒ½å¬æ˜ç™½è¿™ä¹ˆå¤æ‚çš„æ•°æ®ç»“æ„ã€‚ä»–ä¹Ÿè®©æˆ‘è®¤è¯†åˆ°ï¼Œæˆ‘æ ¡çš„ Nate Foster çœŸæ˜¯ä¸ª cjbï¼Œocaml çš„çº¢é»‘æ ‘å®ç°ä¸æ˜¯å› ä¸º pattern matching æ‰€ä»¥ä»£ç æ‰é‚£ä¹ˆå°‘ï¼Œæ˜¯å› ä¸ºå®ƒä½¿ç”¨çš„æ˜¯ 3-4 é‡æ„è€Œä¸æ˜¯ä¼ ç»Ÿçš„æ—‹è½¬ï¼Œè¦æ˜¯ C++ å†™é‡æ„ä»£ç é‡ä¹Ÿä¼šå¤§å¹…å‡å°‘â€¦ é‚“ä¿Šè¾‰è€å¸ˆä¹Ÿé¼“åŠ±äº†æˆ‘ï¼Œè¯´ä¸å®šæˆ‘å’Œæ¸…åçš„åŒå­¦ä»¬å®åŠ›å·®è·æ²¡æœ‰æˆ‘åŸæ¥æƒ³è±¡çš„é‚£ä¹ˆå·¨å¤§ï¼Œæˆ‘å·®çš„å°±æ˜¯ä¸€å ‚è¿™ä¹ˆå¥½çš„è¯¾ï¼Œä¸€ä¸ªå…¨æ˜¯å­¦CSåŒå­¦çš„å®¿èˆï¼Œä¸€ä¸ªè€å¿ƒè®¤çœŸçš„è€å¸ˆè€Œå·²ã€‚æ¸…åŒ—å’ŒMITæ˜¯æˆ‘å¿ƒç›®ä¸­çš„åœ£åœ°ï¼Œæˆ‘ä»¥ä¸ºé‡Œé¢çš„äººéƒ½æ˜¯æ„¿æ„ç©·å…¶ä¸€ç”Ÿä¸ºå…¨äººç±»æœåŠ¡çš„äººï¼Œæˆ‘ä¹Ÿä»¥ä¸ºæˆ‘è¿™æ¬¡æ¥ä¹‹åï¼Œè¿™ä¸ªæƒ³æ³•è¦ä¹ˆç ´ç¢è¦ä¹ˆå°è¯ï¼Œå› ä¸ºè¿™é—¨è¯¾ï¼Œå› ä¸ºé‚“ä¿Šè¾‰è€å¸ˆï¼Œæˆ‘ç°åœ¨æ›´å€¾å‘äºè¯´æˆ‘çš„è¿™ä¸ªæƒ³æ³•è¢«å°è¯äº†ã€‚ å®é™…ä¸Šä¸Šå®Œè¿™é—¨è¯¾ä»¥åæˆ‘å¯¹è‡ªå·±çš„è®¤çŸ¥æ›´è¿·èŒ«äº†ï¼Œè™½ç„¶ PA1 åšçš„ä¸æ˜¯é‚£ä¹ˆå¥½ï¼ˆå’Œæ¸…ååŒå­¦æ¯”ï¼Œè‡ªå·±çš„é¢„æœŸè¿˜æ˜¯è¾¾åˆ°äº†çš„ï¼‰PA2 å› ä¸ºåº·å¥ˆå°”æœŸæœ«è€ƒï¼Œæ‘”ä¼¤äº†è…¿ï¼Œç”Ÿç—…ç­‰ç­‰å‡ ä¹æ²¡åšï¼Œä½†å’± PA3 æ‹¿äº†æ»¡åˆ†å•Šï¼Œè€Œä¸” PA3 æ˜¯å”¯ä¸€ä¸€ä¸ªçœŸæ­£æœ‰ TA æŒ‡å¯¼çš„çš„ Programming Assignmentï¼Œå…¶ä»–çš„éƒ½æ˜¯åˆ«çš„åŒå­¦å¯ä»¥ç›´æ¥é—®ä»–ä»¬ç­é‡Œå®¿èˆé‡Œçš„ä¿¡ç«å¤§ä½¬ï¼Œæˆ‘åªèƒ½é—­é—¨é€ è½¦ã€‚å››èˆäº”å…¥ï¼Œæˆ‘æ˜¯ä¸æ˜¯è¦æ˜¯æœ‰ä¸€å®šç¨‹åº¦çš„å¸®åŠ©ï¼Œå’Œæ¸…ååŒå­¦æ¯”ä¸€ç‚¹ä¹Ÿä¸å·®å‘¢ï¼Ÿè¯´å®è¯æˆ‘æ¥ä¹‹å‰ç¡®å®å¿ƒé‡Œé¢æœ‰ç‚¹è¿™æ ·æƒ³ï¼Œæ¯•ç«Ÿæ¸…åçš„äººè™½ç„¶èªæ˜ï¼Œä½†æ˜¯å¤§éƒ¨åˆ†äººé«˜ä¸­ä¸‰å¹´æ²¡ä»»ä½•ç¼–ç¨‹ç»å†ï¼Œæˆ‘è™½ç„¶è ¢ï¼Œä½†æ˜¯å¯¹è‡ªå·±CSè¿˜æ˜¯æ¯”è¾ƒæœ‰ä¿¡å¿ƒçš„ã€‚ç›´åˆ°ä¸Šå®Œè¿™é—¨è¯¾ï¼ŒæœŸæœ«è€ƒè¯•å‡ ä¹éƒ½ä¸ä¼šçš„æƒ…å†µä¸‹ï¼Œæˆ‘çš„å¿ƒé‡Œè¿˜æ˜¯æŠ±æœ‰é‚£ä¹ˆä¸€ä¸ä¸å¸Œæœ›ï¼šè¯´ä¸å®šå’±å’Œæ¸…åäººæ¯”ä¸€ç‚¹ä¸å·®å‘¢ã€‚è¯´åˆ°è¿™ä¸ªï¼Œæˆ‘å’Œå…¶ä»–äººè¯´èµ·æ¸…åè¿™é—¨è¯¾å¾ˆéš¾çš„æ—¶å€™ï¼Œä»–ä»¬è¡¨ç°å¾—ç«Ÿç„¶æ˜¯æƒŠè®¶è€Œä¸æ˜¯ç†æ‰€å½“ç„¶ï¼Œä»–ä»¬ç«Ÿç„¶çœŸçš„è§‰å¾—åº·å¥ˆå°”æä¾›çš„æ•™è‚²è¶³ä»¥è®©æˆ‘ä»¬å¯ä»¥å’Œæ¸…åäººæŠ—è¡¡ã€‚çœ‹æ¥åœ¨æœ‰è‡ªçŸ¥ä¹‹æ˜è¿™ç‚¹ä¸Šæˆ‘è¿˜æ˜¯æ¯”å…¶ä»–åŒå­¦é«˜ä¸€ç‚¹çš„ï¼ˆ é€‰è¿™é—¨è¯¾è¿˜è¦æ„Ÿè°¢ czï¼Œæ˜¯ä»–è·Ÿæˆ‘è¯´äº†è¿™é—¨è¯¾è¯„ä»·å¾ˆå¥½æˆ‘æ‰ä¼šå»é€‰ï¼Œä¸ç„¶â€œæ•°æ®ç»“æ„â€è¿™ç§è¯¾æˆ‘ç»å¯¹è§‰å¾—æˆ‘éƒ½å­¦å¾—ä¼šäº†ï¼Œæ‡’å¾—ä¸Šã€‚å®é™…ä¸Šæˆ‘ä¸€å¼€å§‹ä¸æ˜¯åœ¨é‚“è€å¸ˆé—¨ä¸‹å­¦ä¹ ï¼Œä¸€å¼€å§‹ç»™å›½é™…äº¤æ¢ç”Ÿçš„åé¢åªæœ‰å¦ä¸€ä¸ªè®²å¸ˆçš„ç­äº†ï¼Œä½†æˆ‘ç¬¬ä¸€èŠ‚è¯¾å»å¬äº†ä»¥åï¼Œå¥¹è®²å°¾é€’å½’ç«Ÿç„¶è¯´ç”¨åˆ°çš„ç©ºé—´ä¼šæ˜¯ O(n)ï¼Œå…¶ä¸­ n æ˜¯è°ƒç”¨æ¬¡æ•°ã€‚åˆ«çš„æˆ‘ä¸ç¡®å®šï¼Œä½†æ˜¯ Myers æ›¾ç»æ˜ç¡®åœ°è¯´è¿‡å°¾é€’å½’çš„å¥½å¤„å°±æ˜¯å¯ä»¥é‡å¤åœ°ä½¿ç”¨è°ƒç”¨æ ˆï¼Œå¦‚æ­¤ä¸€æ¥ä¸ä¼šæœ‰æº¢å‡ºï¼ˆå½“ç„¶äº†è¯´ä¸å®š Java å’Œ C++ å¹¶ä¸ä¸€æ ·ï¼‰äºæ˜¯ä¸‹è¯¾ä»¥åæˆ‘å»è¯¢é—®ä¸ºä»€ä¹ˆæ˜¯ O(n) å’Œå¥¹è®²äº†æˆ‘çš„æƒ³æ³•ï¼Œå¥¹è¡¨ç°å¾—æŒºä¸è€çƒ¦ï¼Œç„¶åæˆ‘è¿½ç€å¥¹å‡ºäº†æ•™å®¤ï¼Œå¥¹ä¸€è¾¹å¼€è‡ªè¡Œè½¦çš„é”ä¸€è¾¹å¬æˆ‘è¯´è¯ï¼Œæœ€åå°±æ’‚ä¸‹ä¸€ä¸ª â€æ©ï¼Œé‚£å¯èƒ½æ˜¯è¿™æ ·å§â€œ å°±èµ°äº†ã€‚è¿™ä¸ªè¡¨ç°è®©æˆ‘å›å¿†èµ·äº†æˆ‘çš„é«˜ä¸­ç­ä¸»ä»»ä¹Ÿæ˜¯è¿™æ ·ï¼Œè¯´è‡ªå·±å¾ˆå–œæ¬¢å­¦ç”Ÿï¼Œå¾ˆå–œæ¬¢æ•™å­¦ï¼Œæœ€åä½ å»æ‰¾å¥¹çš„æ—¶å€™å¥¹æ ¹æœ¬æ˜¯æ¼ ä¸å…³å¿ƒï¼Œè™šä¼ªçš„ä¸€Bï¼Œå¹¸äºæˆ‘åæ¥è®¤è¯† Leoï¼ŒçŸ¥é“äº†ä»–ï¼ˆå¹¶ä¸çŸ¥é“è‡ªå·±åº”è¯¥è·Ÿæˆ‘ä¸€ä¸ªç­ï¼‰ä¸€ç›´åœ¨å¬é‚“è€å¸ˆçš„è¯¾ï¼Œå»å¬äº†ä»¥åçœŸæ˜¯ä¸€ä¸ªå¤©ä¸Šä¸€ä¸ªåœ°ä¸‹ã€‚æ¸…åçš„åŒå­¦ä»¬å•Šï¼Œä½ ä»¬éƒ½åœ¨æ¸…åäº†ï¼Œä¸ºä»€ä¹ˆè¦æŠ˜ç£¨è‡ªå·±ï¼Œä¸è·Ÿç€é‚“è€å¸ˆå­¦å‘¢ï¼Ÿ ä¸Šå®Œè¿™é—¨è¯¾æˆ‘ä¹Ÿåœ¨æƒ³ï¼Œæ˜¯ä¸æ˜¯åªæœ‰å·®çš„è€å¸ˆï¼Œæ²¡æœ‰å·®çš„å­¦ç”Ÿï¼Ÿå¦‚æœæ¯ä¸ªäººéƒ½å¬é‚“è€å¸ˆçš„è¯¾ï¼Œæˆ‘å¾ˆæ€€ç–‘ä»–ä»¬ä¼šå¬ä¸æ‡‚ï¼ˆæ¯•ç«Ÿæˆ‘éƒ½å¬æ‡‚äº†ï¼‰å¯æ˜¯å…¶ä»–å¤§å­¦çš„åŒå­¦ä»¬å¹¶æ— æ³•äº«å—åˆ°è¿™ç­‰å¾…é‡ï¼Œåªèƒ½é€¼ç€è‡ªå·±å¬è®²é‚£ä¸ªè®²å¾—çƒ‚çš„ã€‚å°±å¥½åƒ qsq åœ¨åŒ—å¸ˆå¤§ï¼Œæˆ–è€…æˆ‘è‡ªå·±åœ¨åº·å¥ˆå°”çš„ç»å†å®Œå…¨ä¸€æ ·ï¼Œä¸€ä¸ªå·®çš„è€å¸ˆä¸ä»…å¸®ä¸åˆ°å­¦ç”Ÿï¼Œè¿˜ä¼šä¸¥é‡åœ°æ‰“å‡»ä¸€ä¸ªäººçš„è‡ªä¿¡å¿ƒï¼Œè®©ä»–æ·±æ·±åœ°æ€€ç–‘æˆ‘åˆ°åº•å–œä¸å–œæ¬¢è¿™ä¸ªå­¦ç§‘ï¼Œè¿™ä¸ªå­¦ç§‘åˆ°åº•é€‚ä¸é€‚åˆæˆ‘ç­‰ç­‰æ­¤ç±»ã€‚ Logic, Computing, Gamesæ¸…åå¤§å­¦ç‰¹è˜æ•™æˆï¼Œæ–¯å¦ç¦å¤§å­¦åèª‰æ•™æˆï¼Œä»€ä¹ˆä»€ä¹ˆå¾ˆå‰å®³çš„ç ”ç©¶æ‰€çš„åˆ›å§‹äºº Johan van Benthemï¼æ¥ç»™ä½  ä¸Šç½‘è¯¾ï¼ è€Œä¸”è¿™ç½‘è¯¾è¿˜æ˜¯å¦‚æœä½ æƒ³è¦é—®é—®é¢˜å¿…é¡»ç­‰è€å¸ˆä¸€èŠ‚è¯¾ä¸‹è¯¾ä»¥åï¼Œä½ æ‰èƒ½å’ŒåŠ©æ•™ä¸¾æ‰‹ç¤ºæ„è¯´æˆ‘æœ‰ä¸ªé—®é¢˜ï¼Œç„¶åä»–ä¼šç»™ä½ ä¸€ä¸ªéº¦å…‹é£ä½ æ‰èƒ½é—®ã€‚å­¦ç”Ÿæ²¡æœ‰ä»»ä½•ç›´æ¥è”ç³»æ•™æˆçš„æ–¹æ³•ï¼Œå¿…é¡»é€šè¿‡åŠ©æ•™ï¼ŒåŠ©æ•™åˆä¸€å‰¯çˆ±ç­”ä¸ç†çš„æ ·å­ï¼Œè¯¾ç¨‹æ¨èé˜…è¯»ä¹Ÿæ²¡æœ‰ï¼Œå¿…è¦å…ˆä¿®çŸ¥è¯†ä¹Ÿä¸å†™ï¼Œç”šè‡³è¿ä¸ª syllabus éƒ½æ²¡å¾—ã€‚æ•™æˆçš„è¯¾è®²å¾—å…¶å®è¿˜ä¸é”™ï¼Œç¬¬ä¸€èŠ‚è¯¾æˆ‘æ„Ÿè§‰è‡ªå·±å¬åˆ°äº†å‰äºŒååˆ†é’Ÿï¼Œå½“æˆ‘åé¢å®Œå…¨å¬ä¸æ‡‚æƒ³è¦è‡ªå·±é˜…è¯»ææ–™å¯»æ±‚å¸®åŠ©æ—¶ï¼Œå‘ç°è¿™é—¨è¯¾å±éƒ½ä¸æä¾›ï¼Œä¹Ÿä¸çŸ¥é“æ˜¯è¿™ä¸ªæ•™æˆä¸ä¸Šå¿ƒï¼Œè¿˜æ˜¯åŠ©æ•™ä»€ä¹ˆéƒ½ä¸ç®¡åªç®¡å‘æ•™æˆæŠ¥å‘Šâ€œä¸€åˆ‡å®‰å¥½â€ï¼Œæˆ–è€…æ˜¯å…¨æ¸…åçš„è¯¾éƒ½æ˜¯è¿™ä¸ªå¾·è¡Œï¼Œæˆ‘åæ­£ä¸Šä¸ä¸‹å»è¿™è¯¾äº†ï¼Œä¹Ÿæ˜¯å¾ˆé—æ†¾çš„ï¼Œæ¯•ç«Ÿå¯¹æ–¹çœ‹èµ·æ¥çœŸçš„æ˜¯å¾ˆæœ‰åçš„æ•™æˆï¼Œæ¯”åº·å¥ˆå°”çš„å“²å­¦é™¢ä¼°è®¡å¥½ä¸å°‘å‘¢â€¦ è¯è¯´åæ¥æˆ‘è¿˜å»çœ‹äº†å‡ èŠ‚ï¼Œå‘ç°äººæ˜¯è¶Šæ¥è¶Šå°‘ï¼Œçœ‹åˆ°æ¸…åçš„åŒå­¦ä»¬ä¹Ÿé€€äº†æˆ‘æ˜¯å¾ˆå¼€å¿ƒçš„ï¼Œä¸è¿‡ä»–ä»¬å¯èƒ½æ˜¯å› ä¸ºå¬ä¸æ‡‚è‹±è¯­é€€çš„å§ï¼Ÿæˆ‘ä¹Ÿä¸çŸ¥é“ Introduction to Artificial Intelligenceåœ†äº†ä¸€ä¸ªè‡ªå·±â€œä¸Šå‰é™¢çš„è¯¾â€çš„è¿™ä¸€è£…é€¼æ¢¦ï¼Œç¬¬ä¸€èŠ‚è¯¾æ˜¯ä¸ªè€å¤´å­ï¼Œè‹±è¯­è®²å¾—ä¹Ÿä¸å¾ˆæºœé“ä½†å°±æ˜¯è¦è¯´è‹±è¯­ï¼Œç¬¬ä¸€èŠ‚è¯¾å•¥ä¹Ÿæ²¡è®²å°±è®²äº†è®²AIçš„å†å²ä»€ä¹ˆçš„ï¼Œå¾ˆæ˜¯æ²¡æ„æ€ã€‚åæ¥å‘ç°è¿™ä¸ªè‹±è¯­è®²å¾—ä¸æºœé“ï¼Œè¯´è¯ä¹Ÿä¸æºœé“çš„è€å¤´å­æ˜¯å§šæœŸæ™ºè€å…ˆç”Ÿâ€¦å˜¶ï¼Œå¯¹ä¸èµ· ç¬¬äºŒèŠ‚è¯¾å°±å¼€å§‹æœ‰æ„æ€äº†ï¼Œä¸€ä¸Šæ¥å°± reinforcement learning çš„ä»€ä¹ˆå¾ˆå‰å®³çš„äººæ¥è®²å¾ˆå…ˆè¿›çš„ reinforcement learningï¼Œæœ‰æ„æ€æ˜¯æœ‰æ„æ€ï¼Œä¸è¿‡æ˜¯å±€é™äºå‰é™¢åŒå­¦ä»¬çš„æœ‰æ„æ€ï¼Œæˆ‘å·²ç»å¬ä¸æ‡‚äº†ï¼Œæ—©æ—©æ‹œæ‹œï¼Œå¬äº†ä¸€èŠ‚è¯¾å°±è¡Œäº† è¯¾å ‚ä¸Šè¿˜æœ‰æ¥è‡ª Princeton çš„åŒå­¦ä»¬ï¼ˆçœ‹åˆ°å¥¹ä»¬ Gmail å³ä¸Šè§’çš„æ ¡æ ‡ç¡®å®šçš„ï¼‰æˆ‘ç¬¬äºŒèŠ‚è¯¾å°±ä¸å»äº†ï¼Œä¸çŸ¥é“æˆ‘ä»¬ Princeton çš„å°åŒå­¦æ˜¯ä»€ä¹ˆæ—¶å€™ä¸å»çš„ï¼Œè¿˜æ˜¯å¥¹ä»¬éƒ½èƒ½å¬æ‡‚ã€‚ä¸è¿‡ä½ è¯´å¥¹ä»¬æœ‰å‰é™¢åŒå­¦çš„å®åŠ›ï¼Œæˆ‘æ˜¯ç»å¯¹ä¸ä¿¡çš„ã€‚","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"20FA","slug":"20FA","permalink":"https://harmonyano.github.io/tags/20FA/"},{"name":"Tsinghua","slug":"Tsinghua","permalink":"https://harmonyano.github.io/tags/Tsinghua/"}]},{"title":"C++ å¸¸è§é—®é¢˜","slug":"2020-11-29-C++-å¸¸è§é—®é¢˜","date":"2020-11-29T05:00:00.000Z","updated":"2021-09-08T20:12:12.678Z","comments":true,"path":"2020-11-29-C++-å¸¸è§é—®é¢˜/","link":"","permalink":"https://harmonyano.github.io/2020-11-29-C++-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"char ï¼š1ä¸ªå­—èŠ‚ char*(å³æŒ‡é’ˆå˜é‡): 8ä¸ªå­—èŠ‚ short int : 2ä¸ªå­—èŠ‚ intï¼š 4ä¸ªå­—èŠ‚ unsigned int : 4ä¸ªå­—èŠ‚ float: 4ä¸ªå­—èŠ‚ double: 8ä¸ªå­—èŠ‚ long: 8ä¸ªå­—èŠ‚ long long: 8ä¸ªå­—èŠ‚ unsigned long: 8ä¸ªå­—èŠ‚ I/Oè¯»å…¥å­—ç¬¦ä¸²å¯ä»¥ç”¨ scanf(&quot;%s&quot;) æˆ– getline() è¯»å…¥å­—ç¬¦ä¸”å¿½ç•¥ç©ºæ ¼å¯ä»¥ç”¨ scanf(&quot; %c&quot;)ï¼Œæ³¨æ„ %c å‰é¢çš„ç©ºæ ¼ C++ cin.ignore()çš„ç”¨æ³•è¯¦è§£ C++ cin&gt;&gt; cin.get() cin.getline() unsigned long long int scanf æ–‡ä»¶çš„è¯»å–åŠå†™å…¥: 12freopen(&quot;myfile.txt&quot;,&quot;r&quot;,stdin);freopen (&quot;myfile.txt&quot;,&quot;w&quot;,stdout); STLçš„ä½¿ç”¨ ä¸ºä»€ä¹ˆ std::vector ä¸æ”¯æŒ push_frontï¼Ÿ æŒ‡é’ˆçš„ä½¿ç”¨ æŒ‡é’ˆå˜é‡çš„ä¼ å€¼å’Œä¼ å€ C++ delete å’Œ delete []çš„åŒºåˆ« NULLå’Œnullptrçš„åŒºåˆ« ç±»ä¸ç»“æ„ä½“çš„ä½¿ç”¨ C++ä¸­ç»“æ„ä½“ä¸ç±»çš„åŒºåˆ«ï¼ˆstructä¸classçš„åŒºåˆ«ï¼‰ å®šä¹‰ç»“æ„ä½“å˜é‡åŠåˆå§‹åŒ–; ç»“æ„ä½“å®šä¹‰å˜é‡çš„ä¸‰ç§æ–¹æ³• C++æ„é€ å‡½æ•°ä»€ä¹ˆæ—¶å€™ä¼šè¢«è°ƒç”¨ C++ä¸­å¦‚ä½•å£°æ˜ä¸¤ä¸ªé€’å½’è°ƒç”¨çš„ç±»","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"https://harmonyano.github.io/tags/Logistics/"},{"name":"C++","slug":"C","permalink":"https://harmonyano.github.io/tags/C/"}]},{"title":"Python å¸¸è§é—®é¢˜","slug":"2020-11-29-Python-å¸¸è§é—®é¢˜","date":"2020-11-29T05:00:00.000Z","updated":"2021-09-08T20:11:22.815Z","comments":true,"path":"2020-11-29-Python-å¸¸è§é—®é¢˜/","link":"","permalink":"https://harmonyano.github.io/2020-11-29-Python-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"python æ•´å‹ä¸äºŒè¿›åˆ¶æ•°å€¼çš„ç›¸äº’è½¬æ¢ pyhton çš„å¼‚æˆ–ä¸ Hamming Distance Pythonä¹‹æ­£åˆ™è¡¨è¾¾å¼â€”â€”æŸ¥æ‰¾ Pythonç±»å‹å¼ºåˆ¶è½¬æ¢ Find Median of List in Python: statistics.median(list) Union of two lists: to remove all repetitions, use res = list(set().union(lst1, lst2, lst3, ...)) Sort a dictionary: dct= dict(sorted(dct.items(), key=lambda item:item[0])) to sort by keys; change to item[1] to sort by values. multi-line statements: 123total = item_one + \\ item_two + \\ item_three print a class like Javaâ€™s toString : 12345class Test: def __repr__(self): # what to display when looked at in an interactive prompt return &quot;Test()&quot; def __str__(self): # what to print when called print(Test) return &quot;member of Test&quot; Local variable in a class: Elements outside the __init__ method are static elements; they belong to the class. Elements inside the __init__ method are elements of the object (self); they donâ€™t belong to the class. 1234class MyClass: static_elem = 123 # static def __init__(self): self.object_elem = 456 # specific to eacy instance String convert string to int: How to remove the leading and trailing spaces in Python: my_string.strip() åˆå¹¶ä¸€ä¸ª String List: &quot;&quot;.join(str_lst) advanced split with re : re.split(&quot;split_on_what_in_regex&quot;, str) Extract characters from a string: &quot;&quot;.join(re.findall(&quot;[a-zA-Z]+&quot;, str)) Data Structures Queue: Python ç”¨çš„ä¸æ˜¯ enqueue dequeueï¼Œè€Œæ˜¯ put get 1234import queueq = queue.Queue()q.put(s)v = q.get() å‡½æ•°å¼ç¼–ç¨‹ pythonçš„filteråŸºæœ¬ç”¨æ³•: lst = list(filter(func, lst)), dct = dict(filter(func, dct)) python3ä¸­map()å‡½æ•°ç”¨æ³•: map(func, list) Python reduce() å‡½æ•° IO pythonå†™å…¥csvæ–‡ä»¶çš„å‡ ç§æ–¹æ³• pythonå†™å…¥csvæ–‡ä»¶çš„å‡ ç§æ–¹æ³•æ€»ç»“ python è·å–å½“å‰æ–‡ä»¶å¤¹ä¸‹æ‰€æœ‰æ–‡ä»¶å python è¯»å…¥å¤šè¡Œæ–‡ä»¶: lines = file1.readlines() NumPy Difference between max and maximum: numpy.maximum(A,B) returns the element-wise bigger one of the two numpy.max(A) returns the maximum value inside A Matrix Multiplication: np.matmul(A, B): Returns matrix product of A and B np.multiply(A, B): Returns element-wise multiplication of A and B np.dot(A, B): Returns dot product of A and B numpy.diagonal(M): Returns the diagonal of a 2-D matrix M numpy.tile(A, reps): repeats A reps times Pandas1234567891011121314# ç›´æ¥å¾ªç¯ df å¾ªç¯çš„æ˜¯ col åfor col in df: print(col)# æƒ³è¦å¾ªç¯æ¯ä¸€è¡Œçš„æ•°æ®åº”ä½¿ç”¨ iterrows()# row = (row_index: int, data: pd.Series)for row in df.iterrows(): print(row)# æƒ³è¦è¯»å–æŸä¸€è¡Œçš„æ•°æ®ä½¿ç”¨ loc[i]ï¼Œè¿”å› pd.Seriesrow0 = df.loc[0]# loc ç”¨æ¥è¿‡æ»¤æ—¶å¦‚æœæœ‰ä¸¤ä¸ªä»¥ä¸Šæ¡ä»¶ï¼šåªèƒ½ç”¨&amp;ï¼Œç”¨andä¼šæŠ¥é”™ï¼Œæ­¤å¤–ä¹Ÿè¦ç”¨åœ†æ‹¬å·æ‹¬èµ·æ¥ df.loc[ (df[&quot;att1&quot;] == &quot;012&quot;) &amp; (df[&quot;code&quot;] == &quot;2A&quot;) ] AttributeError: â€˜floatâ€™ object has no attribute â€˜splitâ€™ Mathplotlibimport import matplotlib.pyplot as plt Change where y range starts in matplotlib: plt.ylim(bottom = x) Rotate the labels in x-axis by 90 degrees: this trick helps you when you have too long x-axis labels. plt.xticks(rotation = 90 ) Different Kinds of Plot: scatter plot: plt.scatter(x,y)","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"https://harmonyano.github.io/tags/Logistics/"},{"name":"Python","slug":"Python","permalink":"https://harmonyano.github.io/tags/Python/"}]},{"title":"Latex å®ç”¨æŠ€å·§æ‰‹å†Œ","slug":"2020-11-23-Latex-å®ç”¨æŠ€å·§æ‰‹å†Œ","date":"2020-11-23T05:00:00.000Z","updated":"2021-09-05T15:01:55.613Z","comments":true,"path":"2020-11-23-Latex-å®ç”¨æŠ€å·§æ‰‹å†Œ/","link":"","permalink":"https://harmonyano.github.io/2020-11-23-Latex-%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%E6%89%8B%E5%86%8C/","excerpt":"","text":"æ’ç‰ˆå¤§æ‹¬å· ```latexf(x)=\\left{\\begin{aligned}x &amp; = &amp; \\cos(t) \\y &amp; = &amp; \\sin(t) \\z &amp; = &amp; \\frac xy\\end{aligned}\\right.123456789101112131415 $f(x)=\\left\\&#123; \\begin&#123;aligned&#125; x &amp; = &amp; \\cos(t) \\\\ y &amp; = &amp; \\sin(t) \\\\ z &amp; = &amp; \\frac &#123;x&#125;&#123;y&#125; \\end&#123;aligned&#125; \\right.$2. ```latex f(x)= \\begin&#123;cases&#125; 0&amp; \\text&#123;x=0&#125;\\\\ 1&amp; \\text&#123;x!=0&#125; \\end&#123;cases&#125; $f(x)= \\begin&#123;cases&#125; 0&amp; \\text&#123;x=0&#125;\\\\ 1&amp; \\text&#123;x!=0&#125; \\end&#123;cases&#125;$ Sections and Chapters: Usually, \\section is the top-level document command in most documents. However, in reports or books, and similar long documents, this would be \\chapter or \\part. To get an unnumbered chapter / section add an asterisk (*) at the end of the command, like \\section*.","categories":[],"tags":[{"name":"Latex","slug":"Latex","permalink":"https://harmonyano.github.io/tags/Latex/"}]},{"title":"Algorithm Design åŠ CS4820 ä¸€èˆ¬æ€§å†…å®¹æ€»ç»“","slug":"2020-10-13-Algorithm-Design-åŠ-CS4820-ä¸€èˆ¬æ€§å†…å®¹æ€»ç»“","date":"2020-10-13T04:00:00.000Z","updated":"2021-02-10T20:16:22.984Z","comments":true,"path":"2020-10-13-Algorithm-Design-åŠ-CS4820-ä¸€èˆ¬æ€§å†…å®¹æ€»ç»“/","link":"","permalink":"https://harmonyano.github.io/2020-10-13-Algorithm-Design-%E5%8F%8A-CS4820-%E4%B8%80%E8%88%AC%E6%80%A7%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/","excerpt":"CS 4820 develops techniques used in the design and analysis of algorithms, with an emphasis on problems arising in computing applications. Example applications are drawn from systems and networks, artificial intelligence, computer vision, data mining, and computational biology. This course covers four major algorithm design techniques (greedy algorithms, divide and conquer, dynamic programming, and network flow), computability theory focusing on undecidability, computational complexity focusing on NP-completeness, and algorithmic techniques for intractable problems, including identification of structured special cases, approximation algorithms, and randomization.","text":"CS 4820 develops techniques used in the design and analysis of algorithms, with an emphasis on problems arising in computing applications. Example applications are drawn from systems and networks, artificial intelligence, computer vision, data mining, and computational biology. This course covers four major algorithm design techniques (greedy algorithms, divide and conquer, dynamic programming, and network flow), computability theory focusing on undecidability, computational complexity focusing on NP-completeness, and algorithmic techniques for intractable problems, including identification of structured special cases, approximation algorithms, and randomization. Greedy AlgorithmGreedy Stays AheadGreedy is at least as good as the optimal solution in each step Exchange Argument Take any optimal solution, we can make it exactly the same as our greedy solution without having the optimal solution produce a worse result. There is some â€œstructureâ€ unique to this problem. All solutions have this â€œstructureâ€ give the same number of lateness. Our greedy solution has this â€œstructureâ€ We can exchange any optimal solution to have this â€œstructureâ€ without making this solution worse Divide and ConquerMaster theorem says that for an algorithm with running time $T(n) = aT(\\frac{n}{b}) + f(n)$. $f(n)$ is some polynomial of $n$, so we have $T(n) = aT(\\frac{n}{b}) + O(n^c)$. $a = b^c$: $T(n) = O(n^c ; logn)$ - A balance between constant work at each level and number of subproblems at each level. $a &lt; b^c$: $T(n) = O(n^c)$ - Time dominated by the constant work we do at upper levels: take $a=1$ as an extreme example, all of the time will be spent on top level. $a&gt;b^c$: $T(n) = O(n^{log_ba})$ - Time dominated by each subproblems we have as the recursion go deeper. A lot of branches of subproblems will be generated. Network Flow Max flow é—®é¢˜è½¬æ¢ä¸º Min Cut é—®é¢˜ï¼ŒMin Cut é—®é¢˜æ°¸è¿œå¯ä»¥ç»™è‡ªå·±ä¸æƒ³è¦çš„è¾¹ infinite capacity æ¥å°†å®ƒæ’é™¤åœ¨ min cut ä¹‹å¤–ã€‚ effectively infinite: ä»»ä½•ä¸€ä¸ªæ— æ³•è¾¾åˆ°çš„æ•°ï¼Œéƒ½å¯ä»¥è§†ä½œ infiniteï¼Œæ¯”å¦‚ infinite capacity å¯ä»¥æ˜¯ä¸€ä¸ªå·²çŸ¥çš„ cut å€¼+1 (max flow å¿…ç„¶å°äºä»»æ„ä¸€ä¸ª cutï¼Œæ‰€ä»¥æ²¡æœ‰ä»»ä½•ä¸€ä¸ª flow å¯ä»¥è¾¾åˆ° cut + 1) NPProving Reduction Show that your reduction Ïƒ takes polynomial time. Show that x is a solution to the problem you are reducing from if and only if Ïƒ(x) is a solution to theproblem you are trying to show is NP-hard. You need to show the implication in both directions. Proving NP, NP-Hard, NP-Completeness NP: prove you can verify a solution in polynomial time NP-hard: prove some known NP-Hard (or NP-complete) problem can be reduced to A in polynomial time (æ³¨æ„æ˜¯åˆ«çš„å·²çŸ¥é—®é¢˜å¯ä»¥è¢«è½¬æ¢æˆæˆ‘ä»¬è¦è¯æ˜çš„é—®é¢˜) NP-completeness: it is NP-hard and it is NP Important NP-Complete Problem satisfiability problems: Boolean satisfiability, CNFSAT (conjunctive normal form satisfiability) , 3CNFSAT (aka 3SAT) graph problems: Clique, Independent Set, Vertex Cover, Dominating Set, Colorability, Planar 3-colorability covering problems: Set Cover, 3-dimensional matching (3DM) tour problems: directed and undirected Hamiltonian circuit (HC), Traveling Salesperson (TSP) numerical problems: Subset Sum (SS), Partition, Knapsack, Bin Packing Tips If a problem asks you to decide if there exists a set of at least k objects satisfying some property, try reducing from another problem that involves picking at least k objects, e.g. Independent Set or Clique. Similarly, if a problem asks you to decide if there exists a set of at most k objects satisfying some property, try reducing from another problem that involves picking at most k objects, e.g. Vertex Cover or Set Cover. When reducing Independent Set / Vertex Cover to another graph-like problem. We find out adding a node representing edges is very useful. (Dominating Set, practicefsol 4, fakesol7 3) When a problem does not easily fit into either of the general categories listed above, usually the best thing to try first is 3CNFSAT. When do the reduction from A to B, try to reduce A to a special case of B. (hw5 P3 Clique -&gt; Submatrix Domination, hw6 P2 Vertex Cover -&gt; Dominating Set) Turing MachineDecidabilityGive a total Turing Machine (one that always halts) to accept any â€œyesâ€ instance and reject any â€œnoâ€ instance Undecidability Prove by Diagonalization Prove by Reduction: we usually reduce our problem to Halting Problem or the complement of it (Non-Halting Problem aka. Looping Problem). Note: Ïƒ in this case has to be computable instead of polynomial-time To prove some problem is undecidable within a certain time bound, use clocked diagonalization. Crucial FactsMinimum Spanning Tree cut property: Let A and B partitions vertices V, if e is the minimum edge connecting A and B, e must be in every minimum spanning tree. cycle property: Let C be any cycle in G, e be the maximum cost edge on that cycle, e is not in any minimum spanning tree Proof Techniques Loop Invariant and Recursion: ä¸€ä¸ªå¾ˆå¥½çš„ä¾‹å­æ˜¯ T7.42 çš„è¯æ˜ recursion = inductionloop invariant = induction hypothesistermination condition = basis computation = logic -- Dexter Kozen","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"CS4820","slug":"CS4820","permalink":"https://harmonyano.github.io/tags/CS4820/"}]},{"title":"INFO1998 Intro to Machine Learning","slug":"2020-10-02-INFO1998-Intro-to-Machine-Learning","date":"2020-10-02T04:00:00.000Z","updated":"2021-02-10T20:12:14.962Z","comments":true,"path":"2020-10-02-INFO1998-Intro-to-Machine-Learning/","link":"","permalink":"https://harmonyano.github.io/2020-10-02-INFO1998-Intro-to-Machine-Learning/","excerpt":"The goal of this course is to provide you with a high-level exposure to a wide range of Data Science techniques and Machine Learning models. From the basics of getting your Jupyter environment setup, to manipulating and visualizing data, to building supervised and unsupervised models, this class aims to give you the base intuition and skillset to continue developing and working on ML projects. We hope you exit the course with an understanding of how models and optimization techniques work, as well as have the confidence and tools to solve future problems on your own.","text":"The goal of this course is to provide you with a high-level exposure to a wide range of Data Science techniques and Machine Learning models. From the basics of getting your Jupyter environment setup, to manipulating and visualizing data, to building supervised and unsupervised models, this class aims to give you the base intuition and skillset to continue developing and working on ML projects. We hope you exit the course with an understanding of how models and optimization techniques work, as well as have the confidence and tools to solve future problems on your own. Lec2 Data ManipulationIntroduction to Pandas Series: one dimensional array DataFrame: 2-D table Filtering DataFrames: loc Cleaning-Up DataFrames: df.dropna(), df[df[&#39;Open&#39;].notnull()] (These two methods both return a new DataFrame instead of modifying the existed one) View DataFrames: head, tail, â€¦ Summary Statistics: mean, median, â€¦ describe Dealing with missing data Fill in some random info of our choice: 12#if we there is no record about which cabin he is in, we assume he is on the Top Deckdf[&#x27;Cabin&#x27;]=df[&#x27;Cabin&#x27;].fillna(&#x27;Top Deck&#x27;) Using summary statistics: fill missing entries with median or mean works well with small set Use regression and clustering: will be covered later Lec3 Data VisualizationTypes of Graphs Heatmap Correlation Plots Coloring Graphsplt.scatter(Longitude, Latitude, c=Temp.values.ravel(),cmap=plt.cm.OrRd) color a scattered plot based on values of Temp with color scheme cm.OrRd. Find more color schemes from matplotlib manual. Lec4 Linear RegressionPreparing Data12345678910from sklearn.linear_model import LinearRegressionfrom sklearn.model_selection import train_test_split# X must be a table (in case there are multiple x in y = a1*x1 + a2*x2 + ... + k)X = data[[&#x27;cost&#x27;,&#x27;compl_4&#x27;]] # Y must be one columnY = data[&#x27;median_earnings&#x27;] from sklearn.model_selection import train_test_split# test is 20% of all datax_train, x_test, y_train, y_test = train_test_split(X, Y, test_size=0.2) Predicting and Fitting12345678# creates Linear Regression model LR = LinearRegression()# note LR is an object by calling fit, we set all of its coefficientsLR.fit(x_train, y_train)# predict() returns the predicted valuey_predicted = LR.predict(x_test)# score(x,y&#x27;) first computes the predicted value y based on x and our model, then compare it with y&#x27;score = LR.score(x_test,y_test) Describing the Model12345678# Gives a comprehensive view of Y = a1*x1 + a2*x2 + ... + kLR?# coefficients of x (a1, a2, ...)LR.coef_# intercept kLR.intercept_ Lec5 Measuring Modelâ€™s AccuracyWhen determining accuracy, usually want to compare our model to a baseline. Therefore, instead of comparing our modelâ€™s prediction to each specific y value, we compare it with the mean y value. 123456from sklearn.metrics import mean_squared_errorcelcius_MSE = mean_squared_error(y_test, celcius_predictions)test_goal_mean = y_test.mean()baseline = np.full((len(celcius_predictions),), test_goal_mean)baseline_MSE = mean_squared_error(baseline, celcius_predictions) overfitting: too specific to the data given, doesnâ€™t predict any other data underfitting: no matter what data you use to train this model, it gives the same curve, so it doesnâ€™t have prediction power either because it doesnâ€™t show any pattern of the data. Lec6 ClassifiersLinear regression is used to predict the value of a continuous variable. Classifiers are used to predict categorical or binary variables. KNN12345678from sklearn.model_selection import train_test_splitfrom sklearn.neighbors import KNeighborsClassifierx_train, x_test, y_train, y_test = train_test_split(X,Y, test_size=0.2)k = 10model = KNeighborsClassifier(k) # specify k nearest elementsmodel.fit(x_train,y_train)predictions = model.predict(x_test) Lec7 Other Supervised Learning ModelsDecision Trees123from sklearn import treefrom sklearn.tree import DecisionTreeClassifiermodel = tree.DecisionTreeClassifier(max_depth=5) How to reduce overfitting? Reduce levels of trees Train multiple decision trees (maybe one for each training data) and take its average as final result Logistic RegressionValue always between 0 and 1. Accept if value higher than threshold, reject if lower. K-fold Cross ValidationRather than doing test-train split only once, we do it k times: First separate our sample into k pieces and each time we take one of them as test set, the others as training set. Use from sklearn.model_selection import KFold to achieve this. Calculate a score for each of the split and take its average as the final score. This score is usually closer to real errors. 12345678910111213141516171819202122from sklearn.model_selection import KFoldfrom sklearn.metrics import mean_squared_error, accuracy_scoreincX = inc_data[[&#x27;education.num&#x27;]]incY = inc_data[&#x27;income&#x27;]kf = KFold(n_splits = 5)accuracy = 0for train_index, test_index in kf.split(incX): X_train = incX.iloc[train_index] Y_train = incY.iloc[train_index] X_test = incX.iloc[test_index] Y_test = incY.iloc[test_index] # best_depth æ˜¯æˆ‘ä»¬å‰ä¸€é¢˜æ‰¾åˆ°çš„ä½¿åˆ†æœ€é«˜çš„ depth level of decision tree model = tree.DecisionTreeClassifier (max_depth = best_depth) model.fit(X_train, Y_train) pred_test = model.predict(X_test) accuracy += accuracy_score(Y_test, pred_test) accuracy /= 5print(accuracy) Lec9 Unsupervised Learning Supervised Learning: The desired solution (target) is also included in the dataset Unsupervised Learning: The training data is unlabeled and algorithm tries to learn by itself Hierarchical ClusteringHierarchical clustering groups observations into multiple levels of sets; the top-level set includes all of the data, and the bottom-level sets contain individual observations. The levels in between contain sets of observations with similar features. 1234567891011from sklearn.preprocessing import StandardScalerfrom scipy.cluster.hierarchy import dendrogram, linkagefrom matplotlib import pyplot as plt# Standardize features by removing the mean and scaling to unit variancedata = StandardScaler().fit_transform(data)# build our model from dataclust = linkage(data) # draw the dendrogram visulizationdendrogram(clust)plt.show() K-Means ClusteringWe want to cluster the data into k groups. We first randomly choose k points in this dataset. Then we assign other data points to the group they are closest to. After assigning all data points to some group, we recompute the center of each group by taking the means of all points in that group. Repeat this process until no points change group assignment after one iteration. 1234from sklearn import clusterk = 3kmeans = cluster.KMeans(n_clusters = k) #cluster into k groupskmeans.fit(data)","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"Python","slug":"Python","permalink":"https://harmonyano.github.io/tags/Python/"},{"name":"20FA","slug":"20FA","permalink":"https://harmonyano.github.io/tags/20FA/"}]},{"title":"Add \"Open with Windows Terminal\" to Right-Click Menu","slug":"2020-09-29-Add-Open-with-Windows-Terminalto-Right-Click-Menu","date":"2020-09-29T04:00:00.000Z","updated":"2020-10-02T12:57:07.733Z","comments":true,"path":"2020-09-29-Add-Open-with-Windows-Terminalto-Right-Click-Menu/","link":"","permalink":"https://harmonyano.github.io/2020-09-29-Add-Open-with-Windows-Terminalto-Right-Click-Menu/","excerpt":"Windows Terminal Preview now provides native support of this feature.","text":"Windows Terminal Preview now provides native support of this feature. Download the icon here Move the icon to directory C:\\Users\\&lt;your username&gt;\\AppData\\Local\\WindowsTerminal Create a .reg file and run it. 123456789Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt]@=&quot;Open with Windows Terminal&quot;&quot;Icon&quot;=&quot;C:\\\\Users\\\\&lt;your username&gt;\\\\AppData\\\\Local\\\\WindowsTerminal\\\\terminal.ico&quot;[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt\\command]@=&quot;C:\\\\Users\\\\harmo\\\\&lt;your username&gt;\\\\Local\\\\Microsoft\\\\WindowsApps\\\\wt.exe&quot; In Windows Terminalâ€™s settings, Add &quot;startingDirectory&quot; : &quot;.&quot; into defaults list: 1234&quot;defaults&quot;: &#123; &quot;startingDirectory&quot; : &quot;.&quot; &#125;, Reference How to Add Open Windows Terminal Here Option to Right-click Menu Add â€œopen Windows terminal hereâ€ to right-click context menu å°†â€åœ¨æ­¤å¤„å¯åŠ¨Windows Terminalâ€æ·»åŠ åˆ°å³é”®èœå•","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"https://harmonyano.github.io/tags/Logistics/"}]},{"title":"CS2024 C++ Programming","slug":"2020-09-07-CS2024-C++-Programming","date":"2020-09-07T04:00:00.000Z","updated":"2021-09-01T23:39:32.181Z","comments":true,"path":"2020-09-07-CS2024-C++-Programming/","link":"","permalink":"https://harmonyano.github.io/2020-09-07-CS2024-C++-Programming/","excerpt":"The goal of CS2024 is to teach as much of the C++ language as possible with an eye towards your being able to use it effectively in future classes that may depend on it and/or in a professional setting. C++ is ever changing with new standards released every three years. We look to strike a balance between making sure you thoroughly understand â€œhistoricâ€ C++ as well as introducing you to new features enabled in the language in the past decade.","text":"The goal of CS2024 is to teach as much of the C++ language as possible with an eye towards your being able to use it effectively in future classes that may depend on it and/or in a professional setting. C++ is ever changing with new standards released every three years. We look to strike a balance between making sure you thoroughly understand â€œhistoricâ€ C++ as well as introducing you to new features enabled in the language in the past decade. Lec01 IntroductionExplaining our First Program #include &lt;iostream&gt; Tells the compiler that we would like to load definitions from a header file named â€œiostreamâ€. The # (pound sign) indicates this is a preprocessor directive, it gets dealt with BEFORE your code is compiled std::cout &lt;&lt; â€œHello World!â€ &lt;&lt; std::endl; &lt;&lt; is an operator that directs content from the right to the left. In this case, we direct the string â€œHello Worldâ€ to std::cout, which is the console Compiling C++ Windows: use Visual Studio Linux: g++ -std=c++11 -lstdc++ -o demo1 demo1.cpp: -o specifies the name of the compiled file Compiler takes the text of the source code and converts it into a binary object so that it can execute it a bit more efficiently. Lec02 Input/Output and OperatorsInput and Output &gt;&gt; stream extraction operator std::cin &gt;&gt; k take a value from cin, which is the input stream keyboard, and assign it to k getline(cin,str): cin uses space as delimiter so it wonâ€™t read in a whole line. Use this to read a full line Usingusing is similar to import in java, so that you donâ€™t have to use the full name of a function when calling it. 1234567using std::cout;using std::endl;int main(int argc, char *argv[]) &#123; // No longer need to use the std:: prefix cout &lt;&lt; â€œHello Worldâ€ &lt;&lt; endl;&#125; Lec03 Introduction to ClassesStructC-Style structure definition: (Define a structure called Course, which has three fields ) 12345typedef struct &#123; string name; string instructor; int numStudents;&#125; Course; ClassesVariables defined inside that class are called member variables. Functions defined inside the class are called member functions Public vs. Privatepublic and private keywords can appear as many times as you want in the class definition. 1234567891011class Course &#123;public: // These can be seen outside the class // Define member functions int getStudentCount() &#123; return numStudents; &#125;private: // These can be seen inside the class only // Define member variables string name; string instructor; int numStudents;&#125; Declaration and Definition of Member FunctionsYou donâ€™t have to define the functions where they are declared. Instead, you can define them outside of the class declaration. When you define them outside of the class declaration, you can still access the member variables inside that class. Thatâ€™s because you are telling the compiler that this is a member function. 12345678910111213141516class Course &#123;public: // These can be seen outside the class // Define member functions int getStudentCount(); void setStudentCount(int count); private: ...&#125;string Course::getCourseName()&#123;return name;&#125;int Course::getStudentCount()&#123;return numStudents;&#125; You usually want to define your getter and setter functions inside class definition. When other functions you are trying to define are too big, we usually define them outside the class definition and usually in a separate file. So we declare the functions in header file **.h and define them in another file **.cpp 123456789101112/* &lt;Courses.h&gt; */class Course &#123;private: void complexLogic();&#125;/* &lt;Courses.cpp&gt; */#incldue &quot;Courses.h&quot;void Courses::complexLogic()&#123; ...&#125;; ConstructorsConstructors have to have the same name as the class. Constructors have no return type. You can define Constructors outside of class definition too. Constructors are called when you declare an instance of that type: MyClass instance. Note defining a pointer of that class without allocating memory to that pointer MyClass *p will not call the constructor, but declaring a pointer and allocating memory will call the constructor, because thatâ€™s the real time an instance is created MyClass *p = new MyClass(). Lec5 Functions IEnumIf you donâ€™t assign values to the ones following the first, they will all have value of previous increment 1. 12345678// Define error codesenum RonsError &#123; cNoError = 0, // Values are optional, default is 0 cBadArg, // If a value is not present, cBadResult, // assign previous value + 1 cUnknownErr&#125;; In C++11, we can use the class keyword to define sort of a â€œnamespaceâ€ for the enum. 12345678enum class Months &#123; JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC&#125;if ((month == Months::DEC) || (month &lt; Months::MAR)) ...Months get_march()&#123; return Months::MAR;&#125; Function Declaration and Definition Revisited123456789101112// mymath.h -- header file for math functionslong squareIt(long);// mymath.cpp -- implementation of math functionslong squareIt(long x)&#123; return x * x;&#125;// main.cpp#include â€œmymath.hâ€void main()&#123; cout &lt;&lt; â€œ5 squared is â€œ &lt;&lt; squareIt(5) &lt;&lt; endl;&#125; You should never include a â€œ.c++â€ file in another c++ file. Lec6 Function IIInline Functions12345inline int performAddition(int x,int y) &#123; return x+y;&#125; Wherever this function is called the compiler has the option of replacing the call with the body of the actual function, instead of creating a memory stack for that function call and etc. The compiler may not do that when itâ€™s a recursive call or that function is really long. Pass By ReferenceWhy and when do you want to use pass by reference? You need to return multiple values. C++ only allows you to return one value. So you send those values as pass by reference parameters You are passing a large structure/class. When passing values, the compiler will make a copy of those structure/class and pass them, which takes up a lot of stack space. In the second case, maybe you donâ€™t want to change anything in the structure, but passing by reference makes such a mistake likely to happen. To fix this, you can declare this passed by value as const, so when you accidentally modify it, you will get a compile-time error. 12345bool isBusy(const BIGDataType &amp;arg1)&#123; if (arg1.busyField = 0) return true; return false;&#125; Default ArgumentWhen we declare a function, we can set a default value to its argument. (Donâ€™t set a default value in function definition) 12345678910class Counter &#123; â€¦ void increment(int incrementBy=1); â€¦ &#125;;void Counter::increment(int incrementBy);&#123; mycount += incrementBy;&#125; x.increment(); // increment x by 1 y.increment(2); // increment y by 2 Unary Scope OperatorWhen you have 3 variables with the same name defined in global scope, local scope, and a nested scope inside local scope and you want to access the variable in the global scope inside some scope, you can use the :: before calling this variable. There is no way for you in the nested scope to access the variable with a same name in local scope (parent scope). 123456789int x=1; // in the global scopeint main(int argc, char *argv[]) &#123; int x = 6; // local variable to main() // cannot be accessed in the following nested scope &#123; int x = 5; // local variable in a sub-scope of main() cout &lt;&lt; â€œx is : â€œ &lt;&lt; ::x &lt;&lt; endl; // &quot;x is : 1&quot; &#125;&#125; Lec7 Function IIIFunction Templates1template &lt;typename a,typename b,â€¦&gt; return_type function_name (formal args) At compilation time the compiler will look at your code and generate a separate function for each type used throughout your code when calling template functions. For example, for this maximum below, when the compiler sees the call to maximum(3,5,8), it uses the function template to automatically generate an overloaded version of maximum() that takes three variables of type int as its arguments. 12345678910template &lt;class T&gt; T maximum(T val1, T val2, T val3)&#123; T maxValue = val1; if (val2 &gt; maxValue) maxValue = val2; if (val3 &gt; maxValue) maxValue = val3; return maxValue;&#125;return maximum(3,5,8); Lec8 Arrays and VectorsArraysArrays donâ€™t have boundary checking. 12345678910111213#include &lt;array&gt;// initializationconst int size = 5;array&lt;int,size&gt; myArray;// range based for-loopfor (int item : myArray) cout &lt;&lt; â€œNext item is: â€œ &lt;&lt; item;// sorting and searchingsort(myArray.begin(),myArray.end()); //ascending orderbool found = binary_search(myArray.begin(),myArray.end(),2); Vectors123456#include&lt;vectors&gt;vector&lt;int&gt; primeVector&#123;2,3,5,7,11,13&#125;; primeVector[6] = 17; //valid syntax but can crash the programprimeVector.at(6) = 17; //involves boundary checking and throw an error Lec9 PointersDynamic Allocation123int *iPtr; // declares a pointer to intiPtr = new int; // &quot;new int&quot; gives a dynamically allocated instance of int // then we assign this space to iPtr Note: in the above example, a memory in the heap is allocated to this pointer iPtr contains one of the following: A pointer to the newly allocated data type (in this case, an int) NULL (if the pointer could not be allocated due to insufficient memory) We should always check whether it is NULL before using a dynamically allocated pointer. We can use delete iPtr to dispose a dynamically allocated pointer. 12345int *iPtr; // iPtr points to some random memoryiPtr = new int; // iPtr points to some memory allocated to it in heap*iPtr = 5; // write 5 to the memory iPtr is allocated todelete iPtr; // release the memory assigned to iPtr / iPtr now no longer points to that memoryreturn 0; Pointers to Already Existing ValuesExisting values are in stack frame, so when our pointers point to something already existed, they point to something in the stack frame, but remember variables in stack frame can disappear when out of scope. 12345678int main()&#123; int *iPtr; if (true) &#123; int p = 5; iPtr = &amp;p; &#125; cout &lt;&lt; â€œ*iPtr is â€œ &lt;&lt; *iPtr &lt;&lt; endl;&#125; So the danger is you will have to know how long this stack frame will live, or you will lose track of what you are pointing to and end up pointing something totally irrelevant. Common Confusion with * int *p - declaring a pointer: The star is part of the type name, and says that we want a pointer to some other type (in our example, int * is the type of p). r = *p - dereferencing a pointer (RHS): The star is the dereference operator. This assignment gives the variable r a new value, namely the value inside the box that the pointer p points to. *p = r - dereferencing a pointer (LHS): The star is the dereference operator. This assignment changes the value inside the box that p points to be a new value, namely the value of the variable r. Pointer Chaos12345678910111213141516int *a = 5, *b = 7;// dereference a, get the value stored in the memory a is pointing to,// and write a same value to the memory b is pointing to *b = *a; // let b point to the same address as a is pointing tob = a; // release the memory allocated to a, // also doing that for b since they are pointing at the same thingdelete a; // throw &quot;pointer being freed is not allocated&quot; error// since we already deleted it when we did that for adelete b; Pointers to User-Defined TypesWhen we want to use member member (functions/ variables), we can use one of the following: 123Course *aCourse = new Course;(*aCourse).setStudentCount(45);aCourse-&gt;setStudentCount(45); Passing Pointers as Arguments1234567int *a = new int;int x = 5;// store 0 in the memory location pointed at by intPtrvoid setToZero(int *intPtr) &#123; *intPtr = 0; &#125; setToZero(a); // pass to it a pointer whose value is some addresssetToZero(&amp;x); // pass the address of some variable to it Const with PointersPrinciple of Least Privilege: Any operation you do should only be given the opptunity to happen if it absolutely needs to. Following this principle, we donâ€™t want to give writing privilege to functions doing reading. There are four possibilities between constant/non-constant pointers pointing to constant/non-constant data: 12345678910111213141516171819202122232425262728293031// Non-Constant Pointer, Non-Constant Data// Free for the pointer to point to something else,// Free for the data it is pointing to be written as something elseint *intPtr = new int;// Non-Constnat Pointer, Constant Data// We canâ€™t modify the data pointed at by coursePtr// We CAN set coursePtr to a different valuevoid printAllCourseData(const Course *coursePtr, const int size)&#123; // For this function, maybe we will direct pointer to some other course // once one course&#x27;s info has been printed, // while we don&#x27;t want to change that info // because this is just a reading function&#125;// Constant Pointer, Non-Consant Data// Pointer can only point to a specific memory// The data it is pointing to can be changedvoid setupCourse(Course *const coursePtr)&#123; // For this function, we only want to change information of this course passed in.&#125;// Constant Pointer, Constant Data// We canâ€™t modify the data pointed at by coursePtr// We canâ€™t set coursePtr to a different value eithervoid printCourseData(const Course *const coursePtr)&#123; // We only want to print out the info of this course passed in and do nothing else&#125; Lec10 Classic Arrays and Pointer ArithmeticClassic Array12int *j[4]; == (int *) j[4]// array of 4 pointersint (*p)[4]; // a pointer to an array of 4 integers Arrays are somewhat pointers. For example, if we have int b[10], b always points to the first element in this array: b == &amp;b[0] Pointer ArithmeticFor any array p[n] == *(p+n). In particular, *(p+n) gives the contents of we have after advancing n steps from p. In fact, we also have p[n] == n[p], because our a[m] is just a syntactic sugar for *(a+m) Dynamic Allocation of Arrays123int a1[8] = new int; // WRONGint *a = new int[8]; // RIGHTdelete [] a; // Must use this, â€delete aâ€ is undefined There are more scope issues when you use arrays as pointers. For example, the following code returns a pointer to something inside current call stack frame. It will disappear when out of the scope. Therefore, the returned pointer from function MakeArray() actually points to something undefined. 123int *MakeArray() &#123; int iArray[50]; return iArray; &#125; The following code behaves differently. Instead of returning a pointer to something in the call stack, it returns something in the heap, which will not disappear after the function finishes execution. 123int *MakeArray(int size) &#123; int *anArray = new int[size]; return anArray; &#125; Passing Arrays as ParametersSince arrays are pointers, you can only pass the real array to a function. There is no concept of passing a copy of that array. These are standard ways of declaring a function taking in arrays as its parameters. 12void swap(int *A, int j, int k);void swap(int A[], int j, int k); Memory Allocation with malloc and sizeof malloc is a function for dynamic memory allocation and it only takes in byte. sizeof(SomeDataType) returns the number of bytes this data type needs. Say we want to declare an array of 6 Courses in heap here. 12Course *courseArray = malloc(sizeof(Course) * 6); // Old C way to initialize array in heapCourse *courseArray = new Course[6]; // The C++ way to do it Lec11 Classes â€“ A Deeper Look1clang -std=c+11 -lstdc++ -c MyString.cpp Implicit InlineWhen you define a function right in the class definition, you make this function implicitly inline. Therefore, thereâ€™s no actual method/function created; the code of the method is substituted through the rest of the code wherever that method is called. Multiple ConstructorsYou can use a delegate constructors to save yourself from writing duplicate code. It will just call that constructor, if the delegate constructors take in arguments, you can just pass in those arguments there. 123456789101112131415// older c++ styleMyString::MyString(string initValue) : MyString() &#123; if (growStorage(initValue.length())) &#123; strcpy(storagePtr, initValue.c_str()) stringLength = initValue.length(); &#125;&#125;// c++ 11 styleMyString::MyString(string initValue) : MyString&#123;&#125; &#123; ... &#125;&#125;// Another ExampleMenu::Menu(MenuItem* list[], int n, char prom, string title) : MenuItem(prom, title)&#123; for (int i = 0; i &lt; n; i++) items.push_back(list[i]);&#125;; DestructorThe destructor is a special method (similar to constructor) that is called just before an object is destroyed. There is only one destructor per class (canâ€™t overload). It takes no arguments. A destructor should be used to clean up any dynamically allocated resources (memory, OS objects). You call the destructor when using delete keyword. Passing and Returning ReferencePassing ReferenceIf you modified a parameter passed by reference in a function, the change would persist in the calling function. Note that the way we call this function has not changed. We still pass in two strings instead of pointers. You donâ€™t have to do anything differently to specify that the string arguments are being passed â€œpass-by-referenceâ€ when I call the function; I only need to specify that I want to use pass-by-reference when I declare the getTimeAndTemp function. 12345678void getTimeAndTemp(string &amp;time,string &amp;temp)&#123; time = getTheREALTime(); temp = getTheREALTemp();&#125;int main() &#123; string theTime,theTemp; getTimeAndTemp(theTime,theTemp); // theTime and theTemp will be changed.&#125; Returning ReferenceWhen we add a &amp; before the function name, the function still returns whatever type it returns, but now the function call can appear on left side of assignment operator and we can write a new value to the memory address the returned value is stored in. For the following example, charAt still returns a char type. The only difference is that we can now directly change the returned value stored in the object by using the assignment operator. 123456789101112char &amp;MyString::charAt(int index) &#123; // boundary checking is omitted for clarity return storagePtr[index];&#125;int main() &#123; MyString str(â€œHello World!â€); char c =str.charAt(11); cout &lt;&lt; c; // &#x27;!&#x27; str.charAt(11) = â€˜?â€™; // legal because we are returning reference cout &lt;&lt; str.charAt(11); // &#x27;?&#x27; cout &lt;&lt; â€œstr is now: â€œ &lt;&lt; str.MakeString() &lt;&lt; endl; // Hello World?&#125; const in class As a qualifier to a member variable. It means that the member variable cannot be changed As a qualifier to a member function. It means that the member function cannot change anything in the class: 1string getName() const &#123; return mName; &#125; static in class There is ever only one copy of that variable that is shared among all the instances of the class. The storage for this variable must be declared in the global scope using the fully qualified name of the variable (classname::static_variable_name) The shared copy of the variable can be accessed either as a field of any instance or using the fully qualified name of the variable 123456789101112// &quot;Person.h&quot;class Person &#123; static int number_of_persons;&#125;// &quot;Person.cpp&quot;int Person::number_of_person = 0; // &quot;main.cpp&quot;cout &lt;&lt; Person::number_of_person; // 0Person p(&quot;Harmony&quot;); // increment number_of_person by 1 in the constructorcout &lt;&lt; p.number_of_person; // 1 this in class Its â€œtypeâ€ is pointer to class type. So, if we have a Person class, Person has an implicitly defined member variable named this that is of type Person * Any of the member variable and functions in the class can be referenced from this Lec12 Operator OverloadsUnary Operator Overloadswe just have to use the operator keyword. 1234567891011// &quot;MyString.h&quot;int operator~();std::string operator+();// &quot;MyString.cpp&quot;int MyString::operator~()&#123; return stringLength;&#125;string MyString::operator+()&#123; return MakeString(); // returns a std::string from our MyString instance&#125; Binary Operator OverloadsWe define most binary operator overloads globally when it doesnâ€™t make â€œsenseâ€ which of the two instances of the operands should â€œhostâ€ the overload. (Expressions on both ends are to some extent equal to the other) We use inline to allow us to place this in the header file without causing multiple definition errors, so we are never really â€œdefiningâ€ it, but just replace the code whenever it is called. 12345678inline MyString operator+(const MyString &amp;str1, const MyString &amp;str2) &#123; // use the overloaded unary + sign to return a std::string // then use the std::string overloaded binary + sign to concatenate two strings MyString temp( (+str1) + (+str2) ); return temp;&#125; Here we have an instance of binary overload not done globally. It is a â€œbinary operatorâ€ but only takes one argument. 123T &amp;operator[](int i) &#123; return *(mStoragePtr + i); // equivalent to return mStoragePtr[i];&#125; Copy ConstructorsWhenever we use the assignment operator to initialize a variable when it is declared, the compiler actually looks for a constructor that takes in a single argument that matches the type of the value you are assigning to the newly declared instance. If we have MyString str2 = 1;, the compiler would look for a constructor for MyString that took a single integer: MyString::MyString(int arg). If you copy constructors take in some object, it must be pass-by-reference! 123456789Point::Point(Point &amp;anotherPoint) &#123; // ...&#125;int main()&#123; Point p1(4,5); // will use our custom constructor Point p2(p1); // will use the copy constructor (just as a constructor function) Point p3 = p1; // will use the copy constructor&#125; Overloading Assignment =Rather than initialize some variable, we want now to assign a new value to an existing variable. Rather than a global function, we will define it as a member function in our class. 1234567MyString &amp;MyString::operator=(const MyString &amp;sourceStr)&#123; // convert sourceStr to a std::String with our predefined unary + // setValue takes a C++ string // return the address of this object setValue(+sourceStr); return *this;&#125; Overloading Stream Direction &lt;&lt; and &gt;&gt;123456789101112131415inline ostream&amp; operator&lt;&lt;(ostream &amp;os, MyString &amp;str) &#123; os &lt;&lt; +str; // we must always return the stream that was passed in. That allows &quot;chaining&quot;(cout&lt;&lt;a&lt;&lt;&quot;good&quot;&lt;&lt;endl;) to work return os;&#125;inline istream&amp; operator&gt;&gt;(istream &amp;is, MyString &amp;str) &#123; int allocatedSpace = str.getAllocatedSpace(); char *tempBuf = new char[allocatedSpace]; // allocate temp is.get(tempBuf,allocatedSpace-1); // read from instream into location of tempBuf [tempBuf] up to [tempBuf + allocatedSpace - 1] string tempStr = tempBuf; // convert tempBuf to a std::string str.setValue(tempStr); // set str of MyString class to be tempStr delete [] tempBuf; // delete temp memory, realease space return is; // return stream&#125; Lec13 InheritanceBasic Syntax12345678910class DerivedClass : public BaseClass&#123; &lt;member variables unique to Derived Class&gt; ...&#125;;class Student : public Person&#123; int studentID;&#125;; OverrideWe can override a function by just reimplementing it in our derived class. To access the original implementation from the base class, we use its fully qualified name in the derived class. 123456789101112void Person::printInfo()&#123; cout &lt;&lt; â€œName: â€œ &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; â€œAddr: â€œ &lt;&lt; address &lt;&lt; endl; cout &lt;&lt; â€œPhone: â€ &lt;&lt; phone &lt;&lt; endl; &#125;;void Student::printInfo()&#123; Person::printInfo(); cout &lt;&lt; â€œStudent ID: â€œ &lt;&lt; studentID &lt;&lt; endl;&#125;; Virtual FunctionsSay we overwrite the printInfo function in Person and define a global function that takes in a Person class and call the printInfo function on that class. When we pass a Student instance to it, it will actually use the printInfo function of Person instead of Student. Thatâ€™s because the compiler thinks the function just takes in a Person. 1234567void printPersonInfo(Person &amp;aPerson)&#123; aPerson.printInfo();&#125;;Student s;printPersonInfo(s); // prints out Name, Addr, Phone If you want to use the overridden version of the function, you will have to declare the function in base class as a virtual function. By defining a virtual function, we tell the compiler to call the overridden version no matter what type that instance may be cast to. However, to achieve this effect, we should also pass in an reference or pointer of instance of our derived class. Only in this way can the compiler knows what type our object was declared as. If we just pass by value (a copy of that instance), it will create a copy of our instance with whatever type specified in the function. More specifically, it calls the copy constructor of the specified class. It has no knowledge of what the original type of the argument was. 123456789class Person&#123; virtual void printInfo();&#125;void printPersonInfo(Person &amp;aPerson) // use overriden versionvoid printPersonInfo(Person *aPerson) // use overriden versionvoid printPersonInfo(Person aPerson) // use function in Person; //in fact in the last function, aPerson only has the &quot;Person&quot; part and doesn&#x27;t contain any information specific to the derived class Lec14 PolymorphismWe can dynamically allocate an instance of the derived class and store it in a base class pointer variable. Since Instructor is derived from Person, this is legal. 12Person *aPerson = new Student(); // a pointer of base class(Person) pointing to its derived class(Student)aPerson-&gt;printInfo(); // calls the overridden method in derived class Abstract ClassWe can make a function to be pure virtual (abstract) by adding a = 0 after its declaration. Any new class derived from this class must implement pure virtual methods if the class is going to work. A class with pure virtual functions is an abstract class. Virtual DestructorsIf you have an abstract class, you would need to have an abstract/virtual destructor. That is because when a derived classâ€™s destructor is called, it will (implicitly) call destructors in all base classes it inherits from as well. 12345// Person.hvirtual ~Person() &#123;cout&lt;&lt;&quot;base class destructor called&quot;&lt;&lt;endl;&#125;// Student.h~Students() &#123;cout&lt;&lt;&quot;derived class Studenet destructor called&quot;&lt;&lt;endl;&#125; Lec15 StreamSimple Stream I/O put/get: For any stream, the simplest I/O routines let you input or output one character at a time. End of File eof: a special character (usually has value -1) that signals youâ€™ve reached an end of file state. When we reach eof, we cannot read any further from the file. (Ctrl+Z on Windows, Ctrl+D on other OS) getline: pass in a whole line of characters ( read in until encountering with a \\n) When you type in â€œThisâ€ while running the following code without hitting Enter, it will not print anything, because all characters you typed in have not been sent into the buffer yet. After you hit Enter, â€œThisâ€ will be echoed back. So everything got sent into the buffer, we get one out of it each time, and put it to the outstream, repeat the process until we encounter an eof (Ctrl+Z). 1234while (!cin.eof()) &#123; char c = cin.get(); cout.put(c);&#125; Error HandlingOnce an cin attempt failed, an error flag is set and future attempts to get input will fail. Failure happens when type entered doesnâ€™t match the type of the variable you are assigning value to. cin.fail(): returns true if the last cin assignment failed. cin.clear(): repairs the stream by clearing the error flag in cin. cin.ignore(n, c): ignores the following n characters or one c character. Therefore, cin.ignore(100,&#39;\\n&#39;) ignore all input until youâ€™ve already ignored 100 of them or ignore 1 â€˜\\nâ€™ character. 123456cin &gt;&gt; id;while (cin.fail() || id&lt;0 || id&gt;99) &#123; cin.clear(); cin.ignore(99, &#x27;\\n&#x27;); cout &lt;&lt; &quot;invalid number, try again &gt; &quot;; cin &gt;&gt; id;&#125; Int Stream Manipulator dec: decimal, base 10 oct: octal, base 8 hex: hexadecimal, base 16 setbase(n): set to n base These stream manipulators are â€œstickyâ€. They will remain the format of your output (even though you start another sentence of cout), until you set another stream manipulator. 123cout &lt;&lt; oct &lt;&lt; 8; //10cout &lt;&lt; 9; // 11cout &lt;&lt; setbase(10) &lt;&lt; 16; // 16 Float Stream Manipulator fixed: print out float number in decimal/fixed point notation scientific: print out float number in scientific notation setprecision(n): always print out 3 digits after the decimal point They are all â€œstickyâ€. Youâ€™ll have to manually set it back to previous state. 123int curPrecision = cout.precision(); // current settingcout &lt;&lt; setprecision(2) &lt;&lt; 3.12545 &lt;&lt; endl; // 3.13cout.precision(curPrecision); // Restore original setting Fixed Width left: align to left, the output is padded to the field width appending fill characters at the end right: align to right, the output is padded to the field width by inserting fill characters at the beginning These two stream manipulators are sticky. We also use setw(n) to make sure at least n characters are printed. If the string to print has fewer than n characters, fill with space. If it has more than n characters, print everything. setw(n) is not sticky. Thatâ€™s because most output methods automatically calls setw(0) each time you call them. setw(n) is in the library #include &lt;iomanip&gt; . 123456789#include &lt;iomanip&gt;int n = -77, m = 13579;cout &lt;&lt; setw(6) &lt;&lt; left &lt;&lt; n &lt;&lt; endl;cout &lt;&lt; setw(6) &lt;&lt; right &lt;&lt; n &lt;&lt; endl;cout &lt;&lt; setw(2) &lt;&lt; m &lt;&lt; endl;//-77 // -77//13579 Custom ManipulatorManipulators are just globally defined functions that take an ostream reference and return an ostream reference. Following are some examples: 12345678ostream&amp; beep(ostream &amp;output)&#123; return output &lt;&lt; â€œ\\aâ€;&#125; // displaying \\a causes beepostream &amp;aReallyLongTokenForNewline(ostream &amp;output)&#123; return output &lt;&lt; â€œ\\nâ€;&#125;cout &lt;&lt; â€œThis will cause a beep: â€œ &lt;&lt; aReallyLongTokenForNewLine;cout &lt;&lt; beep; Lec16 Functional Programmingauto keywordThe auto keyword is used to declare a variable whose type is determined by the value it is initialized to. It must be initialized at the moment it is declared (or it will cause a static time compiler error). 12auto f = 3.14 // f is made a doubleauto k; // NO INITIALIZER â€“ This would be a compiler error Function PointersWhen we define a function pointer, we need to define its return type and what type of arguments it takes in: return_type (* function_name) (argument_type1, argument_type2, ...). Note: All these parameters are required. We can declare a function pointer with no allocation. We can assign it to any function that matches the argument type and return type as we do to most pointers. We can also use the C++11 style function in STL functional: std::function&lt; return_type (argument_type1, argument_type2, ...) &gt; function_name, but this is much heavier. 123456789101112131415int SimpleAdd(int arg1,int arg2)&#123; return arg1 + arg2; &#125;int main(int argc, char *argv[])&#123; int (*f)(int start,int stop); // define a function pointer that takes in two ints and returns an int f = SimpleAdd; // f now points at the function â€œSimpleAddâ€ int x = (*f)(3,4); // dereference f, get the function it points to and applies it to 3,4 int y = f(3,4); // A syntactic sugar provided. Compiler will do the dereference cout &lt;&lt; &quot; x is: &quot; &lt;&lt; x &lt;&lt; &quot;, y is: &lt;&lt; y &lt;&lt; endl; function&lt;int(int,int)&gt; g; g = simpleAdd; cout &lt;&lt; g(3,4) &lt;&lt; endl; // also gives 7 // *g(3,4) doesn&#x27;t work because g here is an std::function, not a pointer to a C-style function&#125; Function as ParameterWhen we want to pass a function as a parameter of another function, we can pass it as a C-style pointer or C++11 std::funciton . We can also use a template and let the compiler to figure it out. 12345678910void OldCallMe(int (*f)(int), int x) &#123;...&#125;void NewCallMe(std::function&lt;int(int)&gt; f, int x) &#123;...&#125;template&lt;typename T&gt;void CallMe(T fn, int x)&#123; // a syntax error will result if the fn passed in of type T doesn&#x27;t support the following line int newValue = fn(x); cout &lt;&lt; &quot;CallMe-newValue is: &quot; &lt;&lt; newValue &lt;&lt; endl;&#125; Lambda ExpressionsA lambda expression evaluates to a function pointer. It takes the following format: [vars](args) -&gt; returntype &#123; // body of function &#125;;, where return type and arrow can be omitted. 12345678910111213// Declare a lambda with the auto keyword (we don&#x27;t know what type of a function that is)// func is a function that takes no variables or arguments and simply prints out Hello Worldauto func = []() &#123; cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; endl; &#125;;// Declare a lambda with a function pointer:// func2 is a pointer to a function that takes in a string as parameter// More specifically, that function takes in a string and prints it outvoid (*func2)(string) = [](string s) &#123; cout &lt;&lt; â€œHello â€œ &lt;&lt; s &lt;&lt; endl; &#125;;// Use function template (C++11) to store lambdastd::function&lt;void(string)&gt; func3 = [](string s) &#123; cout &lt;&lt; â€œHello â€œ &lt;&lt; s &lt;&lt; endl; &#125;; Capture Local VariablesWe can use lambda expressions to capture local variables. This will be an important way to still be able to use variables in a function that no longer exists when the lambda finally gets executed. If you want to capture local variables, always use C++11 std::function when defining either the lambda expression or the function you want to take this lambda expression. 12345678void CallMe(std::function&lt;int()&gt; fn) &#123;...&#125;;// template also works because it will automatically identify fn as an std::functiontemplate&lt;typename T&gt;void CallMe(T fn) &#123;...&#125;;int myX = 300;CallMe([myX]()-&gt;int&#123; return myX*2; &#125;); You also have the option of capturing local variables by reference. That means if the lambda expression modifies them, the modifications persist back into the â€œhostingâ€ function where these variables were defined. (Just like any pass by reference function call). Pass by reference or pass a pointer will do. 12345int myX = 300; int *myY = new int; *myY = 3;CallMe([&amp;myX]()&#123; myX *= 2; &#125;);CallMe([myY]()&#123; *myY *= 2; &#125;);cout &lt;&lt; &quot;myX is &quot; &lt;&lt; myX &lt;&lt; endl &lt;&lt; &quot;myY is &quot; &lt;&lt; *myY &lt;&lt; endl; // 600 Lec17 Files I/OofstreamWe use ofstream to write to file. A constructor of ofstream takes in two arguments name of the file to open specifies which mode to use: ios::out open file for writing, overwrite existing file ios::app open file for writing, append to existing file We donâ€™t have to close the stream after writing, ofstream has a destructor that is automatically called at the end of the program. That being said, we can still call out.close() manually. We use out.is_open() to make sure the file is indeed successfully opened and ready to be written in. Directly evaluating the stream variable out itself as a boolean also does the check. 123456#include&lt;fstream&gt;ofstream out(â€œmyFileâ€,ios::out); // create an ofstream, pass in name of the file and ios::out to indicate you want to use it for outputif (out.is_open()) // make sure we successfully opend the file out &lt;&lt; â€œHello world!â€ &lt;&lt; endl;out.close(); ifstreamWe use ifstream to read from a file. 1234ifstream in(â€œmyFileâ€,ios::in);string str = &quot;Hello&quot;;if (in.is_open()) in &gt;&gt; str; Sequential FilesSuppose we have a csv file that uses comma as the delimiter and space as a record separator. If we want to change only a specific record, how are we supposed to move around in that file? tellg(): returns the offset from the beginning of the file where the next read operation will get data from. tellp(): returns the offset from the beginning of the file where the next write operation will put data to. seekg(n): sets the â€œgetâ€ offset to the nth character in the file seekp(n): sets the â€œputâ€ offset to the nth character in the file Reading and Writing at the Same TimeWhen declare an fstream variable, we can specify using multiple â€œmodesâ€ at the same time by putting the or operator | between different modes. We can then use whatever function those modes give 123fstream file(â€œages.datâ€, ios::in | ios::out) //reads and write to &quot;ages.dat&quot; at the same timestring str; file &gt;&gt; str; // read worksfile &lt;&lt; &quot;That&#x27;s good&quot;; // write also works Lec18 Standard Template LibraryIteratorbegin() points to the first element in the object. end() points to one after the last element. Common operators like + &lt; &gt; are all overloaded for iterators. 123for (vector&lt;string&gt;::iterator p = stringVector.begin(); p &lt; stringVector.end(); ++p) cout &lt;&lt; â€œNext Vector Element is: â€œ &lt;&lt; *p &lt;&lt; endl; Vector123vector&lt;string&gt;::iterator q = stringVector.begin();stringVector.erase(q+5); // erase the 6th elementstringVector.erase(q,q+5); // erase [q, q+5), so erase 1st to the 5th element MapMap is based on valuetype, which has type &lt;key, value&gt;. All operations come from this pair. We can use typedef to name some very complicated data type that is frequently used. 12345678910111213141516typedef map&lt;int,string&gt;::value_type IDRecord; // IDRecord is in fact of &quot;pair&lt;int,string&gt;&quot; typetypedef map&lt;int,string&gt;::iterator IDRecordIterator;int main()&#123; map&lt;int,string&gt; ids; IDRecord rec1(12345,&quot;Ron DiNapoli&quot;); IDRecord rec2(34564,&quot;Darpan Kaplan&quot;); ids.insert(rec1); // alway insert a key-value pair ids.insert(rec2); cout &lt;&lt; &quot;ID 34564 belongs to: &quot; &lt;&lt; ids[34564] &lt;&lt; endl; // use array-like way to access map IDRecordIterator p = ids.find(12345); // find returns the address of that entry with a matched key , returns map::end() if key doesn&#x27;t exist IDRecordIterator q = ++p; cout &lt;&lt; &quot;Next entry of ID 12345 is: &quot; &lt;&lt; (*q).second &lt;&lt; endl;&#125; Lec19 ExceptionsBasic SyntaxExceptions can be of any type. We can do throw 3.14, throw &quot;Unexpected&quot;, or throw some object. 1234567891011enum MathErr &#123; noErr, divByZero, genericOverflow &#125;;throw divByZero;try &#123; ...&#125; catch(MathErr e) &#123; ...&#125;// Orcatch(...) &#123;&#125; // catches all kinds of Exceptions Exception Object and InheritanceAs said in previous section, we can throw an object. 1234567891011121314151617181920212223242526272829class MyIndexError &#123; MyIndexError(int i,char *msg):badIndex(i),theMsg(msg)&#123;&#125; int getBadIndex() &#123; return badIndex; &#125; string getMessage() &#123; return theMsg; &#125;private: int badIndex; string theMsg;&#125;;char &amp;MyString::operator[](int index)&#123; if ((index &lt; 0) || (index &gt;= stringLength)) throw MyIndexError(index,â€Index out of boundsâ€); return storagePtr[index];&#125;class BaseException&#123;public: BaseException(string msg,int err=0):message(msg), errorCode(err)&#123;&#125; virtual string getMessage() &#123; return â€œBASE EXCEPTION: â€œ + message; &#125; int getErrorCode() &#123; return errorCode; &#125;protected: string message; int errorCode;&#125;; Lec20 Custom TemplatesBasic Syntax1234567891011template &lt;class placeholder&gt; // declare placeholdersclass SimpleClass // regular class definition&#123;public:â€¦&#125;;// define a function outside of template classvoid SimpleClass&lt;placeholder&gt;::FunctionName() &#123;...&#125;// define constructor/destructor outside of template classvoid SimpleClass&lt;placeholder&gt;::SimpleClass() â€œDefinitionâ€ template class should also be in the same .h file. Because the compiler needs to generate a separate set of member functions for each type used to create an instance of this class at compile time. That means that these definitions are needed at compile time and not at link time, so .cpp wonâ€™t enable us to actually call those functions. Non-Type ParametersWe specified a data type calls placeholder in the template class. We can also specify a constant expression when we declare a template class. This will have the same effect as setting a const value specific for that instance, except previously we couldnâ€™t assign values to const variable. 12template &lt;class storageType,int size&gt; class MyArray &#123;...&#125;template &lt;class storageType=int,int size=5&gt; class MyArray &#123;...&#125; // give a default value Lec22 STL Algorithms#include&lt;algorithm&gt; for all functions below. fill(iterator begin, iterator end, T value): take two iterators/pointers and one value. Fill every position in between with that value.: 12char *ptr = new char[10] // An array of 10 charsfill(ptr,ptr+9,â€™Aâ€™); generate(iterator begin, iterator end, function g): assigns every position in between the two iterators/pointers according to the generating function g. 1234567int nextVal() &#123; static int number = 0; return number++;&#125;int main(int argc,char *argv[]) &#123; std::vector&lt;int&gt; intVector(10); // A vector of integers std::generate(intVector.begin(),intVector.end(),nextVal);&#125; fill_n(begin,count,value): fill from begin to begin+count with specified value generate_n(begin,count,function): fill from begin to begin+count with generated value remove(begin,end,value): remove all elements == value in range from begin to end replace(begin,end,value,replaceWith): replace all elements == value in range from begin to end WITH replaceWith Lec23 Smart PointersShared PointerYou can declare multiple pointers pointing to the same thing using shared pointer and they will all be released when you release one of them, so itâ€™s safer than the classic pointer, where the pointer will hang over there. You can call the use_count() method to get how many shared pointers are out there pointing to this same thing. 123456int main(int argc,char *argv[]) &#123; shared_ptr&lt;Point&gt; pointPtr(new Point(1,2)); shared_ptr&lt;Point&gt; pointPtr2(pointPtr); cout &lt;&lt; â€œx coordinate is: â€œ &lt;&lt; (*pointPtr).x &lt;&lt; endl; cout &lt;&lt; â€œreference count is: â€œ &lt;&lt; pointPtr.use_count();&#125; Unique PointerThere is only this one pointer pointing to that thing. No other shared pointers can be created pointing to the same thing. For the same reason, use_count() is not available either. Lec24 Namespaces and C/C++ DifferencesNamespaceDeclaring NamespaceWe define a namespace by putting it inside a namespace declaration and its corresponding scope, just like what we do to a class. Whatâ€™s different is that a single namespace may span multiple files. Therefore, we can declare/define a single namespace in multiple files. 123456namespace CornellCS2024 &#123; // Defines a namespace named CornellCS2024 class MyString &#123; public: ...&#125;; class AnotherClass &#123;...&#125;&#125; Using Namespace We can use anything declared in the namespace by quoting the fully qualified name 1CornellCS2024::MyString aString; We can designate a specific class to use in the rest of the file. 12using CornellCS2024::MyString;MyString aString; We can simply state that we want to use everything declared in this namespace. Thatâ€™s what we usually do to std in small file. 12using namespace CornellCS2024;MyString aString; C/C++ Difference only supports /* block comments */ variable declarations had to appear the beginning of a scope before any other statements were encountered only has struct, no class no overloads, Namespaces, Declaring a counter variable in a loop, String type, Exceptions, Templates does not use new/delete for dynamic memory allocation/deallocation. Instead, C uses malloc() allocates memory. It needs to be given the exact number of bytes you want to dynamically allocate calloc() is the same as malloc() but initializes all allocated memory to 0 realloc() â€œgrowâ€ a dynamic allocation: basically allocates new space and copies all original memory to new space. free() releases allocated memory Lec99 From Assignments new keyword returns a pointer to an object. You donâ€™t have to use new when creating a new object. Reference 123test t = test(&quot;rrr&quot;, 8);test t(&quot;rrr&quot;, 8);test *t = new test(&quot;rrr&quot;, 8);","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"20FA","slug":"20FA","permalink":"https://harmonyano.github.io/tags/20FA/"},{"name":"CS2024","slug":"CS2024","permalink":"https://harmonyano.github.io/tags/CS2024/"}]},{"title":"Windowsä¸‹é…ç½®PostgreSQL","slug":"2020-09-05-Windowsä¸‹é…ç½®PostgreSQL","date":"2020-09-05T04:00:00.000Z","updated":"2020-10-02T12:55:09.373Z","comments":true,"path":"2020-09-05-Windowsä¸‹é…ç½®PostgreSQL/","link":"","permalink":"https://harmonyano.github.io/2020-09-05-Windows%E4%B8%8B%E9%85%8D%E7%BD%AEPostgreSQL/","excerpt":"å¦‚æœä½ åœ¨çº ç»“è¦ä¸è¦è£…ï¼Œåˆ«è£…äº†å§ï¼Œå¯¹è‡ªå·±å¥½ä¸€ç‚¹","text":"å¦‚æœä½ åœ¨çº ç»“è¦ä¸è¦è£…ï¼Œåˆ«è£…äº†å§ï¼Œå¯¹è‡ªå·±å¥½ä¸€ç‚¹ Download and Install PostgreSQL. During the process, PostgreSQL will ask you to create a username and password, the default username is â€œpostgresâ€ and password is up to you. Run the pg_env.bat under installation folder or the following env.vbs file if that bat doesnâ€™t work 1234567891011on error resume nextset sysenv=CreateObject(&quot;WScript.Shell&quot;).Environment(&quot;system&quot;) &#x27;ç³»ç»Ÿç¯å¢ƒå˜é‡çš„æ•°ç»„å¯¹è±¡Path = CreateObject(&quot;Scripting.FileSystemObject&quot;).GetFolder(&quot;.&quot;).Path&#x27;æ·»åŠ å˜é‡sysenv(&quot;PGHOME&quot;)=&quot;C:\\Hacking\\PostgreSQL&quot; &#x27;!!!change to your own directory!!!&#x27;sysenv(&quot;PGHOST&quot;)=&quot;localhost&quot;sysenv(&quot;Path&quot;)=sysenv(&quot;PGHOME&quot;)+&quot;\\bin;&quot;+sysenv(&quot;Path&quot;)sysenv(&quot;PGLIB&quot;)=sysenv(&quot;PGHOME&quot;)+&quot;\\lib&quot;sysenv(&quot;PGDATA&quot;)=sysenv(&quot;PGHOME&quot;)+&quot;\\data&quot; wscript.echo &quot;PostgreSQL Environment Variable Successfully set&quot; Initialize database by running initdb -D C:\\Hacking\\PostgreSQL\\data Start Server by running pg_ctl -D C:\\Hacking\\PostgreSQL\\data start Register a server service by running pg_ctl register -N &quot;PostgreSQL&quot; -D C:\\Hacking\\PostgreSQL\\data (If not working, run terminal as administrator) You should then be able to see a service called â€œPostgreSQLâ€ in Windows Services (Win+R services.msc) Create Database by running createdb -U postgres &lt;DatabaseName&gt; and entering the password you entered in step 1. Note it will give a â€œPassword Authentication Failureâ€ if you try createdb &lt;DatabaseName&gt; and enter the password that way. That is because PostgreSQL uses your computer username as default and no such use is registered in PostgreSQL in the first place. You have to use -U option to specify the user you want to log in as. Allow operations on database without password by changing authentication method in PostgreSQL\\data\\pg_hba.conf all from md5 to trust: (might take effect after a reboot) 12345678910# TYPE DATABASE USER ADDRESS METHOD# IPv4 local connections:host all all 127.0.0.1/32 trust (was md5)# IPv6 local connections:host all all ::1/128 trust# Allow replication connections from localhost, by a user with the# replication privilege.host replication all 127.0.0.1/32 trusthost replication all ::1/128 trust Now when we run command createdb db, we may get a message Fatel Error: User &quot;harmo&quot; does not exist. This is a similar problem as in step 6. We want to create a user called â€œharmoâ€ by running createuser -s -r -U postgres harmo. Note simply creatuser -s -r harmo will not work because the default user to use to create such a user harmo is also harmo, which doesnâ€™t exist in the first place. What a stupid logic PostgreSQL applies. Now PostgreSQL is ready to use. è¿‡äº†ä¸€å¤©æœåŠ¡å¯åŠ¨ä¸èµ·æ¥äº†ï¼ŒæŸ¥äº†ä¸€å †æ²¡æœ‰ç»“æœï¼Œæˆ‘è¿˜ç”¨ä½ å¦ˆäº†ä¸ªå—¨ï¼Œå°çˆ·ä¸€ä¸ªå‘¨æœ«å°±æ•´ä½ è¿™å‚»é€¼ç©æ„ï¼Œè‰äº†çœŸçš„æ˜¯ å¥½åƒæ˜¯å¯åŠ¨ pgAdmin ä¹‹åï¼Œåˆå¯ä»¥ç”¨äº†ã€‚åˆšåˆšå¯åŠ¨çš„æœåŠ¡æœ¬èº«å°±æ˜¯ä¸ºäº†è®© local server è¿ä½œçš„ï¼Œè€Œ pgAdmin å¯ä»¥å¸®æˆ‘ä»¬å®Œæˆè¿™ä¸ªä»»åŠ¡ã€‚äºæ˜¯æˆ‘ä»¬ç™»å½•è¿› pgAdmin å°±ç›¸å½“äºè®©é‚£ä¸ªæœåŠ¡è¿ä½œèµ·æ¥äº†ï¼Œä¹Ÿå°±å¯ä»¥æ­£å¸¸åœ¨ç»ˆç«¯ä¸­ä½¿ç”¨å‘½ä»¤äº† Reference ä¸»è¦ï¼šWindowsä¸‹åœ¨å‘½ä»¤è¡Œå®‰è£…postgresqlï¼Œå¹¶æ³¨å†ŒæˆwindowæœåŠ¡ Windowsä¸ŠPostgreSQLå®‰è£…é…ç½®æ•™ç¨‹ Windowsä¸‹Postgresqlä¸‹è½½ä¸é…ç½®æ–¹æ³• postgresql å£ä»¤ï¼š psql: è‡´å‘½é”™è¯¯: ç”¨æˆ· è®¤è¯å¤±è´¥ æœ¬æœºpsqlè®¾ç½®éœ€è¦/ä¸éœ€è¦å¯†ç  Postgres psql: è‡´å‘½é”™è¯¯: è§’è‰² â€œpostgresâ€ ä¸å­˜åœ¨","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"https://harmonyano.github.io/tags/Logistics/"},{"name":"CS4320","slug":"CS4320","permalink":"https://harmonyano.github.io/tags/CS4320/"}]},{"title":"åœ£è¯ä¹‹å»","slug":"2020-08-03-åœ£è¯ä¹‹å»","date":"2020-08-03T04:00:00.000Z","updated":"2020-10-02T12:54:18.377Z","comments":true,"path":"2020-08-03-åœ£è¯ä¹‹å»/","link":"","permalink":"https://harmonyano.github.io/2020-08-03-%E5%9C%A3%E8%AF%9E%E4%B9%8B%E5%90%BB/","excerpt":"å‰è¨€ ç»ç”±å§”å‘˜é•¿(@MitoTsukino)çš„æ¨èï¼ŒæŠŠåœ£è¯ä¹‹å»ä»æˆ‘çš„â€œæƒ³ç©çš„å¤è€Galgameâ€åˆ—è¡¨ä¸­æåˆ°äº†ç¬¬ä¸€ä½ã€‚è¡·å¿ƒæ„Ÿè°¢å§”å‘˜é•¿ã€‚ ç•¥å¸¦ç²¾ç¥æ´ç™–çš„çº¯çˆ±ç©å®¶ä¸€å®šè¦åœ¨S1å°±ç¡®è®¤ä¸‹æ¥åˆ°åº•æƒ³æ”»ç•¥è°ï¼Œä¸è¦è®©é™¤å¿ƒä»ªå¯¹è±¡ä»¥å¤–çš„äººè¿›å…¥åˆ°ä»²è‰¯ã—åŠä»¥ä¸ŠçŠ¶æ€ï¼Œä¸è¿™æ ·åšåœ¨æœ€åä¸€å¤œä½ å¿…å®šä¼šéš¾å—ä¸€ä¼š","text":"å‰è¨€ ç»ç”±å§”å‘˜é•¿(@MitoTsukino)çš„æ¨èï¼ŒæŠŠåœ£è¯ä¹‹å»ä»æˆ‘çš„â€œæƒ³ç©çš„å¤è€Galgameâ€åˆ—è¡¨ä¸­æåˆ°äº†ç¬¬ä¸€ä½ã€‚è¡·å¿ƒæ„Ÿè°¢å§”å‘˜é•¿ã€‚ ç•¥å¸¦ç²¾ç¥æ´ç™–çš„çº¯çˆ±ç©å®¶ä¸€å®šè¦åœ¨S1å°±ç¡®è®¤ä¸‹æ¥åˆ°åº•æƒ³æ”»ç•¥è°ï¼Œä¸è¦è®©é™¤å¿ƒä»ªå¯¹è±¡ä»¥å¤–çš„äººè¿›å…¥åˆ°ä»²è‰¯ã—åŠä»¥ä¸ŠçŠ¶æ€ï¼Œä¸è¿™æ ·åšåœ¨æœ€åä¸€å¤œä½ å¿…å®šä¼šéš¾å—ä¸€ä¼š ä¸ƒå’²é€¢Best Endç¬¬ä¸€æ¬¡è§é¢ä¸­6ä¸ªäººç‰©2ä¸ªç•™ç»™æˆ‘å°è±¡æœ€æ·±ï¼Œå…¶ä¸­ä¸€ä¸ªå°±æ˜¯è¢«çœ‹åˆ°å†…è£¤ä½†å´åšå‡ºäº†æƒŠäººçš„â€œæˆ‘å€’æ˜¯æ— æ‰€è°“â€è¿™ç§åæ˜ çš„ä¸ƒå’²é€¢ã€‚ä¹Ÿå¹¸äºäº†ä¸ƒå’²é€¢è¿™ç§æœ‰ç‚¹å†·é…·è€Œä¸”æ— æ‰€è°“çš„æ€åº¦ï¼Œè®©æœ¬æ¥åº”è¯¥ç¤¾ä¼šæ€§æ­»äº¡åŠ æ¯æ¬¡è§åˆ°å¥¹éƒ½è¦å¤¹ç€å°¾å·´çš„â€œæˆ‘â€ï¼Œå¯ä»¥åšç€è„¸çš®å»æ‰¾å¥¹èŠå¤©æˆ–æ˜¯åƒåˆé¥­ï¼Œç„¶åä¸€è·¯é«˜æ­ŒçŒ›è¿›åˆ° S2. ä»ç¬¬ä¸€æ¬¡è§é¢å¼€å§‹ï¼Œä¸ƒå’²çš„å½¢è±¡ç®€ç›´è¿‡äºç†æƒ³ï¼šå°æ¶é­”+é»‘çŸ­å‘+å†·é…·+è¿åŠ¨å°‘å¥³ï¼Œè®©äººæ„Ÿè§‰è¿™è§’è‰²å®Œå…¨å°±æ˜¯æˆ‘åšæ¢¦çš„æ—¶å€™ä¼šå‡ºç°çš„å½¢è±¡ã€‚åä¹‹ä¸ƒå’²å¯¹äºæˆ‘çš„å°è±¡å°±æ˜¯â€œå¹²å•¥å•¥ä¸è¡Œçš„å˜æ€å‰è¾ˆâ€ï¼Œæ¯æ¬¡æˆ‘æƒ³è¦å¹²ä»€ä¹ˆåäº‹ï¼ˆå·çœ‹æ¸¸æ³³éƒ¨è®­ç»ƒï¼Œåœ¨å›¾ä¹¦é¦†å¤§å£°è¯´è¯ï¼Œâ€¦ï¼‰ä¸ƒå’²æ€»ä¼šå‡ºç°åœ¨æˆ‘èº«è¾¹ï¼Œè®©äººä¸ç¦è§‰å¾—å¥¹å°±æ˜¯ä¸ºäº†çœ‹æˆ‘å‡ºä¸‘ä¸€ç›´åœ¨è·Ÿè¸ªæˆ‘ï¼ˆã€‚ç”šè‡³æ€‚æ¿æˆ‘æœä»è‡ªå·±çš„æ¬²æœ›ï¼Œå»å’Œé«˜æ¡¥è€å¸ˆå‘Šç™½ï¼Œå¯¼è‡´æˆ‘ç¬¬ä¸€æ¬¡çŸ¥é“ Galgame è¿˜å¯èƒ½æœ‰ä¸‰ä¸ªé€‰é¡¹å…¨æ˜¯æ­»é¡¹çš„ï¼ŒçœŸæ˜¯æ„Ÿåˆ°äº†äººä¸–é—´çš„é»‘æš—ã€‚ ç¬¬ä¸€ä¸ª attack ç›´æ¥å°±å¼€å¤§ï¼Œä¸Šæ¥å°±æ˜¯â€œå‰è¾ˆï¼Œè¿™ä¹ˆæƒ³çœ‹å°±ç»™ä½ çœ‹ä¸ªå¤Ÿå•Šâ€ï¼Œæ¿€åŠ¨çš„æˆ‘å°±å·®æŠŠæ‘‡æ†æŒ‰çƒ‚äº†ã€‚æˆ‘çœ‹ä¸Šçš„å¥³äººæœç„¶ä¸ä¸€èˆ¬ï¼Œè™½ç„¶æ˜¯æ³³è¡£ä¹Ÿä¸èƒ½ç›´æ¥æŠŠè£™å­æ€èµ·æ¥ç»™äººçœ‹å§ï¼ˆ æ”¾å­¦åçš„ attack æ›´æ˜¯è®©äººæ§åˆ¶ä¸ä½çš„æµ·è¾¹çº¦ä¼šï¼Œè™½ç„¶å†·é™ä¸€æƒ³å¯¹äºä¸ƒå’²æ¥è¯´å…¶å®å°±æ˜¯â€œå•Šï¼Œä»Šå¤©æƒ³å»æ¡åƒåœ¾äº†ï¼Œæ—¢ç„¶å‰è¾ˆè¯´æƒ³ä¸€èµ·å›å®¶çš„è¯å°±é¡ºä¾¿æ‹‰ç€ä»–å»æ¡åƒåœ¾å§â€ã€‚å³ä½¿å¦‚æ­¤ï¼Œåœ¨å¤•é˜³è¥¿ä¸‹çš„æµ·è¾¹æ¼«æ­¥ç®€ç›´æ˜¯é€¼ç€äººè‡ªçˆ†â€œæˆ‘å…¶å®å–œæ¬¢ä½ å¾ˆä¹…äº†â€ã€‚ S2æ›´æ³¨é‡æå†™ä¸ƒå’²é€¢ä½œä¸ºæ™®é€šå¥³é«˜ä¸­ç”Ÿçš„ä¸€é¢ï¼šä¸å¤ªæ“…é•¿çš„æ•°å­¦å’Œè¦ç…§é¡¾çš„å¼Ÿå¼Ÿï¼Œå…¼é¡¾å®¶åº­å’Œå­¦ä¸šçš„æ—¶å€™è¿˜æƒ³è¦å†²å‡»ä¸‹æ¸¸æ³³çš„åŒºåŸŸåæ¬¡ã€‚åœ¨äº’ç›¸äº†è§£çš„è¿‡ç¨‹ä¸­å¥¹ä¹Ÿå¯¹æˆ‘å»ºç«‹èµ·â€œè™½ç„¶éå¸¸åºŸæŸ´ä½†æ˜¯å¶å°”è¿˜æ˜¯ä¼šæœ‰ä¸€ç‚¹ç‚¹ç”¨çš„å‰è¾ˆâ€å½¢è±¡ï¼Œåœ¨åŸæ¥çš„å°å­¦è¢«æ¶ç‹—æ”»å‡»çš„å¤œæ™šï¼Œâ€œæˆ‘â€ä¸é¡¾è‡ªå·±çš„å®‰å±ä¿æŠ¤äº†ä¸ƒå’²ï¼Œä¹Ÿæ€»ç®—è®©å¥¹è§è¯†åˆ°äº†ä½œä¸ºå‰è¾ˆå¸…æ°”çš„ä¸€é¢ã€‚ S3å°±æ˜¯å„ç§è¢«ä¸ƒå’²ç©å¼„çš„æƒ…ä¾£æ—¥å¸¸äº†ï¼Œçœ‹åˆ°â€œæˆ‘â€è¿˜æ˜¯å¯¹é«˜æ¡¥è€å¸ˆä¸æ­»å¿ƒï¼Œç›´æ¥å°±å·å·è·Ÿè¸ªç€è·Ÿè¸ªè€…é«˜æ¡¥è€å¸ˆçš„â€œæˆ‘â€ï¼Œç­‰æˆ‘ä¸Šå»å¥—è¿‘ä¹çš„æ—¶å€™ç›´æ¥æ‰“æ–­ï¼Œç”œåˆ°ä¸èƒ½å†ç”œäº†ã€‚è¯è¯´ä¸è¦åœ¨è‡ªå·±ä»¥ä¸ºæ²¡äººçš„åœ°æ–¹äº²å˜´å•Šï¼Œè¢«è€å¸ˆçœ‹åˆ°ä»¥åä¸¤ä¸ªäººç»å¯¹è¦åƒå¤„åˆ†çš„ã€‚è¿™æœŸé—´ä¸ƒå’²åˆæ‹’ç»äº†åŒç­ä¸€ä¸ªç”·ç”Ÿçš„åœ£è¯é‚€è¯·ï¼Œè€Œä¸”è¯´å‡ºäº†â€œä½œä¸ºä¸€ä¸ªç”·äººæˆ‘ä¸ä¿¡ä»»ä½ â€è¿™ç§ä¼¤äººçš„è¯ï¼Œè®©äººå›æƒ³èµ·å¦‚æœé‚£å¤©å»æµ·è¾¹çš„æ—¶å€™å°±å’Œå¥¹è‡ªçˆ†çš„è¯ï¼Œç»å¯¹ä¹Ÿä¼šè¢«è¯´åŒæ ·çš„è¯ï¼Œâ€œçœŸçš„åªæ˜¯æ‹¿ä½ å½“æœ‹å‹â€è¿™ç§ã€‚ ä½†æ˜¯æ•´ä¸ª2å’Œ3æˆ‘æœ€å…³æ³¨çš„å¹¶ä¸æ˜¯è¿™äº›æ‹çˆ±æˆï¼Œåè€Œæ˜¯ä¸ƒå’²å› ä¸ºå’Œâ€œæˆ‘â€çš„å…³ç³»å‡ºç°çš„æ¸¸æ³³æˆç»©ä¸‹æ»‘ã€‚å†¢åŸå­¦å§æ›´æ˜¯ç›´æ¥æ‰¾åˆ°â€œæˆ‘â€è¯´æœ€è¿‘ä¸ƒå’²åœ¨è®­ç»ƒæ—¶ç»å¸¸å‘å‘†ï¼Œæˆç»©æœ‰æ‰€ä¸‹æ»‘ï¼Œé—®æˆ‘ä½œä¸ºæœ‹å‹çŸ¥ä¸çŸ¥é“äº›ä»€ä¹ˆã€‚æœ€ååœ¨çœé€‰ä¸­ä¸ƒå’²ä¹Ÿæ— ç¼˜åæ¬¡ï¼Œå³ä½¿è¿™æ ·è¿˜æ˜¯åšå¼ºåœ°æŒºç€é€‰æ‹©è‡ªç”±æ³³è½¬æ¸¸æ³³äºŒæˆ˜ï¼Œè™½ç„¶å†¢åŸå­¦å§è¡¨ç¤ºç†è§£è€Œä¸”è§‰å¾—å‹‡æ°”å¯å˜‰ï¼Œä½†æ˜¯ä¹Ÿä»å®é™…å¯è¡Œæ€§çš„è§’åº¦å‡ºå‘ç»™äº†â€œæˆ‘â€éå¸¸ç°å®çš„æ‹…å¿ƒã€‚è¿™æ—¶çš„ä¸ƒå’²å°±æ˜¯æ‹¼ä¸è¿‡ä½†åˆä¸æƒ³æ”¾å¼ƒï¼Œæ¯å¤©åœ¨æ¸¸æ³³æ± é‡Œæ— æ„ä¹‰åœ°æ¸¸ç€ï¼Œå”¯ä¸€èƒ½ç»™çš„å°±æ˜¯è‡ªå·±ä»åœ¨åŠªåŠ›çš„è‡ªæˆ‘å®‰æ…°ã€‚æœ€åä¹Ÿå¹¶æ²¡æœ‰äº¤ä»£æˆç»©åˆ°åº•å¦‚ä½•ï¼Œåªèƒ½å¸Œæœ›â€œæˆ‘â€è·³ä¸‹æ°´å…³å¿ƒå¥¹å¯ä»¥æˆä¸ºå¥¹èé¡ä¸æŒ¯çš„è½¬æœºã€‚ å› ä¸ºæ˜¯æ¸¸æˆï¼Œæ‰€ä»¥ä¸éœ€è¦è€ƒè™‘å¤ªå¤šç°å®çš„å› ç´ ï¼Œä½†æ²¡åŠæ³•ä¸è”æƒ³åˆ°åœ¨è¿™æ—¶å€™çš„æ‹çˆ±ä¼šå ç”¨è¶Šæ¥è¶Šå¤šäºŒäººæœ¬å°±æœ‰é™çš„ç²¾åŠ›ï¼Œå…¶ä»–äº‹ä¸šå­¦ä¹ éƒ½è¶Šå‘ä¸‹æ»‘çš„ä¸¤äººæœ€ååªæœ‰äº’ç›¸ä½œä¸ºä¾é ï¼›åˆæˆ–æ˜¯â€œæˆ‘â€ä¸Šäº†é«˜ä¸‰æ¸æ¸ä¸å†è”ç³»ï¼Œå¤§å­¦èº«å¤„å¼‚åœ°å¤±å»éŸ³ä¿¡çš„ç°å®æƒ…èŠ‚ã€‚å› ä¸ºæ˜¯æ¸¸æˆï¼Œå°±è®©å®ƒåœç•™åœ¨é‚£ä¸ªå‘ç°é€¢å®é™…ä¸Šæ˜¯ä¸ªåæ‹¥ä¸€æ•´åº§å±±çš„å¯Œå©†ï¼Œå¹¶ä¸”æˆ‘è¿˜å’Œå¯Œå©†ä¸€èµ·æ³¡äº†æ¸©æ³‰çš„å¤œæ™šå§ã€‚ çµ¢è¾»è©ä»²è‰¯ã—åºç« çš„æ—¶å€™å°±æŠŠæˆ‘æ‰“å…¥å¤§è´¤è€…æ¨¡å¼çš„å¯æ€•å¥³äººã€‚ç­çº§é‡Œçš„ç¬¬ä¸€å¹•å°±æ˜¯å› ä¸ºè¦ä¸¾è¡Œåœ£è¯åº†å…¸ï¼Œéœ€è¦æœ‰äººèƒœä»»åœ£è¯å§”å‘˜çš„å·¥ä½œï¼Œä½†æ˜¯è¿™ç§å‡ºåŠ›çš„æ´»å½“ç„¶æ²¡æœ‰äººæƒ³å¹²ï¼Œæœ€åæ˜¯ç­é•¿ä¸¾æ‰‹ç„¶åè¯´å‡ºäº†ç»å…¸çš„ç­é•¿ä¼šè¯´çš„å‘è¨€ï¼Œâ€œå•Šï¼Œå¦‚æœæ²¡æœ‰äººå¹²çš„è¯å°±æˆ‘æ¥å§ï¼Œè™½ç„¶æˆ‘ä¹Ÿä¸çŸ¥é“æˆ‘èƒ½ä¸èƒ½å¹²å¥½â€ã€‚çœŸçš„æ˜¯æˆ‘åœ¨å­¦æ ¡ä¼šå¬åˆ°çš„ç­é•¿ä¼šè¯´çš„è¯ï¼Œè€Œä¸”æ¯æ¬¡å¬ï¼Œæ¯æ¬¡éƒ½ä¼šæ¥æ°”ã€‚æ‚¨ä¸çŸ¥é“èƒ½ä¸èƒ½å¹²å¥½å°±ä¹–ä¹–åç€åˆ«å¹²ï¼Œèµ·æ¥BBä¸€é€šä¸å°±æ˜¯æƒ³æ˜¾ç¤ºä½ å¤šä¹ˆç‰›é€¼ã€‚ç„¶åé«˜æ¡¥è€å¸ˆä½œä¸ºä¸€ä¸ªä¹Ÿå¾ˆå…¸å‹çš„æ•™å¸ˆäººç‰©ï¼Œä¹Ÿå‡æ„å…³å¿ƒäº†ä¸€ä¸‹ç­é•¿â€œå¯ä»¥å—ï¼Ÿæ¯•ç«Ÿè¦å…¼ä»»ç­é•¿çš„èŒè´£â€å®é™…ä¸Šè¿™ä¸ªBå¿ƒé‡Œå¤šä¹ˆæš—çˆ½å¤§å®¶éƒ½çŸ¥é“ï¼Œç»ˆäºæœ‰ä¸ªäººåŒ–è§£äº†å°´å°¬çš„æ°”æ°›ç„¶åä½ ä¹Ÿå¯ä»¥å¼€å®Œç­ä¼šæ—©ç‚¹å›åŠå…¬å®¤äº†ä½ è¯´ä½ å¼€ä¸å¼€å¿ƒï¼Œè¿˜è¦å†åœ¨è¿™æ¥ä¸€å¥ï¼Œå°±nmç¦»è°±ã€‚æ›´ç¦»è°±çš„æ˜¯ç­é•¿è¿˜å›å¥¹ä¸€ä¸ªâ€œæ²¡å…³ç³»çš„ï¼Œç­é•¿çš„å·¥ä½œæœ€è¿‘ä¹Ÿæ…¢æ…¢ç†Ÿæ‚‰äº†â€ï¼Œæˆ‘çœ‹ä½ TMæ˜æ˜å°±æ˜¯æŠŠè‡ªå·±çš„å·¥ä½œå…¨åˆ†ç»™ä¸‹é¢çš„å‡ ä¸ªç­å§”ï¼Œè‡ªå·±è·Ÿä¸ªæ”¶ç§Ÿçš„ä¼¼çš„ç„¶åæˆå¤©åœ¨è€å¸ˆé¢å‰é‚€åŠŸå°±æ˜¯äº†ï¼Œæ¥ä¸‹æ¥çš„å°è¯æ›´æ˜¯è®©æˆ‘æ— é™å›æƒ³èµ·äº†å­¦æ ¡é‡Œçš„é‚£ä¸ªç­é•¿ï¼Œæ˜æ˜å°±æ²¡äººé€‰ç„¶åå°±èŒäº†è¿˜è¦å‘è¡¨ä¸ªæ–°å°±èŒæ¼”è®²ï¼Œä»€ä¹ˆâ€ä¸€èµ·åŠä¸€å±Šèƒ½ç•™ä¸‹å›å¿†çš„æ™šä¼šâ€œ â€è™½ç„¶ä¼šæœ‰è®¸å¤šåšçš„ä¸å¥½çš„åœ°æ–¹ï¼Œä½†æ˜¯å¸Œæœ›å¤§å®¶å¤šå¤šåŒ…æ¶µï¼Œä¸€èµ·åŠªåŠ›â€œï¼Œå°±å·®ä¸€è¾¹è¯´è¿˜è¦ä¸€è¾¹å›è¿‡å¤´æ¥çœ‹çœ‹åŒå­¦å®Œäº†ä»¥åé ä¸ªèº¬äº†ã€‚ç¬¬ä¸€æ¬¡è§é¢æ›´åŠ ç¦»è°±ï¼Œæˆ‘è¦æ‰¾å¥¹äº¤ä¸ªä¸œè¥¿ï¼Œçœ‹äº†æˆ‘çš„æœªæ¥å¿—æ„¿è¡¨ä»¥ååˆåœ¨é‚£fufuçš„ç¬‘ï¼Œä½ è§‰å¾—æˆ‘æ¢¦æƒ³ä¹Ÿå¥½å¿—æ„¿ä¹Ÿç½¢ä¸åˆ‡å®é™…æ‚¨å¯ä»¥å·ç€ç¬‘æ€ä¹ˆç¬‘æˆ‘éƒ½æ²¡æ„è§ï¼Œåˆ«å½“ç€æˆ‘é¢è¯´æˆ‘å¿—æ„¿å¾ˆæœ‰æ„æ€å¥½å—ï¼Ÿä½ æ˜¯å†…å¿ƒæœ‰å¤šç¼ºå®‰å…¨æ„Ÿæ‰èƒ½æ¯«ä¸è‡ªçŸ¥åœ°å½“é¢å˜²ç¬‘åˆ«äººçš„å¿—æ„¿ï¼Ÿä¸€èˆ¬æ¥è¯´ç´§æ¥ç€ä¸‹ä¸€ä¸ªäº‹ä»¶å°±æ˜¯ä½ çœ‹è§é«˜æ¡¥è€å¸ˆåœ¨æ„Ÿå¹çµ¢è¾»å·¥ä½œæ•ˆç‡ä¹‹é«˜ï¼Œç„¶åç­é•¿åˆåœ¨è€å¸ˆé¡ºåŠ¿é¢å‰è£…é€¼ï¼Œâ€œå“å‘€å…¶å®ä¹Ÿæ²¡é‚£ä¹ˆå‰å®³å•¦â€ï¼Œæˆ‘åªè¦å¬ä½ è¯´ä¸¤å¥è¯å°±èƒ½æ„Ÿå—åˆ°ä½ å¿ƒé‡Œå¤šå‚²ï¼Œå’±å°±åˆ«æè¿™è£…äº†è¡Œå—ï¼Ÿ å…¶å®ç­é•¿è¶Šè®©æˆ‘æ°”ï¼Œå°±è¯´æ˜è¿™è§’è‰²åˆ»ç”»å¾—è¶Šå¥½ï¼Œå› ä¸ºå¥¹è®©æˆ‘æƒ³åˆ°äº†ç­é‡Œçš„é‚£ä¸ªå¥³äººã€‚æˆ–è€…è¯´å¥¹çƒ¦äººåˆ°è®©æˆ‘æ„Ÿè§‰å¥¹å°±æ˜¯é‚£ä¸ªå¥³äººã€‚è´¤è€…ä¹Ÿä¸æ˜¯å…¶ä»–çš„ï¼Œåªæ˜¯è§‰å¾—çµ¢è¾»è©å¤ªçœŸäº†ï¼Œåƒæ˜¯çœŸåœ¨æˆ‘èº«è¾¹çš„äººï¼Œè€Œæˆ‘ä¹Ÿæ›¾åœ¨è¿™ä¸ªç°å®ä¸–ç•Œçš„Galgameé‡Œæ‹…ä»»è¿‡èƒŒæ™¯æ¿ä»¥å¤–çš„ä¸»è¦è§’è‰²ã€‚å…¶å®æœ‰â€œç­é•¿â€åœ¨çš„ç­ï¼Œæ— éå°±ä¸¤ç§äººã€‚ä¸€ç§çŸ¥é“ç­é•¿åˆ°åº•æœ‰å¤šæ¶å¿ƒçš„äººï¼Œæå°åœˆå­æ’æŒ¤å¥¹ï¼›å¦ä¸€ç§æ˜¯ä¸æ˜çœŸç›¸çš„åƒç“œç¾¤ä¼—ï¼Œåªä¼šè§‰å¾—ç­é•¿å¾ˆå‰å®³ã€‚æ— è®ºå“ªä¸€æ“äººéƒ½ä¸å¯èƒ½æˆä¸ºç­é•¿çš„æœ‹å‹ï¼Œå¥¹çš„ â€œæœ‹å‹â€ï¼Œç”¨å¥¹è‡ªå·±çš„è¯è¯´ï¼Œä¸è¿‡æ˜¯â€œä¸ºäº†åˆ©ç›Šå›´ç»•åœ¨å¥¹èº«è¾¹ç½¢äº†â€ã€‚ åœ£è¯èŠ‚æ…¢æ…¢è¿‘äº†ï¼Œå¤©æ°”è½¬å‡‰ï¼Œç­é•¿ä¸å·§åœ°æ„Ÿå†’äº†ã€‚æˆ‘ï¼Œä¸€ä¸ªGalgameç”·ä¸»ï¼Œæˆäº†å”¯ä¸€ä¸€ä¸ªå»æ¢æœ›ç­é•¿çš„äººã€‚å…¶å®æ— è®ºæ˜¯ä¸æ˜¯Galgameï¼Œå¦‚æœæˆ‘ä¸å»çš„è¯ï¼Œéƒ½ä¸ä¼šæœ‰äººå»ã€‚å› ä¸ºæˆ‘æ€»æ˜¯ä¸èƒ½æŠŠçµ¢è¾»å’Œé‚£ä¸ªç­é•¿åˆ†å¼€æ¥çœ‹ï¼Œå‡è‹¥æ˜¯ç°å®ä¸­ï¼Œæˆ‘æ˜¯ç»å¯¹ä¸å›å»ç®¡çš„ã€‚åªæ˜¯å› ä¸ºæ˜¯Galgameï¼Œæ‰€ä»¥â€œæˆ‘â€æ‰ä¼šåšå‡ºå»è¿™ä¸ªå†³å®šã€‚ å”¯ç‹¬ä¸æƒ³å¯¹é‚£ä¸ªäººè¯´è°ã€‚ ç­é•¿æ˜¯ä¸ªåå‡ å¹´æ¥éƒ½ç”Ÿæ´»åœ¨è‹¦ä¸­çš„å¥³å­©ã€‚å¯¹äºå¥¹æ¥è¯´ï¼Œä¸éœ€è¦èœœç“œåŒ…æ¥å“å°åˆ°ç”œå‘³ï¼Œåªæ˜¯å–èœœç“œåŒ…è½¦æ—è½ä¸‹çš„é›ªèŠ±çš„å‘³é“ï¼Œä¹Ÿè¶³å¤Ÿç”œäº†ã€‚è¿™ç¬¬ä¸€æ¬¡çš„ç”œå‘³å¥¹å¯ä»¥è®°å¾ˆä¹…ã€‚ä¸€ç›´ä»¥æ¥è¡ŒåŠ¨å°±æ˜¯ä¸ºäº†è¾¾åˆ°ç›®çš„çš„å¥¹è¿™ä¸€æ¬¡å‘æˆ‘è¿™ä¸ªå’Œå¥¹å®Œå…¨ä¸ç†Ÿçš„äººè¢’éœ²äº†è‡ªå·±æœ€å¤§çš„ç§˜å¯†ï¼šâ€å…¶å®æˆ‘ä¸€ç›´åœ¨è£…ä¹–â€ã€‚å¤©ä¸‹æ— æ•Œçš„å‡é¢ä¼˜ç­‰ç”Ÿçš„é˜²å¾¡è†œç ´äº†ï¼Œåªæ˜¯å› ä¸ºä¸€ä¸ªæœ€ç®€å•çš„æ¢æœ›ã€‚ æ¥ä¸‹æ¥çš„S3ä¸æ˜¯æˆ‘â€œæ”»ç•¥â€ç­é•¿ï¼Œè€Œæ˜¯ç­é•¿è‡ªæˆ‘æ”»ç•¥è€Œä¸”é¡ºå¸¦ç€æ”»ç•¥æˆ‘ã€‚åæœŸçš„æ•´ä¸ªå‰§æƒ…é‡Œï¼Œç­é•¿è¿˜æ˜¯åƒä»¥å¾€é‚£æ ·éœ¸é“ï¼Œå¨é€¼åˆ©è¯±ç¾ä¹Ÿé—®å‡ºæˆ‘çš„ç”Ÿæ—¥å’Œå–œæ¬¢çš„ä¸œè¥¿ï¼Œå•æªåŒ¹é©¬èµ´ä¼šå¸‚è®®å‘˜ï¼Œæˆ‘é—®å¥¹æ—¢ç„¶ä¸€ä¸ªäººèƒ½å¹²ä¸ºä»€ä¹ˆè¦å¸¦ç€æˆ‘æ¥ï¼Œå¥¹å´å¯¹æˆ‘è¯´ï¼šâ€œä½ åªè¦äººæ¥å°±å¥½äº†â€ã€‚ ä»²è‰¯ã—çº¿åœ¨æˆ‘å¿ƒç›®ä¸­æ˜¯ Best Endï¼Œå› ä¸ºè¿™æ˜¯æœ€é€‚åˆç­é•¿çš„å‰§æƒ…ã€‚å¦‚æœæˆ‘ä¸å»ç¢°è§¦ç­é•¿çš„è¯ï¼Œå¥¹ä¼šæ°¸è¿œä¸€ä¸ªäººèµ°ä¸‹å»ï¼Œå¦‚æœè¢«åˆ«äººå›´æ”»çš„è¯ï¼Œä¼šåƒåœ¨å¦ä¸€æ¡çº¿é‡Œé‚£æ ·å­¤ç«‹æ— æ´ã€‚è€Œä¸”å³ä½¿æˆ‘æˆä¸ºäº†ç­é•¿çš„é‚£ä¸ªâ€œå¯ä»¥ä¾é çš„äººâ€ï¼Œæˆ‘å…¶å®å¹¶æ²¡æœ‰å¯¹å¥¹äº§ç”Ÿä»€ä¹ˆå¤ªå¤§çš„å½±å“ï¼Œå¥¹è¿˜æ˜¯é‚£æ ·éœ¸é“ï¼Œé‚£æ ·è‡ªç«‹ã€‚æœ€åä¸€å¹•çš„æ—¶å€™ï¼Œå¥¹å¯¹æˆ‘è¯´æˆ‘æ˜¯â€œæ‰“å¼€å¿ƒé—¨çš„é’¥åŒ™â€ï¼Œæˆ–è®¸è¿™æ ·ä¸€ä¸ªå¤–åœ¨æ–‡æ­¦åŒå…¨ï¼Œå†…åœ¨å¯ä»¥å¦ç„¶é¢å¯¹è‡ªå·±çš„å§”å‘˜é•¿ï¼Œæ‰æ˜¯é‚£ä¸ªå¤©ä¸‹æ— æ•Œä¼˜ç­‰ç”Ÿçš„å®Œå…¨ä½“å§ã€‚ Best Endè™½ç„¶è¿™ä¸ªçº¿æ˜¯æˆ‘å¿ƒä¸­çš„ True Endï¼Œä½†æ˜¯è¿™ä¸ªçº¿çš„S1å…¶å®ä¹ŸæŒºç¦»è°±çš„ã€‚å°±æ˜¯æˆ‘æ¯å¤©éƒ½ä¸ºç­é•¿å½“å·¥å…·äººï¼Œç„¶åæˆåŠŸåœ°å¼•èµ·äº†ç­é•¿çš„æ³¨æ„è€Œå·²ã€‚ç»†æƒ³çš„è¯ï¼Œå…¶å®å’Œä»²è‰¯ã—çº¿ä¸€æ ·ï¼Œéƒ½æ˜¯ç­é•¿ä»æ¥æ²¡è¢«åˆ«äººæä¾›è¿‡å¸®åŠ©è¿™ä¸ªæƒ…èŠ‚ä½œç¥Ÿã€‚è¿™æ¡çº¿è¿›å…¥ S2 ä»¥åèƒ½å¤Ÿçªç„¶æ„Ÿè§‰åˆ°åˆ¶ä½œç»„åœ¨è¿™æ¡çº¿ä¸ŠèŠ±äº†å¤§ç¬”å¢¨ï¼Œè®©ç­é•¿ä¸æ„§ä¸ºåœ£è¯ä¹‹å»çš„å°é¢äººç‰©ã€‚ ç­é•¿æ˜¯ä¸€ä¸ªä¸å–œæ¬¢æ°´æ—é¦†çš„äººï¼Œå¥¹è§‰å¾—æ°´æ—é¦†æ˜¯â€œæƒ³æŠŠç¾ä¸½çš„ä¸œè¥¿åªæŒæ¡åœ¨è‡ªå·±æ‰‹ä¸­çš„â€æµ…è–„çš„è‡ªæˆ‘ä¸»ä¹‰ï¼›å¥¹æ¸´æœ›ä¸¤ä¸ªäººèƒ½å¤Ÿæ¿€å‘å‡ºå¯¹æ–¹å¿ƒä¸­æ½œåœ¨ä¼˜ç‚¹çš„æ‹çˆ±ï¼Œé„™å¤·åªæ˜¯äº’ç›¸æ’’å¨‡çš„å…³ç³»ï¼›ä½†æ˜¯å¥¹åŒæ—¶ä¹Ÿå®³æ€•æ‹çˆ±ï¼Œå®³æ€•â€œè‡ªæˆ‘è¢«é‡æ–°å¡‘é€ â€ã€‚å¥¹å¯¹æ„Ÿæƒ…çš„æ¸´æœ›æ˜¯æœ€ç†æƒ³åŒ–çš„ï¼Œè¿æ¥å¥¹çš„å´æ˜¯æœ€ç°å®çš„ä¸€æ®µæ„Ÿæƒ…ã€‚åœ¨S2çš„ç»“å°¾ï¼Œå¥¹åªæ˜¯å› ä¸ºæˆ‘å…ˆå»æ‰¾äº†å…„å¼Ÿè€Œä¸æ˜¯å…ˆæ‰¾å¥¹è€Œå´©æºƒï¼Œæˆ‘æƒ³è¿™æ˜¯ç­é•¿ä»æœªæƒ³è¿‡è‡ªå·±ä¼šåšå‡ºæ¥çš„äº‹ï¼Œå¥¹ä¸€è¾¹å“­ä¸€è¾¹æŠ±ç€æˆ‘è¯´å¥¹ä¸æƒ³è¿™æ ·ï¼Œâ€œç¥ˆæ±‚ä»–äººçš„å®‰æ…°çš„è¯ï¼Œå°±æ²¡æ³•è‡ªå·±ç‹¬ç«‹æ”¯æ’‘ä¸‹å»äº†ã€‚â€ ç­é•¿å¸Œæœ›çš„äºŒäººç›¸äº’é¼“åŠ±ï¼Œä¸€èµ·è¿›æ­¥æˆé•¿çš„å…³ç³»æ²¡æœ‰å‡ºç°ï¼Œå¥¹æ‰€é™·å…¥çš„åè€Œæ˜¯è‡ªå·±ä¸€ç›´ä¸é½¿çš„å¯¹å¦ä¸€ä¸ªäººçš„æ— é™ä¾èµ–ã€‚ä¸€è´¯æ•é”çš„ç­é•¿æ„è¯†åˆ°ï¼Œè‡ªå·±å·²ç»è¢«å…³å¿ƒä»–äººçš„æƒ…æ„ŸæŸç¼šè€Œä¸”æ— æ³•é€ƒè„±ï¼Œäºæ˜¯èªæ˜çš„å¥¹é€‰æ‹©æ¥å—ã€‚æˆ‘çš„å­˜åœ¨ä¼šå¯¹å¥¹é€ æˆå½±å“ï¼Œâ€œæˆ‘â€æ˜¯å¥¹ç”Ÿæ´»ä¸­æœ€ä¸å¯æ§çš„å› ç´ ï¼Œå¦‚æœæˆ‘ç¦»å»ï¼Œå¥¹ä¼šä¸çŸ¥æ‰€æªï¼Œç„¶è€Œå¥¹ä¹Ÿå¯¹äºè¿™ç§å¯èƒ½æ€§æ— èƒ½ä¸ºåŠ›ï¼Œå› ä¸ºæƒ…æ„Ÿæ˜¯ä¸€ç§å¾ˆè™šå¹»çš„ä¸œè¥¿ï¼Œä¸èƒ½è¢«é‡åŒ–ï¼Œä¸èƒ½è¢«æ¨ç†ã€‚æ‰€ä»¥å¥¹æƒ³æŠŠä¸¤ä¸ªäººè¿æ¥èµ·æ¥ï¼Œæ‰€ä»¥â€œæˆ‘æŠŠè‡ªå·±çŒ®ç»™ä½ â€ã€‚ æ‰€ä»¥ï¼Œæˆ‘æŠŠè‡ªå·±çŒ®ç»™ä½  S3æ˜¯å†…å¤–åŸæœ¬éƒ½æ— å¯åŠ¨æ‘‡çš„ç­é•¿ä¸€ç‚¹ç‚¹åœ°å˜å¾—æ•æ„Ÿï¼Œå˜å¾—æŸ”å’Œã€‚åœ£è¯èŠ‚é©¬ä¸Šå°±åˆ°äº†ï¼Œå¯æ˜¯å› ä¸ºè®°æ¨ç­é•¿çš„äººæé¬¼ï¼Œå¸‚é‡Œä¸‹æ¥é€šçŸ¥ï¼Œåœ£è¯æ ‘å¸‚é‡Œç»Ÿä¸€å‘æ”¾ï¼Œå­¦æ ¡æ— æƒå‚ä¸äº†ã€‚ç­é‡Œä¸€ä¸‹åˆç‚¸äº†é”…ï¼Œåœ£è¯å§”å‘˜ç»„ä»£ç†ç»„é•¿è‚¯å®šç¬¬ä¸€ä¸ªèƒŒé”…ï¼Œå°¤å…¶æ˜¯èº«å…¼æ•°èŒè¿˜è¦æˆå¤©å’Œâ€œæˆ‘â€è…»åœ¨ä¸€èµ·ï¼Œç»å¯¹éš¾è¾å…¶å’ã€‚è¦æ˜¯ä»¥å‰ï¼Œç­é•¿è‚¯å®šä¼šå‘åŒå­¦ä»¬é èº¬èµ”ç¤¼é“æ­‰ï¼Œæ‰¿è®¤è‡ªå·±å·¥ä½œçš„å¤±èŒï¼Œä¸ç®¡æ˜¯ä¸æ˜¯è‡ªå·±çš„é”™è´£ä»»å…ˆæ½ä¸‹æ¥ï¼Œé¥¼å…ˆç”»å¥½ï¼Œåé¢å†æŠŠä»‡äººè®°åˆ°å°æœ¬æœ¬ä¸ŠæŠ¥å¤ã€‚ä½†æ˜¯æ‹çˆ±ä¸­çš„ç­é•¿å®Œå…¨å˜äº†ä¸ªäººï¼Œåœ¨ç­é‡Œé¢é«˜å–Šè´¨ç–‘å¥¹çš„åŒå­¦ï¼Œå˜²è®½ä»–ä»¬éƒ½é«˜ä¸­ç”Ÿäº†ä¸€ç‚¹æ¨æ–­èƒ½åŠ›éƒ½æ²¡æœ‰ï¼Œåªä¼šäººäº‘äº¦äº‘è§é£ä½¿èˆµï¼Œé€ è°£éƒ½ä¸ä¼šé€ ï¼Œè‡ªå·±ä»€ä¹ˆæ´»ä¸å¹²ä½†æ˜¯è´¬ä½å‡ºåŠ›çš„äººå€’æ˜¯å‹¤å¿«ï¼Œä¸€è¾¹è®¥ç¬‘ç€ä¸€è¾¹å®£å¸ƒâ€œä»Šå¹´çš„åœ£è¯è€å¨˜ä¸ä»…è¦åŠå¥½ï¼Œè¿˜è¦ç»™ä½ ä»¬å®‰ä¸€ä¸ªæ¯”å¾€å¹´æ›´å¤§çš„åœ£è¯æ ‘â€ã€‚å…¶å®ç­é‡Œé¢äººæ—©å°±çœ‹å¥¹ä¸çˆ½ï¼Œç”¨ç­é•¿çš„è¯è¯´ï¼Œæœ¬æ¥å°±æ˜¯ä¸ºäº†åˆ©ç›Šèšåœ¨èº«è¾¹çš„äººï¼Œç°åœ¨ä¸€æƒ³ï¼šä½ éƒ½è·Ÿæˆ‘ä»¬ç¿»è„¸äº†ï¼Œæˆ‘ä»¬ä¹Ÿä¸è—ç€æ–ç€äº†ã€‚æ¥ä¸‹æ¥çš„å‡ å¤©ï¼Œç­é•¿ä¸€ä¸ªäººåƒé¥­ï¼Œä¸€ä¸ªäººå»å›¾ä¹¦é¦†ï¼Œä½“è‚²è¯¾åˆ†ç»„ä¹Ÿå˜æˆäº†å…¨ç­æ‰€æœ‰å¥³ç”Ÿå¯¹å¥¹ä¸€ä¸ªäººï¼Œè¢«æˆ‘é—®èµ·æ¥çš„æ—¶å€™ï¼Œå¥¹è¿˜ç¬‘ç€è·Ÿæˆ‘è¯´â€œæˆ‘åŸæœ¬å°±æ²¡ä»€ä¹ˆæœ‹å‹çš„å“¦ï¼Œå’Œç°åœ¨ä¸€æ ·ä¸€ç›´æ˜¯ä¸€ä¸ªäººã€‚â€ ç­é•¿æœ€åç”¨è‡ªå·±çš„ä»£ç†ç»„é•¿ä½ç½®ï¼Œæ¢æ¥äº†å­¦æ ¡å¯¹åœ£è¯æ ‘çš„é€‰æ‹©æƒã€‚æœ‰çš„æ—¶å€™è§‰å¾—çœ‹æ‡‚ç­é•¿äº†ï¼Œä½†å¥½åƒåˆè¯»ä¸é€ï¼Œä¸€ä¸ªæ€»æ˜¯æƒ³ç€è‡ªå·±èƒ½è·ä»€ä¹ˆåˆ©çš„äººï¼Œåˆ°åº•ä¸ºä»€ä¹ˆå†³å¿ƒä¸ºåŒå­¦å’Œæ•´ä¸ªç¤¾åŒºåŠè¿™ä¸ªåœ£è¯æ™šä¼šå‘¢ï¼Ÿå¹³å®‰å¤œï¼Œå¥¹æ‹¿ç€å¤‡ç”¨é’¥åŒ™æ‹‰æˆ‘è¿›æ ¡èˆï¼Œåœ¨åœ£è¯æ ‘ä¸‹å‘Šè¯‰æˆ‘ï¼Œç°åœ¨å¥¹çš„ç›®æ ‡æ˜¯ä¸ºèƒ½ç•™åœ¨æˆ‘èº«è¾¹è€ŒåŠªåŠ›ï¼Œå› ä¸ºæˆ‘çš„å­˜åœ¨å¯¹å¥¹æ¥è¯´æ¯”ä»»ä½•ä¸œè¥¿éƒ½é‡è¦ã€‚å¯èƒ½è®¸ä¹…ä¹‹åï¼Œæˆ‘ä»¬ä¸åœ¨ä¸€èµ·ï¼Œå¥¹ä¼šä¸ºè‡ªå·±æ›¾è¯´è¿‡è¿™æ ·çš„è¯è€Œè§‰å¾—å¥½ç¬‘ï¼Œä½†æ˜¯åœ¨é‚£ä¸€åˆ»çµ¢è¾»è©æ˜¯è®¤çœŸçš„ã€‚åœ¨é‚£ä¸ªç¬é—´ï¼Œå¥¹æ„¿æ„æ”¾å¼ƒè‡ªå·±çš„ä¸€åˆ‡ï¼Œå°†è¿™æ—¶åˆ»å®šä½ï¼Œå¥¹æ˜ç™½ï¼Œå¥¹éœ€è¦æˆ‘çš„æ”¯æ’‘æ‰èƒ½èµ°å¾—ä¸‹å»ã€‚ ç­é•¿å˜äº†ï¼Œèƒ½å¤Ÿå‹åˆ¶ä½è‡ªå·±æ‰€æœ‰æ¬²æœ›çš„ç­é•¿æ— æ³•æŠ‘åˆ¶ä½åœ°æƒ³å’Œâ€œæˆ‘â€åœ¨ä¸€èµ·ã€‚è¿™å¤§æ¦‚æ˜¯æœ€çœŸå®çš„æ‹çˆ±ï¼Œæœ€æ·±æƒ…çš„å»å§ã€‚ åè®°ä¸ƒå’²é€¢æ˜¯æ¢¦ä¸­çš„ç†æƒ³å¥³å‹ï¼Œè€Œçµ¢è¾»è©åœ¨æˆ‘çš„è„‘å­é‡Œåƒé‚£ä¸ªäººï¼Œæˆ‘çœŸæ­£çš„ç­é•¿ï¼Œè¿˜æœ‰æˆ‘è‡ªå·±çš„ä¸€ä¸ªæ‚ç³…ï¼Œæ‰€ä»¥ç­é•¿è¿™ä¸ªè§’è‰²æ˜¾å¾—å¼‚å¸¸çœŸå®ã€‚éšç€æ¸¸æˆçš„æ·±å…¥ï¼Œæˆ‘è§‰å¾—æˆ‘å˜å¾—æ›´ç†è§£ï¼Œæ›´åŒ…å®¹äº†ï¼Œå³ä½¿æ˜¯å½“æˆ‘å›æƒ³èµ·æˆ‘å’ŒåŸæ¥é‚£ä¸ªåæ¶ä¸èµ¦çš„ç­é•¿çš„æ•…äº‹æ—¶ï¼Œæˆ‘è„‘æµ·é‡Œçš„ç¬¬ä¸€ä¸ªæƒ³æ³•ä¹Ÿå˜æˆäº†â€œå…¶å®æˆ‘å½“æ—¶ä¹Ÿæœ‰è®¸å¤šä¸å¯¹çš„åœ°æ–¹â€ã€‚æˆ–è®¸æ˜¯å¥½äº‹å§ åœ¨é—®é—®é¢˜çš„æ—¶å€™å¶å…¥äº†åœ£è¯ä¹‹å»çš„è´´å§ï¼Œå§é‡Œé¢è¿˜æœ‰å‡ ä¸ªæ´»è·ƒçš„äººä¸€ç›´åœ¨ç»™åˆ«äººè§£ç­”ç€é—®é¢˜ï¼Œå½“æˆ‘çœ‹åˆ°è¿™ä¸ªè´´å§é™¤äº†ç­”ç–‘å¸–æ²¡ä»€ä¹ˆåˆ«çš„ä¸œè¥¿æ—¶ï¼Œæ‰ä¼šæ„è¯†åˆ°è¿™åŸæ¥æ˜¯ä¸€æ¬¾10å¹´å‰çš„æ¸¸æˆï¼Œå…¶ä»–æ²¡æœ‰å®ƒå‡ºåçš„PSPæ¸¸æˆï¼Œä¸‹è½½é“¾æ¥æ—©å°±å¤±æ•ˆäº†ï¼›è€Œå½“ä½ æ‰¾åˆ°ä¸€ä¸ªå¯ä»¥ç”¨çš„ä¸‹è½½é“¾æ¥æ—¶ï¼Œä½ ä¼šæƒŠè®¶çš„å‘ç°åŸæ¥è¿™ä¸ªä¸–ç•Œä¸Šè¿˜å­˜åœ¨ç›´é“¾ä¸‹è½½è¿™ç§ä¸œè¥¿ï¼Œä¸€ä¸ª1Gçš„æ¸¸æˆï¼Œè·‘æ»¡å¸¦å®½å‡ ç§’é’Ÿå°±å®Œæˆäº†ã€‚æˆ‘äºæ˜¯æ‰è§‰å¾—åœ¨å‡ å¹´é—´ï¼Œäº’è”ç½‘çš„ç¯å¢ƒç«Ÿç„¶å˜å¾—å¦‚æ­¤ä¹‹å¿«ï¼Œå¥½åƒæˆ‘å¯¹ä¸€åˆ‡ä¸œè¥¿çš„è®¤çŸ¥éƒ½åœç•™åœ¨5,6å¹´å‰ï¼Œæˆ‘ä¹Ÿæƒ³åˆ°å°±åœ¨3å¹´å‰è¿˜æ´»è·ƒçš„é‚£ä¸ªåŒ¿åç‰ˆï¼Œåœ¨é‚£é‡Œæ›¾ç»æœ‰ä¸€ç¾¤å’Œæˆ‘å‡ ä¹æœ‰ç€ä¸€æ ·çˆ±å¥½çš„äººï¼›4å¹´å‰çš„vtuberï¼Œæ˜¯ä¸€ä¸ªå°ä¼—åˆ°ä¸èƒ½åœ¨å°ä¼—çš„è¯é¢˜ï¼›5å¹´å‰çš„vocaloid chinaï¼Œæ˜¯åˆ›ä½œè€…ä»¬æœ€ç§¯æçš„ä¸€ä¸ªæ—¶ä»£â€¦ å­¦ç”Ÿç”Ÿæ´»ç¦»æˆ‘è¿œå»ï¼Œè¿äº’è”ç½‘æœ€ç»ˆä¹Ÿå°†æˆ‘æŠ›å¼ƒã€‚","categories":[],"tags":[{"name":"Game","slug":"Game","permalink":"https://harmonyano.github.io/tags/Game/"}]},{"title":"Kinect as Web Cam","slug":"2020-06-24-Kinekt-as-Web-Cam","date":"2020-06-24T04:00:00.000Z","updated":"2020-06-24T04:55:23.561Z","comments":true,"path":"2020-06-24-Kinekt-as-Web-Cam/","link":"","permalink":"https://harmonyano.github.io/2020-06-24-Kinekt-as-Web-Cam/","excerpt":"é«˜äºŒå‡é«˜ä¸‰æš‘å‡å‚åŠ å¤ä»¤è¥è®©æˆ‘ç™½å«–çš„ Kinect2ï¼Œå¤§æå°ç”¨å½“åšç½‘ç»œæ‘„åƒå¤´æ¥ç”¨","text":"é«˜äºŒå‡é«˜ä¸‰æš‘å‡å‚åŠ å¤ä»¤è¥è®©æˆ‘ç™½å«–çš„ Kinect2ï¼Œå¤§æå°ç”¨å½“åšç½‘ç»œæ‘„åƒå¤´æ¥ç”¨ ä¸‹è½½ Kinect For Windows SDK 2.0ï¼Œä¸‹è½½åˆ«äººå¼€å‘çš„ FullFastKinectCamV2 ver. 2.2ï¼Œç”¨å°±å®Œäº‹äº† ReferenceKinectCamV2 for Kinect V2","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"https://harmonyano.github.io/tags/Logistics/"}]},{"title":"2020 ç½‘ç»œæ—¥å¿—","slug":"2020-06-09-2020-ç½‘ç»œæ—¥å¿—","date":"2020-06-09T04:00:00.000Z","updated":"2021-02-10T20:11:40.340Z","comments":true,"path":"2020-06-09-2020-ç½‘ç»œæ—¥å¿—/","link":"","permalink":"https://harmonyano.github.io/2020-06-09-2020-%E7%BD%91%E7%BB%9C%E6%97%A5%E5%BF%97/","excerpt":"","text":"A cartoon intro to DNS over HTTPS: HTTP, DNS, DNS over HTTPS ç®€ä»‹ (ä¸­æ–‡ç‰ˆ 1 2) VS Codeä¸Šä¹Ÿèƒ½ç©è½¬Jupyter Notebook ä»€ä¹ˆæ˜¯ç”Ÿæˆå‡½æ•°ï¼Ÿ: æœ‰è‡ªå¸¦æ•°å­¦å…¬å¼çš„dpfç‰ˆï¼Œæ¥æºä¸ºè±†ä¸ç½‘ã€‚å…¶ä¸­ç¬¬ä¸‰é¡µç»“å°¾å¼å­åº”ä¸º $g(x)+xg(x) = \\frac{g(x)}{x} - 1$, æ­¤æ®µç»“å°¾ï¼ˆåœ¨ç¬¬å››é¡µå¼€å¤´ï¼‰çš„å¼å­åº”ä¸º $g(x) = \\frac{-x}{x^2+x-1}$. IDMä½¿ç”¨æŠ€å·§","categories":[],"tags":[{"name":"ç½‘ç»œæ—¥å¿—","slug":"ç½‘ç»œæ—¥å¿—","permalink":"https://harmonyano.github.io/tags/%E7%BD%91%E7%BB%9C%E6%97%A5%E5%BF%97/"}]},{"title":"Cornell 20SP æ€»ç»“","slug":"2020-05-27-Cornell-20SP-æ€»ç»“","date":"2020-05-27T04:00:00.000Z","updated":"2020-08-04T09:54:02.815Z","comments":true,"path":"2020-05-27-Cornell-20SP-æ€»ç»“/","link":"","permalink":"https://harmonyano.github.io/2020-05-27-Cornell-20SP-%E6%80%BB%E7%BB%93/","excerpt":"CS3110 Data Struct &amp; Functional ProgrammingRanting When you find yourself saying, â€œI donâ€™t know,â€ be sure to follow it up with â€œ - but Iâ€™ll find out.â€ Itâ€™s a great way to admit what you donâ€™t know, but then take responsibility like a pro. â€“ The Pragmatic Programmer, Ch2. The Cat Ate My Source Code","text":"CS3110 Data Struct &amp; Functional ProgrammingRanting When you find yourself saying, â€œI donâ€™t know,â€ be sure to follow it up with â€œ - but Iâ€™ll find out.â€ Itâ€™s a great way to admit what you donâ€™t know, but then take responsibility like a pro. â€“ The Pragmatic Programmer, Ch2. The Cat Ate My Source Code â€‹ Nate Foster å®Œç¾è¯ é‡Šäº†å¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹ï¼Œå½“ä½ é—®ä»– XXX ä»€ä¹ˆæ—¶å€™æå®Œï¼Œ XXX ä¸ºä»€ä¹ˆè¿˜æ²¡ä¸Šä¼ ï¼ŒXXX æ˜¯ä¸æ˜¯å‡ºé”™äº†çš„æ—¶å€™ï¼Œä»–æ€»èƒ½å‘Šè¯‰ä½  â€œIâ€™ll look into itâ€, â€œI donâ€™t know but Iâ€™ll get it done by todayâ€, â€œI have another meeting coming up, but you can come to my office hour to talk about thatâ€ (å½“ä½ çœŸå»äº†çš„è¯ä»–ä¼šå’Œä½ è¯´ä»–æ¥ä¸‹æ¥åˆæœ‰å¦ä¸€ä¸ªäº‹è¦å¤„ç†å¹¶éå¸¸ç¤¼è²Œåœ°è¯·ä½ æ»š)ã€‚ç½‘ä¸Šçš„æ‰€æœ‰è¯„ä»·éƒ½æ˜¯ Both 3110 professors are amazingï¼Œå¹¶ä¸” reddit ä¸Šç»å¸¸æœ‰äººæ„Ÿè°¢ Fosterï¼Œå°±å·®èµç¾ Foster èƒœè¿‡ä»–äº²çˆ·çˆ·äº†ã€‚ä¸çŸ¥é“æ˜¯ Foster ç»™äº†è¿™äº›äººå¥½å¤„ï¼Œè¿˜æ˜¯ Foster è‡ªå¯¼è‡ªæ¼”ï¼Œæˆ‘å’Œ 19FA å’¨è¯¢çš„ä¸€å TA æ„è§æ˜¯ç›¸åŒçš„ï¼šâ€Clarkson is more organized than Fosterâ€. æˆ‘è™½ç„¶æ²¡æœ‰ä¸Šè¿‡ Clarkson çš„3110ï¼Œä½†æ˜¯æˆ‘è§‰å¾—å†å·®ä¹Ÿä¸ä¼šå·®åˆ°å“ªé‡Œå»äº†ã€‚è¦ä¸æ˜¯ SP çš„ 3410 è®²å¸ˆå¤©æ°”å‹ºè¯„ä»·æ›´å·®ï¼Œæˆ‘ç»ä¸é€‰ SP ä¸Š 3110ã€‚ â€‹ ä¸çŸ¥é“æ˜¯ä¸æ˜¯è®¡ç®—æœºé™¢éƒ½æœ‰çš„é—®é¢˜ï¼šè®²ä¹‰å†™çš„å®åœ¨å¤ªå¥½äº†ä»¥è‡³äºä¸Šè¯¾ä¸å¦‚è‡ªå·±çœ‹è®²ä¹‰ã€‚ä½†æ˜¯ Myers è®²çš„ç¯ç¯ç›¸æ‰£ï¼ŒFoster åˆ™æ˜¯å¼•å…¥äº† iclicker ä»¥å¼ºåˆ¶ä½ åœ¨ä¸€ä¸ªå¯ä»¥å®¹çº³ 300 ä¸ªäººçš„æ•™å®¤é‡Œä¸Šè®¡ç®—æœºè¯¾æ—¶ç¦æ­¢ä½¿ç”¨è®¡ç®—æœºï¼Œè€Œæ˜¯çœ‹ç€ä»–ç°åœº debug è‡ªå·±æœ¬åº”åœ¨è¯¾å‰ debug å¥½çš„ demo ä»£ç ã€‚Foster è¿™å­¦æœŸå”¯ä¸€çš„ç”¨å¤„å¤§æ¦‚å°±æ˜¯è§£ç­”äº†æˆ‘å…³äºçº¢é»‘æ ‘çš„é—®é¢˜ (å½“ç„¶äº†ä¸¥æ ¼æ¥è¯´ä¸æ˜¯ä»–è§£ç­”çš„ï¼Œè¿™ä¸ªæˆ‘å£ä¸­çš„æœ€å¤§ç”¨å¤„å…¶å®å°±æ˜¯æˆ‘é—® â€œä¸ºä»€ä¹ˆ OCaml å¯ä»¥å‡ åè¡Œå®ç°å…¶ä»–è¯­è¨€å‡ ç™¾è¡Œçš„ä»£ç ï¼Œæ˜¯ä¸æ˜¯å› ä¸º OCaml çš„ pattern matching å‡å°‘äº†å¾ˆå¤šæŒ‡é’ˆæ“ä½œâ€ï¼Œä»–å›ç­”äº†ä¸ª â€œYes, you can say thatâ€ è€Œå·²) Assignment A0: æŸä¸€ä¸ª Consultant è¯´æˆ‘æŠŠæœ€åä¸€ä¸ªå‡½æ•° tail-recursive Fibonacci çš„ä¸¤ä¸ªå˜é‡æå€’å·´äº†ï¼Œäºæ˜¯æˆ‘æŠŠå®ƒæ­£äº†è¿‡æ¥ï¼Œè¿™é¢˜0åˆ†ã€‚ä¸€ä¸ªmedianä¸ºæ»¡åˆ†çš„å°çƒ­èº«ï¼Œæˆ‘å¾—äº†å‡ ä¹ä¸¤ä¸ª deviation ä½äº medianã€‚appealçš„ç»“æœä¹Ÿæ˜¯ä¸ç»™æˆ‘åˆ†ï¼ŒåŸå› æ˜¯æˆ‘çš„ spec é‡Œé¢ä¸¤ä¸ªå˜é‡çš„é¡ºåºæ˜¯æ­£ç¡®çš„ã€‚ä½ è¯´è¿™TMä¸æ˜¯åºŸè¯å—ï¼Œå› ä¸ºå½“æ—¶æ”¹çš„æ—¶å€™å¿˜æ”¹specäº†å‘—ã€‚å°±å› ä¸ºè¿™ä¸ªä½œä¸šæäº†æˆ‘çš„å¿ƒæ€æ‰€ä»¥æˆ‘åé¢å¯¹ Foster å’Œè¿™é—¨è¯¾ä¸€ç›´å°è±¡ä¸å¥½ã€‚ A3: å†™äº†Maplewoodâ€¦ A5: sxyåˆæ•‘äº†æˆ‘ä¸€å‘½ï¼Œè¯´å®è¯æˆ‘ä¸€ç›´åˆ°å†™å®Œéƒ½ä¸çŸ¥é“è‡ªå·±åœ¨å†™ä»€ä¹ˆã€‚è¿™ä¸ªä½œä¸šå®Œå…¨æ˜¯è¢«sxyå¸¦çš„ Projectåšäº†ä¸€ä¸ªè¿˜è›®å¥½ç©çš„äºŒåˆ†æ³•è§£ä»»æ„ä¸€å…ƒå‡½æ•°çš„å¯ç¼–ç¨‹è®¡ç®—å™¨ã€‚ CS2802 Discrete Structures (Honors) - So letâ€™s think about some applications of graph in real life. Say who is the most influential person in this class. - You, professor! - â€¦ Yeah, of course. â€‹ Joe Halpern æ˜¯ä¸ªéå¸¸å¥½ç©çš„è€å¤´ï¼Œé™¤äº†æœ‰çš„æ—¶å€™è¯¾ä¸Šæ‰¯å¤ªå¤šçš„ä¾‹å­ä»¥è‡³äºè®²ä¸å®Œè¯¾ä»¥å¤–ï¼Œè¿™æ˜¯ä¸€å ‚è¦æ˜¯æœ‰æ—¶é—´è®²å®Œå›¾è®ºå°±å®Œç¾äº†çš„è¯¾ã€‚ä»ä¸€å¼€å§‹çš„æ—¶å€™å¿…é¡»æ¯æ¬¡éƒ½å» OH å†™å‡ºæ¥è¯æ˜ (å°¤å…¶æ˜¯æŸä¸€æ¬¡çš„ inductive definition of transitive closure)ï¼Œåˆ°æœ€åæŸä¸ªä½œä¸šè‡ªå·±ç‹¬ç«‹å®Œæˆäº† â€œWe know M accepts A, WTS A* is regular (accepted by some automata)â€ ç„¶åè¿™ä¸ªé¢˜è¿˜æ‹¿äº†æ»¡åˆ†ï¼Œåˆ‡å®çš„æ„Ÿè§‰åˆ°è‡ªå·±è¿˜æ˜¯å­¦äº†äº›æœ‰ä¸€èˆ¬é€‚ç”¨æ€§çš„ä¸œè¥¿çš„ã€‚ MATH3110 Introduction To Analysisâ€‹ å› ä¸ºæŸäººé€‰çš„è¿™è¯¾ï¼Œä¸´èµ°å‰è¯·æ•™äº†åˆ˜æ™“ä¸œï¼Œä»–å®³æ€•è¿™èŠ‚è¯¾ä¼šéš¾æ‰€ä»¥å»ºè®®æˆ‘åªæ˜¯æ—å¬ä½†ä¸è¦ä¸Šï¼Œå“å¾—æˆ‘è¿™å­¦æœŸæ²¡å†å¤šé€‰è¯¾ï¼Œç»“æœä¸èƒ½è¯´å®Œå…¨ä¸éš¾ï¼Œä½†æ˜¯æ¯” 2802 è¿™ä¸ª 3 å­¦åˆ†çš„è¯¾æ•´ä½“æ¥è¯´èŠ±çš„æ—¶é—´å°‘ã€‚å†ä¹Ÿä¸ä¿¡åˆ˜æ™“ä¸œäº†ï¼Œç¬¬ä¸€å­¦æœŸä¸´èµ°å‰è¿˜è·Ÿæˆ‘è¯´åˆ«æŠŠå¤šå…ƒå¾®ç§¯åˆ†è€ƒæ‰ï¼Œæœ€åæˆ‘è¿˜æ˜¯è€ƒæ‰äº†( â€‹ åšå®šä¸‹æ¥é€‰è¿™é—¨è¯¾è¿˜æœ‰ä¸€ä¸ªåŸå› æ˜¯ä¸Šå­¦æœŸçš„çº¿æ€§ä»£æ•°é‡‘ç‰Œè®²å¸ˆ Meyer åœ¨è®²ï¼Œè¿™å­¦æœŸè·Ÿå¥¹ä¸Šäº†ä¸€ä¸ªå­¦æœŸæ„Ÿè§‰è™½ç„¶æœ‰çš„æ—¶å€™è¯¾ä¸Šè®²ä¸å¤ªåˆ°ç‚¹å­ä¸Š (Meyer ä¸‹å­¦æœŸè¦å» Carleton äº†ï¼Œå“­å“­)ã€‚è§£é‡Šçš„ä¸æ˜¯å¾ˆæ˜ç™½ä»¥å¤–ï¼Œæ•´ä¸ªè¯¾ä¸‹æ¥éå¸¸æœ‰ç»„ç»‡æ€§ã€‚å¦ä¸€åè®²å¸ˆæ³•å›½ä½¬ Saloff-Coste è™½ç„¶è¯¾è®²å¾—çœŸä¸æ€ä¹ˆæ ·ï¼Œä½†æ˜¯ OH ç‰¹åˆ«æœ‰ç”¨ï¼Œè®©äººä¸ç¦ç–‘æƒ‘ OH çš„æ—¶å€™è®²å¾—è¿™ä¹ˆå¥½ä¸ºä»€ä¹ˆè¯¾èƒ½è®²å¾—è¿™ä¹ˆçƒ‚ã€‚ CS2043 UNIX Tools and Scriptingâ€‹ è®²çš„ä¸œè¥¿éƒ½å¾ˆæœ‰ç”¨å¾ˆæœ‰æ„æ€ï¼Œä½†æ˜¯è¿™è€å¸ˆå®å±ä¸è¡Œï¼Œå°±çº¯å¿µ PPT WRIT1380 FWS: Elements of Acad Wtgâ€‹ ä¸ºäº†æˆç»©èƒ½é«˜ç‚¹åˆæ°´äº†ä¸€å¹´ FWSï¼Œæ¯”å»å¹´å·®è¿œäº†ï¼Œè¿™è€å¸ˆæ²¡æœ‰Brad èƒ½æ‰¯çš®ä¹Ÿæ²¡ä»–æœ‰æ„æ€ï¼Œä½œä¸šè¿˜æ¯” Brad å¤šã€‚ä¸è¿‡ç¡®å®æ•™äº†ç‚¹æœ‰ç”¨çš„å†™ä½œæŠ€å·§","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"20SP","slug":"20SP","permalink":"https://harmonyano.github.io/tags/20SP/"}]},{"title":"Mutability","slug":"2020-03-03-Mutability","date":"2020-03-03T05:00:00.000Z","updated":"2020-08-04T09:31:25.468Z","comments":true,"path":"2020-03-03-Mutability/","link":"","permalink":"https://harmonyano.github.io/2020-03-03-Mutability/","excerpt":"From Textbook: Mutability","text":"From Textbook: Mutability RefsSyntax123ref x!xx := e ref x: creates a reference using the ref keyword (let x = ref 0 creates a location in memory whose contents are initialized to 0) !x: dereferences x and returns the contents of the memory location x := e: is an assignment. It mutates the contents x to be 1. Note that x itself still points to the same location (i.e., address) in memory. Variables really are immutable in that way. What changes is the contents of that memory location. Memory is mutable; variable bindings are not. Counter12345678910111213let next_val = let counter = ref 0 in fun () -&gt; incr counter; !counterlet next_val_broken = fun () -&gt; let counter = ref 0 in incr counter; !counter next_val_broken () = 1 ... 1 ... 1next_val () = 1 ... 2 ... 3 ... Look at how these two functionsâ€™ results differ. In the first example, counter is just a temporary variable later bound to the fun() -&gt; ... Therefore, counter will not be initiated every time we call next_val . It is evaluated only when the first time it is defined. Sequencing1e1; e2; ... ; en The sentence above evaluates each one of ei in order from left to right, returning only vn. If the values vi previous expression ei evaluates to are not of type unit, the compiler will give you a warning because it makes no sense to throw away those values. To get rid of the warning (if youâ€™re sure thatâ€™s what you need to do), thereâ€™s a function ignore : &#39;a -&gt; unit in the standard library. Using it, ignore(2+3); 7 will compile without a warning. Of course, you could code up ignore yourself: let ignore _ = (). This is a syntactic sugar of let _ = e1 in e2 Equality Physical Equality (==,!=): same address Structural Equality (=,&lt;&gt;): same content Mutable Fields (in Record)Syntax123456789(* declare a record with mutable field *)type point = &#123;x:int; y:int; mutable c:string&#125;let p = &#123;x=0; y=0; c=&quot;red&quot;&#125;(*mutate the field of that record*)p.c &lt;- &quot;white&quot;p.x &lt;- 3# Error: The record field x is not mutable Mutable StackArrays and LoopsArrays Array creation: [|e0; e1; ...; en|] Array indexing: e1.(e2) Array assignment: e1.(e2) &lt;- e3 Loops12345678910while e1 do e2 donelet i = ref 0while !i&lt;=2 do print_endline(string_of_int v.(!i)); incr i donefor x=e1 to e2 do e3 donefor x=e1 downto e2 do e3 donefor i=1 to 2 do print_endline(string_of_int v.(i)) donefor i=2 downto 0 do print_endline(string_of_int v.(i)) done while loops terminate when e1 becomes false for loops execute once for each integer from e1 to e2 for..to loops evaluate starting at e1 and incrementing x each iteration; for..downto loops evaluate starting at e1 and decrementing x each iteration","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"CS3110","slug":"CS3110","permalink":"https://harmonyano.github.io/tags/CS3110/"},{"name":"20SP","slug":"20SP","permalink":"https://harmonyano.github.io/tags/20SP/"}]},{"title":"Specifications","slug":"2020-02-18-Specifications","date":"2020-02-18T05:00:00.000Z","updated":"2020-08-04T09:34:25.510Z","comments":true,"path":"2020-02-18-Specifications/","link":"","permalink":"https://harmonyano.github.io/2020-02-18-Specifications/","excerpt":"From Textbook: Specifications and Abstractions Specification of Functions123456(** [f x] is ... Example: ... Requires: ... Raises: ... *)let f x =","text":"From Textbook: Specifications and Abstractions Specification of Functions123456(** [f x] is ... Example: ... Requires: ... Raises: ... *)let f x = Returns: Donâ€™t write Returns: ..., instead, just use [f x] is ... Requires: specific conditions on input Requires: [x &gt;=0] Raises: what the program will do if a bad input is given Raises: xxx Exception if [x&lt;0] Examples: give an example input and output of the function to better explain what it does Specification of ModulesWhat to document in a module: functions not specified in the interface abstraction function representation invariant 1234567891011121314151617181920212223242526(* Implementation of sets as lists without duplicates. * Includes rep_ok checks. *)module ListSetNoDupsRepOk : Set = struct (* Abstraction function: the list [a1; ...; an] represents the * set &#123;a1, ..., an&#125;. [] represents the empty set &#123;&#125;. * * Representation invariant: the list contains no duplicates. *) type &#x27;a set = &#x27;a list let rep_ok (l : &#x27;a set) : &#x27;a set = List.fold_right (fun x t -&gt; assert (not (List.mem x t)); x :: t) l [] let empty = [] let mem x l = List.mem x (rep_ok l) let add x l = rep_ok (if mem x (rep_ok l) then l else x :: l) let rem x l = rep_ok (List.filter ((&lt;&gt;) x) (rep_ok l)) let size l = List.length (rep_ok l) let union l1 l2 = rep_ok (List.fold_left (fun a x -&gt; if mem x l2 then a else x :: a) (rep_ok l2) (rep_ok l1)) let inter l1 l2 = rep_ok (List.filter (fun h -&gt; mem h l2) (rep_ok l1))end note that the above code keeps representation invariant, abstraction function, and other spec about implementation details inside the module definition, because when we generate the docs of this module, everything outside the definition of the module will be come â€œpublicâ€ specs for clients and everything inside will become â€œprivateâ€ spec for maintainers. Abstraction FunctionAbstraction function maps valid concrete values to abstract values 1234567891011121314151617(** AF: ... *)module ListSetDups : Set = struct (* AF: the list [a1; ...; an] represents the * smallest set containing all the elements a1, ..., an. * The list may contain duplicates. * [] represents the empty set. *) type &#x27;a set = &#x27;a list ... module ListSetNoDups : Set = struct (* AF: the list [a1; ...; an] represents the set * &#123;a1, ..., an&#125;. [] represents the empty set. *) type &#x27;a set = &#x27;a list ... Representation InvariantRepresentation Invariant distinguishes valid concrete values and from invalid concrete values and is the implicit part of all the precondition and postcondition. 1234567(** RI: ... *)module ListSetNoDupsRepOk : Set = struct (* RI: the list contains no duplicates. *) type &#x27;a set = &#x27;a list ... Common MistakesSome common mistakes include not stating enough in preconditions, failing to identify when exceptions will be thrown, failing to specify behavior at boundary cases, writing operational specifications instead of definitional and stating too much in postconditions. Long Variable Name1234let number_of_zeros_in_the_list = fold_left (fun (accumulator:int) (list_element:int) -&gt; accumulator + (if list_element=0 then 1 else 0)) 0 the_listin ... Code using such long names is verbose and hard to read. Instead of trying to embed a complete description of a variable in its name, use a short and suggestive name (e.g., zeroes), and if necessary, add a comment at its declaration explaining the purpose of the variable.","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"CS3110","slug":"CS3110","permalink":"https://harmonyano.github.io/tags/CS3110/"},{"name":"20SP","slug":"20SP","permalink":"https://harmonyano.github.io/tags/20SP/"}]},{"title":"Code Reuse with Modules","slug":"2020-02-13-Code-Reuse-with-Modules","date":"2020-02-13T05:00:00.000Z","updated":"2020-08-04T09:34:53.202Z","comments":true,"path":"2020-02-13-Code-Reuse-with-Modules/","link":"","permalink":"https://harmonyano.github.io/2020-02-13-Code-Reuse-with-Modules/","excerpt":"From Textbook: Code Reuse with Modules IncludesDef: includes enables a structure to include all the values defined by another structure, or a signature to include all the names declared by another signature.","text":"From Textbook: Code Reuse with Modules IncludesDef: includes enables a structure to include all the values defined by another structure, or a signature to include all the names declared by another signature. Syntax1234567891011module type SetExtended = sig include Set (*all other definitions specific to SetExtended*) val of_list : &#x27;a list -&gt; &#x27;a tendmodule ListSetDupsExtended = struct include ListSetDups (*all other definitions specific to SetExtended*) let of_list lst = List.fold_right add lst emptyend Encapsulation1234567891011121314module ListSetDupsImpl = struct type &#x27;a t = &#x27;a list let empty = [] let mem = List.mem let add x s = x::s let elts s = List.sort_uniq Stdlib.compare sendmodule ListSetDups : Set = ListSetDupsImplmodule ListSetDupsExtended = struct include ListSetDupsImpl let of_list lst = lstend The important change is that ListSetDupsImpl is not sealed, so its type &#39;a t is not abstract. Plus, OCaml compiler can infer it is an implementation of Set .When we include it in ListSetDupsExtended, we can therefore exploit the fact that itâ€™s a synonym for &#39;a list. The clients should use ListSetDups, but when we use List to implement other things, we should use ListSetDupsImpl instead. Includes vs. Open1234567891011121314151617181920module M = struct let x = 0endmodule N = struct include M let y = x + 1 let z = 1endmodule O = struct open M let y = x + 1 let z = 1endmodule M : sig val x : int endmodule N : sig val x : int val y : int val z : int endmodule O : sig val y : int val z : int end N has both an x and y, whereas O has only a y. The reason is that include M causes all the definitions of M to also be included in N, so the definition of x from M is present in N. But open M only made those definitions available in the scope of O, aka. a part of the implementation; it doesnâ€™t actually make them part of the structure, aka. the client cannot see them. So O does not contain a definition of x, even though x is in scope during the evaluation of Oâ€˜s definition of y. FunctorsDef: a functor is simply a â€œfunctionâ€ from structures to structures. It is a parametrized module. Syntax123456789101112131415161718module F (M : S) = struct ...end(*annonymous functors*)module F = functor (M : S) -&gt; struct ...end(*functors parametriezed with multiple modules*)module F (M1 : S1) ... (Mn : Sn) = struct ...end(* above are the desugared version of the codes above*)module F = functor (M1 : S1) -&gt; ... -&gt; functor (Mn : Sn) -&gt; struct ...end 12module ANewModule = F(OldModule)module ListSetNoDupsExtended = ExtendSet(ListSetNoDups) ApplicationExtension1234567module ExtendSet(S:Set) = struct include S let add_all lst set = let add&#x27; s x = S.add x s in List.fold_left add&#x27; set lstend Other than Extension: Testing123456module SackTester (S: StackSig) = struct let _ = assert (S.(empty |&gt; push 1 |&gt; peek) = 1)endmodule MyStackTester = StackTester(MyStack)module ListStackTester = StackTester(ListStack) The only difference is that because the latter example is about extension, we need to include everything from its parent module.","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"CS3110","slug":"CS3110","permalink":"https://harmonyano.github.io/tags/CS3110/"},{"name":"20SP","slug":"20SP","permalink":"https://harmonyano.github.io/tags/20SP/"}]},{"title":"Modules","slug":"2020-02-11-Modules","date":"2020-02-11T05:00:00.000Z","updated":"2020-03-10T19:03:46.196Z","comments":true,"path":"2020-02-11-Modules/","link":"","permalink":"https://harmonyano.github.io/2020-02-11-Modules/","excerpt":"From Textbook: OCaml Modules StructuresSemanticsThe first letter of a moduleâ€™s name should be capitalized. 123module ModuleName = struct (* definitions *)end","text":"From Textbook: OCaml Modules StructuresSemanticsThe first letter of a moduleâ€™s name should be capitalized. 123module ModuleName = struct (* definitions *)end You can access the variables / methods in a module by Module.method 12let x = ModuleName.empty;;x.peek;; SignaturesSemanticsSignature is a collections of declarations; not evaluated, just type checked. 123456789101112module type ModuleTypeName = sig (* declarations *)endmodule type Stack = sig type &#x27;a stack val empty : &#x27;a stack val is_empty : &#x27;a stack -&gt; bool val push : &#x27;a -&gt; &#x27;a stack -&gt; &#x27;a stack val peek : &#x27;a stack -&gt; &#x27;a val pop : &#x27;a stack -&gt; &#x27;a stackend A structure matches a signature if the structure provides definitions for all the names specified in the signature (and possibly more), and these definitions meet the type requirements given in the signature. If you donâ€™t seal X, as long as the fields in module correspond with those in signature, these two match. when we seal X, we a create a linkage between module with the signature but we donâ€™t have to do that. Itâ€™s safer if you explicitly want X to be a type of X, but we add an extra layer of abstraction to X. AbstractionYou can also specify that this module as a type of some signature by providing a module type annotation : Stack. After adding this, everything inside that module will be come abstract and hidden from view. 1234567891011121314151617module type Arith = sig type t val zero : t val one : t val (+) : t -&gt; t -&gt; t val ( * ) : t -&gt; t -&gt; t val (~-) : t -&gt; tendmodule Ints : Arith = struct type t = int let zero = 0 let one = 1 let (+) = Stdlib.(+) let ( * ) = Stdlib.( * ) let (~-) = Stdlib.(~-)end Outside of the module Ints, the expression Ints.(one + one) is perfectly fine, but Ints.(1 + 1) is not, because t is abstract: outside the module no one is permitted to know that t = int. In fact, the toplevel canâ€™t even give us good output about what the sum of one and one is! 12# Ints.(one + one);;- : Ints.t = &lt;abstr&gt; Sharing ConstraintOCaml lets you write sharing constraints that refine a signature by specifying equations that must hold on the abstract types in that signature. If T is a module type containing an abstract type t, then T with type t = int is a new module type that is the same as T, except that t is known to be int. For example, we could write: 123module Ints : (Arith with type t = int) = struct (* all of Ints as before *)end Now both Ints.(one + one) and Ints.(1 + 1) are legal. Modules and the Top LevelWell, apparently you cannot remember everything about how to import a library into OCaml and you donâ€™t have to. So just refer to this site","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"CS3110","slug":"CS3110","permalink":"https://harmonyano.github.io/tags/CS3110/"},{"name":"20SP","slug":"20SP","permalink":"https://harmonyano.github.io/tags/20SP/"}]},{"title":"Higher-Order Functions","slug":"2020-02-06-Higher-Order-Functions","date":"2020-02-06T05:00:00.000Z","updated":"2020-03-10T19:07:06.450Z","comments":true,"path":"2020-02-06-Higher-Order-Functions/","link":"","permalink":"https://harmonyano.github.io/2020-02-06-Higher-Order-Functions/","excerpt":"From Textbook: Higher Order Programming Introduction higher-order: functions as values, you can pass functions as arguments into other functions, functions at the same level as other variables lower-order: languages like C, functions as something higher than other variables Pipeline is a higher-order function. 123let pipeline x f = f xlet (|&gt;) = pipelinelet x = 5 |&gt; double (* 10 *)","text":"From Textbook: Higher Order Programming Introduction higher-order: functions as values, you can pass functions as arguments into other functions, functions at the same level as other variables lower-order: languages like C, functions as something higher than other variables Pipeline is a higher-order function. 123let pipeline x f = f xlet (|&gt;) = pipelinelet x = 5 |&gt; double (* 10 *) Map (Transforms Elements)it maps each element of the list through a function 123456789(* [map f [x1; x2; ...; xn]] is [f x1; f x2; ...; f xn] *)let rec map f = function | [] -&gt; [] | h::t -&gt; (f h)::(map f t)let add1 = map (fun x-&gt; x+1);let add1&#x27; = map ((+)1);let concat3110 = map (fun x -&gt; x^&quot;3110&quot;) Filter (Eliminates Elements)List.filter &lt;predicate&gt; &lt;list&gt;it picks all elements which meet predicate p to form a new list. 12345(* [filter p l] is the list of elements of [l] that satisfy the predicate [p]. * The order of the elements in the input list is preserved. *)let rec filter f = function | [] -&gt; [] | h::t -&gt; if f h then h::(filter f t) else filter f t Fold (Combines Elements)Fold Right Can we abstract the following two functions as a single function? 1234567let rec sum = function | [] -&gt; 0 | h::t -&gt; h + (sum t)let rec concat = function | [] -&gt; &quot;&quot; | h::t -&gt; h ^ (concat t) First, we abstract the initial value 1234567891011let rec sum&#x27; init = function | [] -&gt; init | h::t -&gt; h + sum&#x27; init tlet sum = sum&#x27; 0let rec concat&#x27; init = function | [] -&gt; init | h::t -&gt; h ^ concat&#x27; init tlet concat = concat&#x27; &quot;&quot; We find out the only thing these two functions have in difference is the operator. So the next step, we factor out the operator. 123let rec combine init op = function| [] -&gt; init| h::t -&gt; op h (combine init op t);; The intuition for why this function is called fold_right is that the way it works is to â€œfold inâ€ elements of the list from the right to the left, combining each new element using the operator. For example, fold_right (+) [a;b;c] 0 results in evaluation of the expression a+(b+(c+0)). The parentheses associate from the right-most subexpression to the left. One way to think of fold_right would be that the [] value in the list gets replaced by init, and each :: constructor gets replaced by op. For example, [a;b;c] is just syntactic sugar for a::(b::(c::[])). So if we replace [] with 0 and :: with (+), we get a+(b+(c+0)). Fold Left123let rec fold_left op acc = function | [] -&gt; acc | h :: t -&gt; fold_left op (op acc h) t The idea is that fold_left (+) 0 [a;b;c] results in evaluation of ((0+a)+b)+c. The parentheses associate from the left-most subexpression to the right. So fold_left is â€œfolding inâ€ elements of the list from the left to the right, combining each new element using the operator. Fold Left vs. Fold RightWhy is there a difference of the order the operand takes in arguments (op acc h; op: &#39;a -&gt; &#39;b -&gt; &#39;a as in fold_left; op h (combine init op t); op: &#39;a -&gt; &#39;b -&gt; &#39;b as in fold_right)? And why is there a difference of the order these two functions take in argument (fold_left op acc lst; fold_right op lst init)? fold_left f init [v1; v2;...; vn] is f (... (f (f init v1) v2)...) vn whereas fold_right f [v1; v2;...; vn] init is f v1 (f v2 (...(f vn init)...)) (â€“ Nate Foster) order of evaluation: fold_left evaluates from left to right fold_right evaluates from right to left tail-recursive: because of the way these two functions evaluate fold_left is tail-recursive. We can add that value to acc, the group of elements completed evaluation, after evaluating the current element. fold_right is not recursive. Because it cannot evaluate the nth element before evaluating the (n+1)th element. And the evaluation of nth element depends on (n+1)th element. This pattern violates the definition of tail-recursive Then is there a tail-recursive version of fold_right? You can first reverse the list and then fold_left. Fold Application12345678let length l = List.fold_left (fun a _ -&gt; a+1) 0 llet rev l = List.fold_left (fun a x -&gt; x::a) [] llet map f l = List.fold_right (fun x a -&gt; (f x)::a) l []let filter f l = List.fold_right (fun x a -&gt; if f x then x::a else a) l [](*test whether a list is full of true*)let lst_and_fold = List.fold_left (fun acc elt -&gt; acc &amp;&amp; elt) true Generalized Fold1234567let rec foldtree init op = function | Leaf -&gt; init | Node (v,l,r) -&gt; op v (foldtree init op l) (foldtree init op r) let size t = foldtree 0 (fun _ l r -&gt; 1 + l + r) tlet depth t = foldtree 0 (fun _ l r -&gt; 1 + max l r) tlet preorder t = foldtree [] (fun x l r -&gt; [x] @ l @ r) t","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"CS3110","slug":"CS3110","permalink":"https://harmonyano.github.io/tags/CS3110/"},{"name":"20SP","slug":"20SP","permalink":"https://harmonyano.github.io/tags/20SP/"}]},{"title":"Advanced Data Types","slug":"2020-02-04-Advanced-Data-Types","date":"2020-02-04T05:00:00.000Z","updated":"2020-03-10T21:02:58.286Z","comments":true,"path":"2020-02-04-Advanced-Data-Types/","link":"","permalink":"https://harmonyano.github.io/2020-02-04-Advanced-Data-Types/","excerpt":"From Textbook: Advanced Data Types Algebraic Data Typesä»¥å‰æˆ‘ä»¬çš„ variants æ¯”è¾ƒåƒ enumï¼Œä½†æ˜¯ç°åœ¨æˆ‘ä»¬æ›´åƒä¸€ä¸ªabstract class","text":"From Textbook: Advanced Data Types Algebraic Data Typesä»¥å‰æˆ‘ä»¬çš„ variants æ¯”è¾ƒåƒ enumï¼Œä½†æ˜¯ç°åœ¨æˆ‘ä»¬æ›´åƒä¸€ä¸ªabstract class 12345678910111213(*definition*)type t = C1 | C2 of t2| ... | Cn (*of tn*)(* t: &#x27;a * &#x27;a * ... *)(*expression*)C e---or---C(* e: (e1:&#x27;a, e2:&#x27;a, ...) *)(*pattern matching*)C p(* p: (e1:&#x27;a, e2:&#x27;a, ...) *) examples: 12345678910111213141516171819202122232425262728type point = float * float type shape = | Point of point | Circle of point * float (* center and radius *) | Rect of point * point (* lower-left and upper-right corners *)let area = function | Point _ -&gt; 0.0 | Circle (_,r) -&gt; pi *. (r ** 2.0) | Rect ((x1,y1),(x2,y2)) -&gt; let w = x2 -. x1 in let h = y2 -. y1 in w *. htype string_or_int =| String of string| Int of inttype string_or_int_list = string_or_int listlet rec sum : string_or_int list -&gt; int = function | [] -&gt; 0 | (String s)::t -&gt; int_of_string s + sum t | (Int i)::t -&gt; i + sum tlet three = sum [String &quot;1&quot;; Int 2] When do we need [],(),&#123;&#125; | of? 12type node = &#123;value:int; next:mylist&#125;and mylist = Nil | Node of node []: list (): Constructor of a tuple &#123;&#125;: Constructor of a record |: delineate different variants inside a type of: defining the construction of an algebraic type Recursive Variants12345678910type intlist = Nil | Cons of int * intlisttype &#x27;a tree = | Leaf | Node of &#x27;a nodeand &#x27;a node = &#123; value: &#x27;a; left: &#x27;a tree; right: &#x27;a tree&#125; Parametrized VariantsNo matter what kind of types we define, either a variant, a record, or a tuple. We need the type parameter &#39;a or (&#39;a,&#39;b) when we define it. 123456(* [Option] makes it safer to return nothing*)type &#x27;a option = None | Some of &#x27;atype &#x27;a mylist = Nil | Cons of &#x27;a * &#x27;a mylisttype (&#x27;a,&#x27;b) pair = &#123;first: &#x27;a; second: &#x27;b&#125;type (&#x27;a,&#x27;b) test = &#x27;a * &#x27;b Similarly, when you want to declare a variable that has a parametrized type, you also need to give the type parameter. 123type &#x27;a tree = Leaf of &#x27;a | Node of (&#x27;a * &#x27;a tree * &#x27;a tree)let x:&#x27;a tree = Leaf 5let x:int tree = Leaf 5 If you do let x:tree = Leaf 5, the compiler wonâ€™t know what type you are talking about. Polymorphic VariantsThey would be better off with the name â€œanonymous variants,â€ because you want to use them when these variants are only used in this specific function and not anywhere else. The constructor of polymorphic variants start with a â€œ ` â€œ 123456789101112(* note: no type definition *)let f = function | 0 -&gt; `Infinity | 1 -&gt; `Finite 1 | n -&gt; `Finite (-n) val f : int -&gt; [&gt; `Finite of int | `Infinity ]let lst = [`Pos 5; `Zero; `Neg (~-4); `Pos 3];;val lst : [&gt; `Neg of int | `Pos of int | `Zero ] list = [`Pos 5; `Zero; `Neg (-4); `Pos 3] Pattern Matching12345678910111213141516type &#x27;a tree = | Leaf | Node of &#x27;a nodeand &#x27;a node = &#123; value: &#x27;a; left: &#x27;a tree; right: &#x27;a tree&#125;(* [mem x t] returns [true] if and only if [x] is a value at some * node in tree [t]. *)let rec mem x = function | Leaf -&gt; false | Node &#123;value; left; right&#125; -&gt; value = x || mem x left || mem x right ExceptionsThe Basics12345678910(*Definition: it is just a special kind of &quot;type&quot;*)exception E of t(*Call an Exception*)raise e(*syntactic sugar*)failwith &quot;Not Good&quot;raise (Failure (&quot;Not Good&quot;)) Pattern MatchingThe following code says: try evaluating e. If it produces an exception packet, use the exception patterns from the original match expression to handle that packet. If it doesnâ€™t produce an exception packet but instead produces a normal value, use the non-exception patterns from the original match expression to match that value. 123456789match try e with | q1 -&gt; e1 | ... | qn -&gt; enwith | r1 -&gt; e1 | ... | rm -&gt; em","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"CS3110","slug":"CS3110","permalink":"https://harmonyano.github.io/tags/CS3110/"},{"name":"20SP","slug":"20SP","permalink":"https://harmonyano.github.io/tags/20SP/"}]},{"title":"Standard Data Types","slug":"2020-01-30-Standard-Data-Types","date":"2020-01-30T05:00:00.000Z","updated":"2020-03-10T20:39:30.121Z","comments":true,"path":"2020-01-30-Standard-Data-Types/","link":"","permalink":"https://harmonyano.github.io/2020-01-30-Standard-Data-Types/","excerpt":"From Textbook: Standard Data Types ListsBuilding Lists The empty list is written [] and is pronounced â€œnilâ€, a name that comes from Lisp. Given a list lst and element elt, we can prepend elt to lst by writing elt::lst. The double-colon operator is pronounced â€œconsâ€","text":"From Textbook: Standard Data Types ListsBuilding Lists The empty list is written [] and is pronounced â€œnilâ€, a name that comes from Lisp. Given a list lst and element elt, we can prepend elt to lst by writing elt::lst. The double-colon operator is pronounced â€œconsâ€ cons always prepend things, so cons is actually right-associative. The following code has the same effect. 121::2::3::[];;1::(2::(3::[]));; All the elements of a list must have the same type. The word list itself here is not a type. For example, given int, it produces the type int list. You could think of type constructors as being like functions that operate on types, instead of functions that operate on values. (We mentioned this idea of thinking constructor as a function on type in CS2112) Accessing ListsThe following code computes the sum of a list. 1234let rec sum lst = match lst with | [] -&gt; 0 | h::t -&gt; h + sum t The following code computes the length of a list. _, the underscore character is used when we want to indicate the presence of some value in a pattern without actually giving it a name. 12345let rec length lst = match lst with | [] -&gt; 0 | _::t -&gt; 1 + length t The following code appends one list onto the beginning of another list. 1234let rec append lst1 lst2 = match lst1 with | [] -&gt; lst2 | h::t -&gt; h::(append t lst2) Note: every natural number is either 0 or is 1 greater than some other natural number n, and so a proof by induction has a base case for 0 and an inductive case for n+1. Likewise all our functions have a base case for the empty list and a recursive case for the list that has one more element than another list. This similarity is no accident. There is a deep relationship between induction and recursion; weâ€™ll explore that relationship in more detail later in the course. Mutating ListsValues in OCaml are immutable. The following code increments the head by 1. 1234let inc_first lst = match lst with | [] -&gt; [] | h::t -&gt; (h+1)::t This code looks extremely similar with C or Java operating on pointers. The implementation of list in OCaml works in the way that it shares the tail list t between the old list and the new list, such that the amount of memory in use does not increase (beyond the one extra piece of memory needed to store h+1). The reason that itâ€™s quite safe for the compiler to implement sharing is exactly that list elements are immutable. Pattern Matching with ListsBasicsEach of the clauses pi -&gt; ei is called a branch or a case of the pattern match. The pâ€˜s here are a new syntactic form called a pattern. a variable name, e.g. x the underscore character _, which is called the wildcard (we donâ€™t care what it is) the empty list [] p1::p2 [p1; ...; pn] 1234let length_is lst n = match length lst with | n -&gt; true | _ -&gt; false The code above always returns true, because suppose that the length of lst is 5. Then the pattern match becomes: match 5 with n -&gt; true | _ -&gt; false. And n matches 5. A variable pattern matches any value and here produces the binding n-&gt;5. The correct codes are written below. 123456789101112let length_is lst n = match length lst with | m -&gt; if m=n then true else false | _ -&gt; false let length_is lst n = match length lst with | m -&gt; m=n | _ -&gt; falselet length_is lst n = length lst = n However, this doesnâ€™t mean patterns are not the variable values as in switch statement. Yes they are general â€œpatternsâ€. But you can match them to specific values. e.g. 123456789match 5 with| 6 -&gt; true| _ -&gt; false;;- : bool = falsematch 5 with| 5 -&gt; true| _ -&gt; false;;- : bool = true Advanced Pattern Matching p1 | ... | pn: an â€œorâ€ pattern; matching against it succeeds if a match succeeds against any of the individual patterns pi, which are tried in order from left to right. All the patterns must bind the same variables. (p : t): a pattern with an explicit type annotation. c: here, c means any constant, such as integer literals, string literals, and booleans. &#39;ch1&#39;..&#39;ch2&#39;: here, ch means a character literal. For example, &#39;A&#39;..&#39;Z&#39; matches any uppercase letter. p when e: matches p but only if e evaluates to true. Tuples and Recordsboth represent heterogeneous types of values, both sizes are fixed RecordsWorks like struct in C++. Each field is identified by names. Definition123type student =&#123;name: string; gpa : float; year :int;&#125; (*defining a type*)let rbg = &#123;name = &quot;R B&quot;; gpa = 4.0; year = 1954;&#125; (*declare an instance of that type*)let s = rbg.name (*accessing field in the record*) Patter Matching123456match rbg with | &#123;name=n; gpa=g; year=y&#125; -&gt; y(*syntactic sugar of codes above*)match rgb with | &#123;name;gpa;year&#125; -&gt; name TuplesTuples are identified by position, instead of naming the components. Definition1234let t = (10,&quot;am&quot;) (*t has type: int * string*) type time = int * string let t:time = (10,&quot;am&quot;) (*t has type: time*) fst t;; snd t;; (*predefined functions to access the first and second element of a tuple*) Pattern Matchingif we use a pattern in a let expression (or definition), we are really just doing pattern matching with a single clause. 123456789let tick t =let (t,s) = t in (t+1,s) (*tick : int * &#x27;a -&gt; int * &#x27;a = &lt;fun&gt;*)let tick (t:time):time =let (t,s) = t in (t+1,s) (*tick : time -&gt; time = &lt;fun&gt;*)let tick (t:time):time = match t with| (t,s) -&gt; (t+1,s) Pattern Matching in a Nutshell1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768(* Pokemon types *)type ptype = TNormal | TFire | TWater(* A record to represent Pokemon *)type mon = &#123;name: string; hp : int; ptype: ptype&#125;(********************************************* * Several ways to get a Pokemon&#x27;s hit points: *********************************************)(* OK *)let get_hp m = match m with | &#123;name=n; hp=h; ptype=t&#125; -&gt; h(* better *)let get_hp m = match m with | &#123;name=_; hp=h; ptype=_&#125; -&gt; h(* better *)let get_hp m = match m with | &#123;name; hp; ptype&#125; -&gt; hp(* better *)let get_hp m = match m with | &#123;hp&#125; -&gt; hp(* best *)let get_hp m = m.hp(************************************************** * Several ways to get the 3rd component of a tuple **************************************************)(* OK *)let thrd t = match t with | (x,y,z) -&gt; z(* good *)let thrd t = let (x,y,z) = t in z(* better *)let thrd t = let (_,_,z) = t in z(* best *)let thrd (_,_,z) = z(************************************* * How to get the components of a pair *************************************)let fst (x,_) = xlet snd (_,y) = y(************************ * take tuple as a whole ************************)let rep_ok ((n,lst) as v) = if List.length lst = n then v else failwith &quot;RI violated&quot;","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"CS3110","slug":"CS3110","permalink":"https://harmonyano.github.io/tags/CS3110/"},{"name":"20SP","slug":"20SP","permalink":"https://harmonyano.github.io/tags/20SP/"}]},{"title":"Functions","slug":"2020-01-28-Functions","date":"2020-01-28T05:00:00.000Z","updated":"2020-03-10T20:35:21.091Z","comments":true,"path":"2020-01-28-Functions/","link":"","permalink":"https://harmonyano.github.io/2020-01-28-Functions/","excerpt":"From Textbook: Functions FunctionsDefinition: let f x1 x2 ... xn = e (f is the function name; xi is input, and there can be multiple inputs; e is the output) We can think of t1 -&gt; t2 -&gt; u as the type of a function that takes two inputs, the first of type t1 and the second of type t2, and returns an output of type u. Likewise for a function that takes n arguments. A function is already a value (thatâ€™s how you assign the value â€œfunctionâ€ to a variable name), so there is nothing to be evaluated when we evaluate its dynamic semantic.","text":"From Textbook: Functions FunctionsDefinition: let f x1 x2 ... xn = e (f is the function name; xi is input, and there can be multiple inputs; e is the output) We can think of t1 -&gt; t2 -&gt; u as the type of a function that takes two inputs, the first of type t1 and the second of type t2, and returns an output of type u. Likewise for a function that takes n arguments. A function is already a value (thatâ€™s how you assign the value â€œfunctionâ€ to a variable name), so there is nothing to be evaluated when we evaluate its dynamic semantic. Anonymous FunctionDefinition: fun x -&gt; x+1 (fun is a keyword indicating an anonymous function) Anonymous functions are also called lambda expressions, a term that comes out of the lambda calculus, which is a mathematical model of computation in the same sense that Turing machines are a model of computation. In the lambda calculus, fun x -&gt; e would be written $Î»x.e.$ The Î» denotes an anonymous function. Function Application Normal way:(fun x -&gt; e3) ((fun x -&gt; e2) e1);; Pipeline: e1 |&gt; fun x-&gt;e2 |&gt; fun x-&gt;e3;; They are semantically the same as â€œlet expressionsâ€ : let x = e1 in let x = e2 in e3 (In fact, the let expression is just a syntactic sugar of function application) Function application is left-associative: g f x = (g f) x, while function types are right-associative: g -&gt; f -&gt; x = g -&gt; (f -&gt; x) Polymorphic FunctionsThe &#39;a is a type variable: it stands for an unknown type, just like a regular variable stands for an unknown value. Labeled ArgumentsOCaml supports labeled arguments to functions. You can declare this kind of function using the following syntax: 12# let f ~name1:arg1 ~name2:arg2 = arg1 + arg2;;val f : name1:int -&gt; name2:int -&gt; int = &lt;fun&gt; This function can be called by passing the labeled arguments in either order: 1f ~name2:3 ~name1:4;; A sugar of declaring function with labeled arguments is 1let f ~name1 ~name2 = name1 + name2 Partial ApplicationA function of two variables: let add x y = x + y A composite function: let addx x = fun y -&gt; x + y 123let add x y = x+ylet add x = fun y -&gt; x+ylet add = fun x -&gt; (fun y -&gt; x+y) The top two are just syntactic sugar for the last statement. Now, think about what does the last line mean? Does the fun y -&gt; x+y actually knows that there exists an x? The answer is yes. Thatâ€™s because the statement fun y -&gt; x+y is in the scope of xâ€˜s declaration. For the codes below, the outermost function actually takes in a value of type t1 and produces a function that is of type t2 -&gt; (t3 -&gt; t4) And the type of such a function 1t1 -&gt; t2 -&gt; t3 -&gt; t4 really means the same as 1t1 -&gt; (t2 -&gt; (t3 -&gt; t4)) That is, function types are right associative: there are implicit parentheses around function types, from right to left. The intuition here is that a function takes a single argument and returns a new function that expects the remaining arguments. Below is an example of Partial Application: The bottom two are syntactic sugars of the first statement 123let comp = fun f g -&gt; fun x -&gt; g(f x);;let compa f g = fun x -&gt; g(f x);;let compb f g x = g(f x);; Applying comp to other functions: 1234567891011utop # let inc x = x+1;;val inc : int -&gt; int = &lt;fun&gt;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€utop # let inc2 = comp inc inc;;val inc2 : int -&gt; int = &lt;fun&gt;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€utop # inc 1;;- : int = 2â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€utop # inc2 1;;- : int = 3 A useful application of Partial Application is precomputation: When we want to use a process multiple times, we can just write a function that takes in other function and do that job. g. predefine comp so that when we want to composite two functions, we only need to apply it to the function comp instead of writing out the composite function on ourselves every time. Unit FunctionThere is only one value of this type, which is written () and is also pronounced â€œunitâ€. So unit is like bool, except there is one fewer value of type unit than there is of bool. Unit is therefore used when you need to take an argument or return a value, but thereâ€™s no interesting value to pass or return. Type InferenceHow to determine the type of a very complicated function? Add right-associative parameters; Rewrite the function as a more understandable let expression Find out which variables have to take in a value (then it must be a function), which doesnâ€™t (then it can be anything) Determine the type of each variable from the last statement, and write their types from left to right in the sequence they were taken in. Take fun f g -&gt; fun x -&gt; g(f x) as an example: let h = fun f g -&gt; ( fun x -&gt; g(f x) ) x doesnâ€™t take in a value, so x is a variable of type aâ€™ f takes in x, so f must be a function of type aâ€™ -&gt; bâ€™ g takes in the output of f, so g must be a function of type bâ€™ -&gt; câ€™ The type of this function is 12 f g x (output:g(f x))(a&#x27; -&gt; b&#x27;) -&gt; (b&#x27; -&gt; c&#x27;) -&gt; a&#x27; -&gt; c&#x27; Take fun f g -&gt; fun x -&gt; (g f) x as another example: let h = fun f g -&gt; (fun x -&gt; (g f) x) x doesnâ€™t take in a value, so x is a variable of type aâ€™ f doesnâ€™t take in a value, so f is a variable of type bâ€™ g takes in f, so g must be a function whose input is of type bâ€™; plus its output takes in another variable x, so its output is also a function, which takes in a type aâ€™. Therefore, g is of type b&#39; -&gt; (a&#39; -&gt; c&#39;) The type of this function is 12f g x (output:(g f) x)b&#x27; -&gt; (b&#x27; -&gt; a&#x27; -&gt; c&#x27;) -&gt; a&#x27; -&gt; c&#x27;","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"CS3110","slug":"CS3110","permalink":"https://harmonyano.github.io/tags/CS3110/"},{"name":"20SP","slug":"20SP","permalink":"https://harmonyano.github.io/tags/20SP/"}]},{"title":"CS2043 Unix Tools and Scripting","slug":"2020-01-24-CS2043-Unix-Tools-and-Scripting","date":"2020-01-24T05:00:00.000Z","updated":"2021-08-31T00:16:56.845Z","comments":true,"path":"2020-01-24-CS2043-Unix-Tools-and-Scripting/","link":"","permalink":"https://harmonyano.github.io/2020-01-24-CS2043-Unix-Tools-and-Scripting/","excerpt":"AboutThe goal of CS2043 is to introduce you to the UNIX/Linux â€œcommand lineâ€ and its accompanying tools. When done with this class you should feel comfortable navigating any UNIX shell prompt, installing UNIX/Linux systems and understanding any shell script that you may encounter down the road. Weâ€™ll cover basic commands through script writing and visit some of the more common tools used today!","text":"AboutThe goal of CS2043 is to introduce you to the UNIX/Linux â€œcommand lineâ€ and its accompanying tools. When done with this class you should feel comfortable navigating any UNIX shell prompt, installing UNIX/Linux systems and understanding any shell script that you may encounter down the road. Weâ€™ll cover basic commands through script writing and visit some of the more common tools used today! LEC02 File System (01/24)Root DirectoryUnlike Windows, UNIX has a single global â€œrootâ€ directory (instead of a root directory for each disk or volume). The root directory is just /. Absolute paths start with a /, and always refer to the root directory. cat: concatenate and print a file cat &gt;&gt; &lt;filename&gt;: concatenate your following input in shell to the file specified wc -l &lt;filename&gt;: count the number of lines in a file wc -w &lt;filename&gt;: count the number of words in a file touch: create a file if not existed mkdir -p test/a/b: make directory and all its parent directory if they do not exist cp â€“r &lt;src&gt; &lt;dest&gt;: To copy a complete directory cp â€“f &lt;src&gt; &lt;dest&gt;: To overwrite more aggressively LEC03 Permission (01/27)Reading permission: Linux Representation Permission by user type -rwxâ€”â€” User permissions â€”-rwxâ€” Group permissions â€”â€”-rwx Other permissions r- read, w- write, x - execute groups &lt;username&gt;: check which group this user is in and you can manage permission by groups chmod &lt;mode&gt; &lt;filename&gt;: change permissions: &lt;mode&gt;: +774: add user and group all rwx permissions, give others only r permission to the file -222: deprive user, group, and otherâ€™s permissions to write the file =111: change user, group, and otherâ€™s permissions to only execute the file. They will lose permissions to read or write if they previously had su: makes you the super user sudo: grants you the super power temporarily LEC04 More Commands (01/29) more | less: to view file man: \\something to search for â€œsomethingâ€, n to go to its next occurrence find &lt;directory&gt; -&lt;criteria&gt; &lt;specification&gt;: Modifiers for find are evaluated in conjunction (a.k.a AND). But you can condition your arguments with an OR using the â€“o flagfind can also execute command on found files / directories by using the â€“exec modifier, and find will execute the command for you The variable name is {} You have to end the command with either a : Semicolon (;): execute command on each result as you find them- Plus (+): find all the results first, then execute command arguments for &lt;criteria&gt;: -name: the fileâ€™s name -amin n: file last access was n minutes ago -atime n: file last access was n days ago examples: find ./ -name *.sh: find under the current directory all files containing the extension name â€œ.shâ€ find . â€“amin -10 â€“exec cat &#123;&#125; \\+: Display all the contents of files accessed in the last 10 minutes find . â€“type f â€“readable â€“executable: All files that are readable and executable find . â€“type f â€“readable â€“o â€“executable: All files that are readable or executable find . â€“amin +10: Find all files accessed at least 10 minutes ago find . â€“amin -10: Find all files accessed at most 10 minutes ago LEC05 Zipping (01/31)Zipping tar -c -v -f &lt;zipped_filename&gt; &lt;files_to_zip&gt;: tar files only create a bundle of file,s it doesnâ€™t compress Remember to put -f as the last one, or at least -f must come right before &lt;zipped_filename&gt; -c : create a new bundle -v : verbose (output information about whatâ€™s going on) -f : save in file tar -xvf &lt;archived_filename&gt; &lt;files_to_zip&gt;: -x: extract files Piping1&lt;command1&gt; | &lt;command2&gt; ls -al /bin | less: show everything in directory /bin as scrollable history | tail -20 | head -10 : the most recent 10th - 19th file RedirectionIf you donâ€™t specify, the output or input of a command comes from the terminal command &gt; file: write the output of the command into file (overwrite) command &lt; file: take the file as input of a command line command 2&gt; file: outputs the error message to a file (stderr(2) in C) command &gt;&gt; file: append the output of the command into file (doesnâ€™t overwrite) LEC06 Loops and Variables (02/03)Environment and Variables environment variables: in the computer local variables: only in current shell Shebang #!/bin/sh: execute the file using Bourne shell (sh) #!/bin/bash: execute the file using bash shell (bash) exit codereturned value of main will be printed out if executing the script in Linux exit N: exit with status N executing multiple commands in a row cmd1; cmd2: execute cmd 1 first, then cmd 2 cmd1 &amp;&amp; cmd2: execute cmd2 only if cmd 1 returns 0 (exited normally) cmd1 || cmd2: execute cmd2 only if cmd 1 doesnâ€™t return 0 (failed) ScriptingWe mostly use bash in our scripting. So remember to include #!/bin/bash in the top Variablesstoring command output: var = &quot;$(echo hello world)&quot; if statement123456789if [ CONDITION_1 ] then # statementselif [ CONDITION_2 ]then # statementselse # statementsfi if...then...fi part is necessary. elif and else are allowed, but not necessary. Shorten codes with ; to write them in one line, like if [[ 0 â€“eq 0]]; then echo â€œHiyaâ€; fi for loop123for (( i = 0; i &lt;= 11; ++i )); do echo â€œi: $iâ€done while loop1234567891011121314151617s=â€œsâ€ while [[ &quot;$s&quot; != &quot;ssss&quot; ]]; do echo &quot;$s&quot; s=&quot;s$s&quot;donex=0 while (( x &lt;= 11 )); do echo &quot;x: $x&quot; (( ++x ))done# Loop through lines in a filefile=â€œfilename.txtâ€while read -r line; do echo &quot;Line: $line&quot;done &lt; &quot;$file&quot; Comparing ValuesNumbers $n1 â€“eq $n2 tests if n1 == n2 $n1 â€“ne $n2 tests if n1 != n2 $n1 â€“lt $n2 tests if n1 &lt; n2 $n1 â€“le $n2 tests if n1 &lt;= n2 $n1 â€“gt $n2 tests if n1 &gt; n2 $n1 â€“ge $n2 tests if n1 &gt;= n2 Strings â€œ$s1â€ == â€œ$s2â€ tests if s1 and s2 are identical â€œ$s1â€ != â€œ$s2â€ tests if s1 and s2 are different Path Testing Test if /some/path exists: -e /some/path Test if /some/path is a file: -f /some/path Test if /some/path is a directory: -d /some/path Test if /some/path can be read/written/execute: -r/-w/-x /some/path Arithmetic ExpressionPut expressions inside (( )) . In script, you need to put $ before expressions to read values. Below are some examples 123echo $(( 2 + 3 )) #5x=10; sum=$(( $x+10 ))echo $sum #20 Passing Arguments $1, $2, â€¦, $10: values of the first, second, etc. arguments If 3 arguments are given, $4, $5, â€¦ higher are empty $0 is the name of the script $# is the number of arguments (argc in C) $? Is the exit code of the last program executed You can have your script set this with exit &lt;number&gt; (read man exit) No explicit call to exit is the same as exit 0 (a.k.a, success!) $* expands \\$1 .. \\$n into one string, has the same effect as â€œ\\$1 \\$2 â€¦ \\$nâ€ (one string) $@ expands $1 .. $n into individual strings, same as â€œ$1â€ â€œ$2â€ .. â€œ$nâ€ (n strings) Be careful with spacing comparing two variables Lec07 Your Shell, Job, and Processes (02/05)Resource MonitoringCommands ps &lt;PID&gt; (process snapshot): report the current running processes, including PID ps -C &lt;command_name&gt;: report the current process using its corresponding shell command top: displays CPU usage of current processes htop: better version of top, though not pre-installed in many Linux distributions Examples1234ps â€“C firefox #find firefox&#x27;s pid through its command name61860 ... firefoxhtop -p 61860 #display usage of this specific process Modifying Processes nice -n &lt;priority:int&gt; &lt;command name&gt; : initialize command with non-default priority renice -n &lt;priority&gt; -p &lt;PID&gt;: readjust the priority of a running process kill &lt;PID&gt;: kill this process killall &lt;command name&gt;: kill processes by name, kill all processes related to this program JobsWhen we are executing ping or installing big packages, we may lose control of our command line temporarily. And we may want to run these commands in the background. &lt;command&gt; &amp;: run the command in background, but will still print output in the terminal jobs: report jobs working in background bg &lt;job_id&gt;: resumes the job in background (note: job id should come after %, like %1, or the command will take it as the PID) fg &lt;job_id&gt;: resume job in the foreground Lec08 Your Shell (02/10) source &lt;script_name&gt;: the command runs script in the current shell, not as usual in a spawned shell alias &lt;new_name&gt;=&lt;old_name&gt;: e.g. x = &#39;cd /Desktop&#39; ssh -X: allows X11 rendering (allows graphic interface through remote server) scp [flags] &lt;from&gt; &lt;to&gt; (secure copy): copy files from the internet (remote host): Must specify the user on the remote host. Syntax for remote client: user@host:/path (Note You need the : to start the path) ctrl + r reverse search your history for the most recent command that has the string you just typed in. Lec10 Shell Expansions and Search (02/14)Grammar of Shell Expansions *: multiple character wildcard: match any string, including the empty string ?: single character wildcard: match a single character: matches exactly one but what that character is doesnâ€™t matter [brackets]: [a-z, A-Z] matches one character in the range [^ ...]: not, [^abc] matches any character that is not a, b, or c &#123;... , ...&#125;: matches any pattern inside the comma separated braces. &#123;Hello,World&#125; matches either â€œHelloâ€ or â€œWorldâ€ \\ : escape space: &#123;Hello, Goodbye&#125; World = Hello Goodbye World &#123;Hello, Goodbye&#125;\\ World = Hello World Goodbye World (the space is escaped, so â€œWorldâ€ is now taken as a part of the set of words) $: to read values (echo $PWD reads the PWD variable and then echo its value) &lt;: create instream from file &gt; &gt;&gt;: direct output to a file (overwrite or append) GREPgrep &lt;pattern&gt; [input] Globally search a Regular Expression and Print. GREP can be used to search or filter large amounts of data. grep -r &lt;pattern&gt; ./ search current directory and all its subdirectories for the pattern specified grep -i &lt;p&gt; ./ ignore upper/lower case distinctions -v display those lines that do NOT match -n precede each matching line with the line number -c print only the total count of matched lines Regular Expressions a?: search for a with 0 or 1 appearance a*: search for a with 0 or multiple appearance a+: search for a with 1 or multiple appearance .: wildcard Lec11 Sed, Cut, and Paste sed: Replace: sed &#39;s/no spoon /a fork/g&#39; no_spoon.txt: replace (s/) every occurrence in the whole document (globally: /g) of â€œno spoonâ€ with â€œa forkâ€ Delete: sed &#39;/[Dd]avid/d&#39; david.txt: executes delete command (/d) xargs: can read from stdin, so it can pass output from other commands to scripts that only take in arguments, not from stdin. shift &lt;number&gt;: drop the first &lt;number&gt; arguments paste: merge multiple files paste â€“d , names.txt phones.txt &gt; result.csv: merge names and phones together, -ddelimit them with â€˜,â€™ paste â€“d , -s names.txt phones.txt &gt; result.csv: merge file serially (-s) instead of in parallel LEC12 awk, gawk, and Process Substitutionawk awk &#39;/[Mm]onster/ &#123;print&#125;&#39; frankenstein.txt: find regex [Mm]onste and print the lines out. awk &#39;/[Mm]onster/&#39; frankenstein.txt: if not specified, the default action is to print awk &#39;/[Mm]onster/ &#123;print $0&#125;&#39; frankenstein.txt: $0 refers the whole line awk &#39;/[Mm]onster/ &#123;print $1&#125;&#39; frankenstein.txt: prints the first word of the line contains our pattern awk &#39;/Ron/&#123;print $3&#125;&#39; marks.txt: prints the third column of the line containing â€˜Ronâ€™ in the file â€˜marks.txtâ€™ awk &#39;BEGIN&#123;x=5; y=10; z=x+y; print z&#125;&#39;: arithmetics in awk &amp;&amp; || a?b:c !(a&amp;&amp;b): also work in awk awk &#39;/s/?/8./:/9./ &#123;print&#125;&#39; marks.txt: If thereâ€™s an â€˜sâ€™, look for grade in 80s, otherwise grade in 90s awk &#39;!/s/ &#123;print&#125;&#39; marks.txt: Look for all lines that do not contain an â€˜sâ€™ Process SubstitutionWe can treat a command of series of commands as if they were a file &lt; (list): treat the list of commands as input e.g. echo &quot;This is a test&quot; &gt; &gt;(wc â€“w) &gt; (list): treat the list of commands as output file e.g. while read x; do echo $x; done &lt; &lt;(git log) LEC13 Advanced Bash ScriptingCondition Statements: casecase employs a patter match, using shell expansion 123456789case &quot;$var&quot; in&quot;A&quot; ) #commands to execute if [[ $var == &quot;A&quot; ]]2 ) #commands to execute if [[ $var -eq 2 ]][2-4] ) ##commands to execute if [[ $var -ge 2 ]] &amp;&amp; [[ $var -le 4 ]]* ) #default commands Arrays1234567891011121314151617arr = ( use parentheses and seperate items by space )my_arr = ( &quot;a string&quot; 1 ) % can be of multiple types# You can also customize the indexes inside the array (so its more like a dictionary instead of a traditional array)my_arr[44] = &quot;string&quot;# perform an array operation by $&#123;expr&#125;echo &quot;Index 51: $&#123;arr[51]&#125;&quot;#iterate through the array as individual itemsfor x in &quot;$&#123;arr[@]&#125;&quot;; do echo &quot;$x&quot;; done#iterate through the array as a joined long seriesfor x in &quot;$&#123;arr[*]&#125;&quot;; do echo &quot;$x&quot;; done#iterate through the list of indexesfor idx in &quot;$&#123;!new_arr[@]&#125;&quot;; do echo â€œ$idxâ€; done","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"20SP","slug":"20SP","permalink":"https://harmonyano.github.io/tags/20SP/"},{"name":"CS2043","slug":"CS2043","permalink":"https://harmonyano.github.io/tags/CS2043/"}]},{"title":"Installing and Configuring Ocaml on Linux","slug":"2020-01-20-Installing-Ocaml-on-Linux","date":"2020-01-20T05:00:00.000Z","updated":"2020-01-25T00:48:22.405Z","comments":true,"path":"2020-01-20-Installing-Ocaml-on-Linux/","link":"","permalink":"https://harmonyano.github.io/2020-01-20-Installing-Ocaml-on-Linux/","excerpt":"Install Ocamlrun sh &lt;(curl -sL https://raw.githubusercontent.com/ocaml/opam/master/shell/install.sh) and install opam at /usr/bin (Caution: install it under this directory to ensure you can also access opam at userâ€™s directory)","text":"Install Ocamlrun sh &lt;(curl -sL https://raw.githubusercontent.com/ocaml/opam/master/shell/install.sh) and install opam at /usr/bin (Caution: install it under this directory to ensure you can also access opam at userâ€™s directory) Configure Ocaml and VSCode initiate with sandbox (bubblewrap) disabled opam init --bare -a -y --disable-sandboxing switch OPAM to the OCaml 4.09.0 compiler: 123# Note: do NOT prefix these commands with sudoopam switch create 4.09.0 ocaml-base-compiler.4.09.0eval $(opam env) install OPAM packages needed 12opam install -y utop ounit qtest yojson lwt lwt_ppx menhir ansiterminal lambda-term merlin ocp-indent user-setup bisect_ppx-ocamlbuildopam user-setup install install â€œOCaml and Reason IDEâ€ and configure settings.json in vscode as such: 12345678910&#123; &quot;workbench.colorTheme&quot;: &quot;Solarized Light&quot;, &quot;editor.tabSize&quot;: 2, &quot;editor.rulers&quot;: [ 80 ], &quot;editor.formatOnSave&quot;: true, &quot;reason.path.ocamlmerlin&quot;: &quot;/home/mint/.opam/4.09.0/bin/ocamlmerlin&quot;, &quot;reason.path.ocamlfind&quot;: &quot;/home/mint/.opam/4.09.0/bin/ocamlfind&quot;&#125; note that it first showed that â€œcannot locate ocamlmerlin binary.â€ I fixed the problem by changing directory of â€œocamlmerlinâ€ and â€œocamlfindâ€ in the settings. (Find their path with which ocamlmerlin)","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"https://harmonyano.github.io/tags/Logistics/"},{"name":"CS3110","slug":"CS3110","permalink":"https://harmonyano.github.io/tags/CS3110/"}]},{"title":"Cornell 19FA æ€»ç»“","slug":"2019-12-22-Cornell-19FA-æ€»ç»“","date":"2019-12-22T05:00:00.000Z","updated":"2019-12-27T02:58:05.112Z","comments":true,"path":"2019-12-22-Cornell-19FA-æ€»ç»“/","link":"","permalink":"https://harmonyano.github.io/2019-12-22-Cornell-19FA-%E6%80%BB%E7%BB%93/","excerpt":"CS2112 OO Design Data Structs (Honors) My goal in teaching this course has been to make you guys fearless about taking ideas and turning them into systems of codes that work â€“ Andrew Myers, 2019/12/10","text":"CS2112 OO Design Data Structs (Honors) My goal in teaching this course has been to make you guys fearless about taking ideas and turning them into systems of codes that work â€“ Andrew Myers, 2019/12/10 ä»A1åˆ°A7è‚‰çœ¼å¯è§è‡ªå·±çš„æˆé•¿ï¼ŒçœŸçš„æƒ³å­¦CSçš„è¯ä¸€å®šè¦ä¸Šè¿™ä¸ªè¯¾ï¼Œå› ä¸ºè¿™ä¸ªè¯¾æ‰€ä»¥æˆ‘è§‰å¾—è¿™ä¸€å­¦æœŸè¿‡å¾—ç‰¹åˆ«å¿«ï¼Œä¸¤å‘¨ä¸€ä¸ªprojectï¼Œä¸€å­¦æœŸå°±è¿™æ ·è¿‡å»äº†ã€‚ A1: ä»€ä¹ˆå˜›ï¼Œè¿˜æ˜¯æŒºç®€å•çš„å—ï¼ˆç»“æœæ‹¿äº†ä½äºä¸€ä¸ªdeviationï¼‰ A2(Isaac)ï¼šå› ä¸ºäº²çˆ±çš„ä¸­å›½æœ‹å‹ä»¬è‡ªå·±æœ‰è‡ªå·±çš„é˜Ÿå‹ï¼Œåªæœ‰ä¸€ä¸ªé»‘å“¥æ‰¾æˆ‘å½“é˜Ÿå‹ã€‚è¿™ä¸ªé»‘å“¥å¥½åƒæ˜¯è¯¾ä¸Šå”¯ä¸€ä¸€ä¸ªé»‘å“¥ï¼ŒçœŸçš„éå¸¸åŠªåŠ›ã€‚ä½†æ˜¯è¯´å®è¯æœ‰çš„æ—¶å€™å¿™ä¸åˆ°ç‚¹ä¸Šå»ï¼Œå¿™äº†ç™½å¿™ã€‚æœ€åRSAå› ä¸ºä¸€ä¸ªè«åå…¶å¦™çš„bugï¼Œåˆæ˜¯ä½äºä¸€ä¸ªmedian (128 commits) A3(Ralph)ï¼šæˆ‘æœ€çˆ±çš„æ•°æ®ç»“æ„ï¼ŒChinese American é˜Ÿå‹ï¼Œå¼ºæ˜¯çœŸçš„å¼ºã€‚å¯ä»¥ç›´æ¥æ— éšœç¢è¯»Javaæºç ï¼Œä»–çš„hashTableä¼°è®¡å°±æ˜¯è¿™æ ·å†™å‡ºæ¥çš„ï¼Œä¸ç„¶æ›´å¼ºï¼Œå› ä¸ºä»–çš„hashTableå†™å¾—å®åœ¨å¤ªå¥½äº†ã€‚åŸºæœ¬ä¸Šè¢«ä»–å¸¦äº†ï¼Œæˆ‘å°±å†™äº†ä¸ªtrieè€Œå·²ã€‚ä½†æœ‰å¯èƒ½æ˜¯å› ä¸ºè¿™æ¬¡ä½œä¸šå¤ªç®€å•ï¼Œè€Œä¸”ç›¸å¯¹ç‹¬ç«‹ï¼Œæˆ‘ä¿©éƒ½è§‰å¾—ä¸éœ€è¦å’Œå¯¹æ–¹äº¤æµï¼Œç»“æœæ²¡ä»€ä¹ˆå›¢é˜Ÿåˆä½œçš„æ„Ÿè§‰ï¼Œåšçš„è¿˜ä¸å¦‚A2å¸¦æ„Ÿ (152 commits) A4(Xinyu &amp; Faizaan)ï¼šç»ˆäºæœ‰ä¸­å›½äººæ²¡æœ‰é˜Ÿå‹äº†ï¼ˆï¼Œæ‰€ä»¥æ˜¯ä¸€ä¸ªä¸­å›½å¦¹å­å’Œä¸€ä¸ªç¾å›½äººåšå¾—é˜Ÿå‹ã€‚è¿™ä¸ªç¾å›½äººï¼ŒçœŸçš„ä¸æ­£ç»ï¼Œæ˜æ˜èƒ½æå‰åšå®Œéè¦æ‹–åˆ°æœ€åä¸€ç§’å†™ã€‚å¹¸äºå› ä¸ºA4æ•´ä¸ªç»“æ„æ˜¯æˆ‘å†™çš„ï¼Œæˆ‘å‡ ä¹å¯¹å®ƒæœ‰ç»å¯¹äº†è§£å’ŒæŒæ§ï¼Œè¿›è¡Œå¾—è¿˜æ˜¯å¾ˆé¡ºåˆ©çš„ã€‚è¿™ä¸ªä¸­å›½å°å§‘å¨˜æ˜¯çœŸçš„å¼ºï¼Œç»™å¥¹è®²æ˜ç™½äº†å°±èƒ½å†™ï¼Œå†™å‡ºæ¥è¿˜ä¸€ç‚¹éƒ½æ²¡bug A5(Xinyu &amp; Faizaan)ï¼šå› ä¸ºA4æˆ‘è¦å…³å¿ƒçš„ä¸œè¥¿å¤ªå¤šï¼Œæ•´ä¸ªç»™æˆ‘æ•´è™šè„±äº†ï¼Œäºæ˜¯æˆ‘æŠŠA5å…¨æƒäº¤ç»™äº†ç¾å›½äººï¼Œç»“æœä½œä¸ºä»£ç é‡æœ€å¤§çš„projectä¹‹ä¸€ï¼Œä»–åˆæ²¡å†™å®Œï¼Œåº”è¯¥æ˜¯æˆ‘åšçš„æœ€å·®çš„ä¸€æ¬¡ä½œä¸šã€‚ä½†æ˜¯æœ€åæˆç»©æ²¡æœ‰æƒ³è±¡çš„é‚£ä¹ˆå·®ï¼Œä¸»è¦æ‰¹çš„æ¾ã€‚ A6(Xinyu &amp; Faizaan)ï¼šå› ä¸ºæˆ‘æ‡’å¾—å­¦ä¹ JavaFxä¸€å †ä¹±ä¸ƒå…«ç³Ÿçš„è¯­æ³•ï¼Œæ‰€ä»¥æˆ‘åˆå…¨æƒäº¤ç»™äº†ç¾å›½äººï¼Œè¿™ä¸ªæ—¶å€™å…¶å®æœ‰ç‚¹ç ´ç½å­ç ´æ‘”çš„æ„Ÿè§‰ã€‚åŒæ—¶æˆ‘æŠŠA5ç”¨ä¸äº†çš„åœ°æ–¹æ•´ä¸ªé‡å†™äº†ä¸€éã€‚æœ€åä¸€æ™šä¸Šéå¸¸åˆºæ¿€ï¼Œè™½ç„¶æˆ‘ä»¬deadlineä¹‹å‰ä¸€ä¸ªå°æ—¶åšå®Œäº†ï¼Œä½†æ˜¯æœ€åä¸€åˆ»æˆ‘æ”¹äº†æ”¹ä¸€äº›é”™è¯¯ä¿¡æ¯å±•ç¤ºçš„ä»£ç è®©æ•´ä¸ªGUIæ›´å¥½çœ‹ï¼Œç»“æœåœ¨æµ‹è¯•çš„æ—¶å€™å‘ç°äº†ä¸€ä¸ªbugã€‚æˆ‘ä»¥ä¸ºæ˜¯æˆ‘çš„é”™è¯¯ï¼Œäºæ˜¯git resetå›å»ï¼Œäº¤ä¸Šäº†ä»¥å‰çš„ç‰ˆæœ¬ã€‚åˆºæ¿€åœ¨äºæˆ‘å¡ç€deadlineäº¤ä¸Šçš„ï¼Œæ›´åˆºæ¿€çš„æ˜¯æˆ‘äº¤å®Œä»¥åå‘ç°æˆ‘äº¤çš„ä»ç„¶æ˜¯æœ€æ–°ç‰ˆæœ¬ï¼Œæ‰€ä»¥bugä»ç„¶å­˜åœ¨ï¼Œå¿ƒæƒ…èµ·ä¼æœ€å¤§çš„ä¸€æ™šä¸Šã€‚ï¼ˆä¸è¿‡æœ€åå‘ç°å’Œæˆ‘é‚£ä¸€ä¸ªå°æ—¶çš„æ”¹åŠ¨æ²¡å…³ç³»ï¼Œæ˜¯modelä¸æ˜¯GUIå‡ºäº†é—®é¢˜ï¼‰ A7(Xinyu &amp; Faizaan)ï¼šserveræˆ‘è§‰å¾—è¿˜æ˜¯è¦å­¦ä¸€ä¸‹çš„ï¼Œå’ŒA4ä¸€æ ·è¯•ç€å†™äº†ä¸ªç»“æ„ã€‚å°å§‘å¨˜å¸®æˆ‘æŠŠserverå…¨å†™å®Œäº†ï¼Œæœ€å¯æ€•çš„æ˜¯ä¸€ä¸ªbugéƒ½æ²¡æœ‰ï¼ŒçœŸçš„å“äººã€‚ç¾å›½äººå¯èƒ½å› ä¸ºè¦å‡†å¤‡è‡ªå·±çš„Finalï¼Œæ‰€ä»¥è¿™ä¸€æ¬¡ç«Ÿç„¶åœ¨deadlineä¹‹å‰å…­ä¸ƒä¸ªå°æ—¶å°±å†™å®Œäº†ï¼Œç„¶åæ—©æ—©æäº¤ä¸Šå»äº†ã€‚éå¸¸æ»¡æ„çš„ä¸€æ¬¡ä½œä¸šï¼ˆä¹Ÿæ˜¯é™¤A3å¤–å”¯ä¸€çš„é«˜äºmediançš„ä½œä¸šï¼‰(475 commits in total) æœ¬æ¥æŒ‡ç€Finalé‡Œé¢æ“…é•¿çš„ç®—æ³•å’Œæ•°æ®ç»“æ„ææåˆ†ï¼Œç»“æœFinalå‡ºç‚¹è¿‡äºç®€å•ï¼Œå¹¶æ‹‰ä¸å¼€åˆ†å·®ã€‚è¦æ˜¯å‡ºåˆ°å’Œç»™çš„exampleåŒä¸€ä¸ªéš¾åº¦ï¼Œæˆ‘æ˜¯æœ‰ä¿¡å¿ƒè¿™èŠ‚è¯¾æ‹¿Açš„ã€‚ MATH 2210 Linear Algebraæˆ‘çš„æ•™æˆæ˜¯ä¸ªè€çˆ·å­(James West) ï¼Œè€çˆ·å­å¿«ä¹åäº†å§ï¼Œä¸€å¥è¯è¯´åˆ°æœ€åä¸€ä¸ªè¯çš„æ—¶å€™æˆ‘å·²ç»å¿˜äº†ä»–ç¬¬ä¸€ä¸ªè¯´çš„è¯æ˜¯ä»€ä¹ˆäº†ï¼ŒäººçœŸçš„å¾ˆå¥½ï¼Œå¯æ˜¯è„‘å­ç¡®å®è€åŒ–äº†ï¼Œå¹¶ä¸æ˜¯é‚£ä¸ªæœ€å¥½çš„è®²å¸ˆã€‚ åæ¥æ¢åˆ° Myer çš„ sessionï¼Œè®²å¾—ç¡®å®ä¸é”™ï¼ˆWest é‚£é‡Œçš„äººå…¨è·‘å¥¹é‚£å»äº†ï¼‰ï¼Œæœ€åä¸€ä¸ª OH è¿˜å¤šç•™äº†ä¸‰ååˆ†é’Ÿä¸“é—¨ç»™æˆ‘æŠŠ Inner Product Space è®²æ˜ç™½äº†ï¼Œä¸€ä½ä¼˜é›…åˆå–„è‰¯çš„å¥³è€å¸ˆã€‚ DEA 1500 Intro to Environ. Psychologyæœ¬ä¸“ä¸šå”¯ä¸€ä¸€èŠ‚æˆ‘è§‰å¾—å¯ä»¥ä¸Šçš„è¯¾ï¼Œè€Œä¸”è¯„ä»·ä¹Ÿå¾ˆå¥½ï¼Œäºæ˜¯å°±ä¸Šäº†ã€‚Gary Evans ç»å¯¹æ˜¯æ•°ä¸€æ•°äºŒçš„è®²å¸ˆï¼Œæ¸…æ™°æœ‰æ¡ç†ï¼Œè¯¾ç¨‹å†…å®¹ä¹Ÿå¾ˆæœ‰è¶£ï¼ˆè™½ç„¶åæœŸæœ‰äº›åŒè´¨åŒ–ï¼‰ã€‚å¦‚æœè¯´ç¾å›½1%çš„äººæŒæ¡ç€99%çš„è´¢å¯Œï¼Œé‚£æˆ‘ä¹Ÿè¦è¯´ç¾å›½1%çš„èªæ˜å¹¶çœŸæ­£æœ‰ç€äººæ–‡æƒ…æ€€çš„äººé¢†åˆ°äº†99%çš„å‚»å­ï¼Œå°±æ˜¯è¿™1%çš„äººæ„å»ºäº†éƒ¨åˆ†äººå¿ƒç›®ä¸­çš„äººç±»æ–‡æ˜ç¯å¡”ã€‚Gary å°±æ˜¯é‚£ä¸ª1%ã€‚èƒ½ä»ä»–çš„è¯¾ä¸­æ„Ÿå—åˆ°ä»–å¯¹è¿™ä¸ªæ˜Ÿçƒç”šè‡³æ•´ä¸ªäººç±»çš„çˆ±ã€‚ Sometimes we focus on Chinaâ€™s carbon footprint and says it should regulate more. However, look at the data of the United States per capita. Iâ€™m not saying China shouldnâ€™t regulate more, but isnâ€™t it a little hypocritical to ask China to do more regulations while we are producing more than them? è™½ç„¶ä¸æƒ³æ§ä¸€è¸©ä¸€ï¼Œä½†æ˜¯Garyå…¶å®åº”è¯¥ä¹Ÿå¾ˆè€äº†ã€‚å³ä½¿å¦‚æ­¤å´ä¸€ç›´ç”¨é¥±æ»¡çš„ç²¾ç¥ä¸ºå¤§å®¶å‘ˆç°è¿™é—¨è¯¾ï¼Œæœ€åå‡ ä¸ªlectureä¸çŸ¥é“ä»–æ€ä¹ˆäº†ï¼Œæœ‰çš„æ—¶å€™ä¼šå¤±æ‰è‡ªå·±çš„å£°éŸ³ï¼Œæ•´ä¸ªå£°éŸ³çªç„¶å°±å˜å“‘äº†ï¼Œé‚£ä¸ªæ—¶å€™çœŸçš„æ˜¯å¿ƒç–¼ä»–ã€‚ä»–çš„æœ€åä¸€è¯¾æˆ‘ä¼šæ°¸è¿œè®°åœ¨å¿ƒé‡Œã€‚ æˆ‘çŸ¥é“ä½ ä»¬ä¸­æœ‰å¾ˆå¤šäººæ˜¯å„æ–¹é¢çš„ç§¯æåˆ†å­ï¼Œæ¯”å¦‚ç¯ä¿ä¸»ä¹‰è€…ï¼Œä½ æœ‰çš„æ—¶å€™ä¹Ÿè§‰å¾—ä¸ºä»€ä¹ˆå¤§å®¶éƒ½ä¸ç†è§£æˆ‘åœ¨åšçš„äº‹éƒ½æ˜¯ä¸ºäº†ä»–ä»¬å¥½ï¼Œä½ æœ‰çš„æ—¶å€™ä¹Ÿä¼šè§‰å¾—è‡ªå·±éå¸¸æ— åŠ©ã€‚æˆ‘è¦å‘å¤§å®¶å±•ç¤ºè¿™ä¸€å¥è¯ï¼šè¿™äº›åšå‡ºå·¨å¤§æ”¹å˜çš„è¿åŠ¨ï¼Œå¾€å¾€æ˜¯ç”±ä¸€å°ç¾¤äººé¢†å¯¼çš„ã€‚å›æƒ³ä¸€ä¸‹ï¼Œä»–ï¼ˆç”˜åœ°ï¼‰å½“æ—¶æ˜¯å¤§å¤šæ•°å—ï¼Ÿä»–ï¼ˆé©¬ä¸è·¯å¾·é‡‘ï¼‰ä¹Ÿä¸æ˜¯ã€‚ä½ å¯èƒ½è§‰å¾—è¿™äº›äººéƒ½æ˜¯ä¸€å¼€å§‹å°±éå¸¸ä¼Ÿå¤§çš„ â€¦ è¿™ä¸ªå½“æ—¶åªæœ‰åäºŒå²çš„å°å¥³å­©ï¼Œå‘ä¸–ç•Œæ­éœ²äº†çº³ç²¹çš„ç½ªè¡Œï¼Œå¥¹å½“æ—¶æœ‰å¤šä¹ˆå¼ºå¤§çš„èƒ½åŠ›å—ï¼Ÿâ€¦ æœ‰æ—¶ä½ å¯èƒ½ä¼šè§‰å¾—å¾ˆæ— åŠ›ï¼Œä½†æ˜¯è®°ä½Margaretè¯´äº†ä»€ä¹ˆï¼šæ°¸è¿œéƒ½æ˜¯é‚£ä¸€å°éƒ¨åˆ†äººã€‚ â€“ Gary Evans, 2019/12/09 WRIT 1370 FWS: Elements of Acad WtgBradæ˜¯ä¸ªç¨å¾®å¸¦ç‚¹ç—æ°”çš„ä¸é”™çš„äººï¼Œè™½ç„¶è¿™è¯¾å«åš Metaphor in Art, Science and Culture ä½†æˆ‘å®é™…ä¸Šè§‰å¾—ä»–å…¶å®è¿™ä¸‰ä¸ªéƒ½å¹¶ä¸å¾ˆæ‡‚â€¦ Donâ€™t be Strangers. â€“ Brad Zukovic, 2019/12/06 CS5199 Comp Program &amp; Problem Solvingç‹—å±è¯¾ï¼Œè¯¾ç¨‹éƒ½è¿›è¡Œäº†ä¸€å¤§åŠäº†æ‰å‘Šè¯‰åˆ«äººç”¨ä»€ä¹ˆæ–¹å¼è®¡ç®—attendanceï¼Œå¹¸äºæœ€åè¿æ°”å¥½åˆšåˆšå¥½åˆ°äº†passçš„çº¿ï¼Œä¸ç„¶è¦æ˜¯ç¬¬ä¸€å­¦æœŸæˆç»©å•ä¸Šå°±æœ‰ä¸ªfailæˆ–è€…withdrawï¼Œé‚£æ˜¯çœŸçš„éš¾çœ‹ã€‚ PE1395 Self DefenseæŒºå¥½ç©çš„","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"19FA","slug":"19FA","permalink":"https://harmonyano.github.io/tags/19FA/"}]},{"title":"Add pdf file to hexo","slug":"2019-12-17-add-pdf-file-to-hexo","date":"2019-12-17T05:00:00.000Z","updated":"2019-12-18T03:22:39.731Z","comments":true,"path":"2019-12-17-add-pdf-file-to-hexo/","link":"","permalink":"https://harmonyano.github.io/2019-12-17-add-pdf-file-to-hexo/","excerpt":"Say youâ€™ve put book.pdf in ./source/books/, then put something like [Download my book!](/books/book.pdf) anywhere in the article and it will create the link for you. Cited From hexo","text":"Say youâ€™ve put book.pdf in ./source/books/, then put something like [Download my book!](/books/book.pdf) anywhere in the article and it will create the link for you. Cited From hexo","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"https://harmonyano.github.io/tags/Logistics/"},{"name":"Hexo","slug":"Hexo","permalink":"https://harmonyano.github.io/tags/Hexo/"}]},{"title":"Problem Analysis","slug":"2019-12-05-Problem-Analysis","date":"2019-12-05T05:00:00.000Z","updated":"2019-12-18T03:24:32.793Z","comments":true,"path":"2019-12-05-Problem-Analysis/","link":"","permalink":"https://harmonyano.github.io/2019-12-05-Problem-Analysis/","excerpt":"From Lecture: Hard problems and undecidability Computable ProblemTime ComplexityTractable Problems (P)Polynomial algorithms: $O(n^k)$ for some k ($k\\leq4$)","text":"From Lecture: Hard problems and undecidability Computable ProblemTime ComplexityTractable Problems (P)Polynomial algorithms: $O(n^k)$ for some k ($k\\leq4$) Exponential Time (EXPTIME)Exponential Time algorithm: $O((2^k)^n)$ Nondeterministic Polynomial Problems (NP)e.g.: Hamilton cycles, SAT (Boolean satisfiability), Graph coloring How would you solve a very hard problem? If you have enough resources (space &amp; time), you can just randomly generate some results and check the resultâ€™s correctness. Therefore, the key is that you have to check the correctness in deterministic time (polynomial time). In fact, all of them can be solved by exponential-time algorithms that essentially try all exponentially many possible solutions, but this approach is infeasible NP-Complete: All NP problems can be expressed using the three NP examples above. These three problems are said to be NP-Complete. In fact, SAT is the most frequently used one. There are many people working on how to solve well-formed SAT problems in a reasonable amount of time. e.g. You can transform a Hamilton cycle problem into an SAT problem and use those SAT algorithms to solve it Space Complexity L: logarithmic space PSPACE: polynomial space NPSPACE: nondeterministic polynomial space Inclusion Relationships$L\\sube P\\sube NP \\sube PSPACE = NPSPACE \\sube EXPTIME$ Unknow Problems $O(Factoring)\\in P$ ? NP = EXPTIME ? P = NP ? L = P ? because Lâ‰ PSPACE, we know that at least one of the inequalities Lâ‰ P, Pâ‰ NP, and NPâ‰ PSPACE must hold, but we donâ€™t know which. Incomputable Problems (Halting Problem)interpretclaim: we can convert a program to an AST we can build an interpreter for the AST We have a simple program p that returns only a boolean value. If we canâ€™t determine whether such simple programs terminate, then of course we have no hope of determining whether more complex programs do. 12345678/** @return result of p on input i or does not terminate if p couldn&#x27;t terminate on input i*/boolean interpret (Program p, Object i) class p &#123; boolean main(Object i)&#123;...&#125;&#125; method interpretis correct $\\iff$ $\\forall(p,i)$ p.main(i)==interpret(p,i) terminate12/** Return whether p would halt on i */boolean terminates(Program p, Object i) Autological &amp; HeterologicalA program is either autological or heterological: autological: program is autological if it returns true when provided its own AST (return value for other inputs not defined) heterological: either returns false on itself as input or doesnâ€™t terminate Self-ReferenceYou cannot build both interpret and terminates for a program. 12345678910class H&#123; /** returns whether P is heterological (either doesn&#x27;t terminate or return false) */ boolean main(Program p)&#123; if(terminates(p,p)) return !interpret(p,p); //terminate but returns false, so p is heterological else return true; // doesn&#x27;t terminate, so p is heterological &#125;&#125; canâ€™t directly return !interpret(p,p) because we are not sure whether P will terminate. Therefore, we have to first check whether it terminates or not. Now we want to pass H itself to H.main note: H can always terminate no matter what p is (because if p terminates, it calls interpret, which always returns a value if p terminates; if p doesnâ€™t terminate, it just returns a boolean value of true) Therefore, if we pass H itself, it goes into the if (terminates) &#123;&#125; block, which returns ! interpret(h,h) = !h.main(h) Therefore, calling h.main(h) actually returns !h.main(h) But how can h returns the negation of what itâ€™s supposed to return? Therefore, there doesnâ€™t exist a program like h. \\ Therefore, we cannot build both interpret and terminate. Since we can and did build an interpreter, terminate is what we canâ€™t really build. Thatâ€™s the why this problem is called a â€œhalting problemâ€. ImplicationsTheoretical ImplicationsEvery language is either: too expressive to analyze termination precisely (incomplete) not expressive to build on interpreter (inconsistent) makes a program like H illegal (impossible to be both comprehensive and consistent) practical implicationse.g. Can we write a IntelliJ plugin to check NullPointerException? if NPE is decidable, consider the codes below 123h;x = null;x.hashcode(); // It should give you an error at this line at compile-time, which means the program can determine whether the program will actually run to this line, which means the program can determine whether h terminates Reduction: if algorithm for problem A can be used to solve B (with suitable efficiency), A must be at least as hard as B. (In the example of above A: NPE checker B: halting problem)","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"19FA","slug":"19FA","permalink":"https://harmonyano.github.io/tags/19FA/"},{"name":"CS2112","slug":"CS2112","permalink":"https://harmonyano.github.io/tags/CS2112/"}]},{"title":"Priority Queue and Heap","slug":"2019-11-26-Priority-Queue-and-Heap","date":"2019-11-26T05:00:00.000Z","updated":"2019-12-18T03:24:37.089Z","comments":true,"path":"2019-11-26-Priority-Queue-and-Heap/","link":"","permalink":"https://harmonyano.github.io/2019-11-26-Priority-Queue-and-Heap/","excerpt":"From Lecture: Heaps and priority queues Priority Queue1234567interface PriorityQueue&lt;E&gt; &#123; void increasePriority(E x, int priority) //constructor PriorityQueue (ElemOps&lt;E&gt; ops);&#125;","text":"From Lecture: Heaps and priority queues Priority Queue1234567interface PriorityQueue&lt;E&gt; &#123; void increasePriority(E x, int priority) //constructor PriorityQueue (ElemOps&lt;E&gt; ops);&#125; Binary HeapInvariant Order: n.priority&lt;=n.child.priority (å°æ ¹å †) shape: All leaves are at depth h or h-1 All h-depth are on the left This heap is in fact a complete binary tree ImplementationSwimif parents have bigger priority, this node should swim. Sinkif any of the child has higher priority (smaller value), we swap this node with the one with a higher priority (the smaller one). And we only sink when there is actually something to sink (we are at the second deepest level, one level above the leaves) ä½†æ˜¯è¦æ³¨æ„ï¼Œæœ‰çš„æ—¶å€™ä½ æƒ³è¦sinkï¼Œä½†æ˜¯ä½ çš„å­©å­å®é™…ä¸Šæ˜¯æœªè¢«åˆå§‹åŒ–çš„ä¸€äº›æœ‰ç€éšæœºä¼˜å…ˆå€¼çš„ç»“ç‚¹ï¼Œè¿™æ—¶å¦‚æœä½ åšäº¤æ¢äº†ï¼Œé‚£å°±å…¨å®Œäº†ã€‚æ‰€ä»¥åº”å½“åˆ¤æ–­è¿™ä¸ªå­©å­ç»“ç‚¹åŸæœ¬åœ¨ä¸åœ¨å †ä¸­ AddWe should preserve both the invariant when adding one element. shape: Ifwe add it at the end of the heap, shape invariant is preserved order: This invariant can be broken (though itâ€™s at the end, it may not be the node with lowest priority) . So this newly added element should swim. Extractextract the head of the heap. But we need to replace it with something to preserve the invariant. shape: The last element in the array is a good candidate. We move it to the root of the tree. This reestablishes the shape invariant order: This invariant may now be broken. We fix the heap invariant by sinking the root è¦æ³¨æ„æˆ‘ä»¬åšä»»ä½•åˆ é™¤æ“ä½œçš„æ—¶å€™ï¼Œè¦ç¡®ä¿è¿™ä¸ªå…ƒç´ å·²ç»ä¸åœ¨æ•°ç»„ä¸­äº†(1. é•¿åº¦â€“ 2. åŸæœ¬çš„indexè®¾ä¸ºLOWEST_PRIORITY ç¡®ä¿å®ƒæ°¸è¿œåœ¨å †åº•å¾…ç€) Change in Priority shape: maintained order: we may need to bubble the element up if we increase the priority (which for a min-queue means decreasing the value) or down if we decrease the priority. You need to know the nodeâ€™s index to perform swimming and sinking. But if the node is an object, how would you know its index? We can store its index inside the object. HeapifyHere is a very efficient way to turn an arbitrary array into a heap. Heapifying can be done by bubbling every element down, starting from the last element in the second last layer (å¶å­çš„å‰ä¸€å±‚ï¼Œå¶å­é‚£ä¸€å±‚æ²¡æœ‰å¯ä»¥sinkçš„ä¸œè¥¿ï¼Œæˆ–è€…è¯´ï¼Œå¶å­é‚£ä¸€å±‚çš„Heap Invariantæ˜¯ç»å¯¹è¢«ä¿å­˜çš„ï¼Œç¬¬ä¸€ä¸ªHeap Invariantä¸è¢«ä¿å­˜çš„èŠ‚ç‚¹æ˜¯å€’æ•°ç¬¬äºŒå±‚çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹) in the array representation and working backward. The total time required to do this is linear. At most half the elements need to be bubbled down one step (å€’æ•°ç¬¬äºŒå±‚ï¼Œå¶å­å‰ä¸€å±‚), at most a quarter of the elements need to be bubbled down two steps (å€’æ•°ç¬¬ä¸‰å±‚ï¼Œå¶å­å‰ä¸¤å±‚), and so on. Time Complexity: $n/2 + 2n/4 + 3n/8 + 4n/16 + â€¦ + k^n/2k + â€¦ = 2n.$ This method tells us to start from the end and bubble down. However, we can also start from the front and bubble up. The only difference is that up is slower than down in total (think about how many nodes have to go through how many layers to get to the correct position for each kind of heapify). We can also try bubbling down from the front or bubbling up from the end. These two methods are incorrect. Because when we bubble up from the front, we can guarantee that the nodes we have looped through and its parent can form a heap. Similarly, when we bubble down from the end, we can guarantee that the nodes we have looped through and its children can form a heap. However, for bubbling down from the front and bubbling up from the end, no such qualities can be guaranteed. Resizable ArrayYou can store your heap in a resizable array with a load factor as weâ€™ve seen in the HashTables. Code in C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;chrono&gt;#include&lt;time.h&gt;using namespace std;const int M=1000000,INF=10e9; int n=0,a[M];void swim(int); void sink(int);void add(int); int extract(); int head(); void print(); int height(int);int main()&#123; /* å †æ’åºå°æµ‹è¯• int num; cin&gt;&gt;num; for(int i=0;i&lt;num;i++) &#123;int now; cin&gt;&gt;now; add(now);&#125; for(int i=0;i&lt;num;i++) cout&lt;&lt;&quot;extracted&quot;&lt;&lt;extract()&lt;&lt;endl&lt;&lt;endl;*/ /* æ´›è°·P3378 æ¨¡æ¿ å † int result[M/2],ans=0; int num; cin&gt;&gt;num; for(int i=0;i&lt;num;i++)&#123; int command; cin&gt;&gt;command; switch(command)&#123; case 1: int adding; cin&gt;&gt;adding; add(adding); break; case 2: result[ans++]=head(); break; case 3: extract(); break; &#125; &#125; for(int i=0;i&lt;ans;i++) cout&lt;&lt;result[i]&lt;&lt;endl;*/ /* heapify æ—¶é—´æµ‹è¯• ç†è®ºä¸Šæ¥è¯´sinkæ¯”swimè¦å¿«(éœ€è¦çš„æ“ä½œå°‘) ä½†æ˜¯å¤§æ¦‚å› ä¸ºæˆ‘çš„sinkçš„å®ç°æ–¹æ³•å¤ªçƒ‚ï¼Œæ‰€ä»¥ç«Ÿç„¶ swim å¿«ä¸€ç‚¹ int max = 100000;n=max; for(int i=0;i&lt;max;i++) a[i] = max-i; auto t0 = std::chrono::system_clock::now(); for (int i = (n/2); i &gt; 0; i--) sink(i); //for(int i=2;i&lt;=n;i++) &#123;swim(i);&#125; auto t1 = std::chrono::system_clock::now(); using milliseconds = std::chrono::duration&lt;double, std::milli&gt;; milliseconds ms = t1 - t0; std::cout &lt;&lt; &quot; time taken by my code: &quot; &lt;&lt; ms.count() &lt;&lt; &#x27;\\n&#x27;;*/ return 0;&#125;void swim(int i)&#123; while(a[i/2]&gt;=a[i]&amp;&amp;i&gt;1)&#123; //æ³¨æ„è¾¹ç•Œçš„é€‰æ‹©ï¼ši&lt;=1çš„è¯ä¸Šé¢å·²ç»æ²¡ä¸œè¥¿äº†ï¼Œå°±æ²¡æœ‰å†ä¸Šæ¸¸çš„å¿…è¦äº† swap(a[i/2],a[i]); i = i/2; &#125;&#125;void sink(int i)&#123; int l=i*2, r=i*2+1; while((a[i]&gt;=a[l]||a[i]&gt;=a[r])&amp;&amp;i&lt;pow(2,height(n)))&#123;//å¶å­çš„ä¸Šä¸€å±‚æ‰éœ€è¦ä¸‹æ²‰ï¼Œå¶å­é‚£ä¸€å±‚æ²¡æœ‰ä¸œè¥¿å¯ä»¥æ²‰ if(a[l]&lt;=a[r]&amp;&amp;l&lt;=n)&#123; //l&lt;=nåˆ¤æ–­è¿™ä¸ªå­©å­ç»“ç‚¹ç¡®å®åœ¨å †ä¸­ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªå †å¤–ä½†åœ¨æ•°ç»„ä¸­çš„ç»“ç‚¹ //æœ‰é—®é¢˜ï¼Œè¿™ä¸ªåœ°æ–¹å¦‚æœä¸æŠŠæ¯ä¸ªåˆ æ‰çš„å…ƒç´ è®¾ä¸ºINFçš„è¯ï¼Œrä¼šä¸€ç›´å­˜åœ¨åœ¨æ•°ç»„ä¸­ï¼› //è€ƒè™‘2 1 (0) çš„æƒ…å†µï¼Œå…¶ä¸­0æ˜¯å·²ç»è¢«åˆ æ‰çš„å…ƒç´ ï¼Œä½†æ˜¯å› ä¸ºa[r]=0&lt;a[l]=1æ‰€ä»¥2ä¸ä¼šsink //å¦‚æœå°†æ•°ç»„åˆå§‹åŒ–æˆINFçš„è¯ï¼Œå°±ä¸éœ€è¦åœ¨ä¸åœ¨å †å†…l&lt;=nè¿™ä¸ªæ¡ä»¶åˆ¤æ–­äº† //ä½†æ˜¯å†…å­˜å ç”¨ä¼šæå¤§æé«˜ï¼Œå› ä¸ºæ•´ä¸ªé•¿ä¸ºMçš„æ•°ç»„éƒ½è¢«åˆå§‹åŒ–äº† swap(a[i],a[l]); i = l; l=i*2; r=i*2+1; continue; &#125; else if (a[l]&gt;a[r]&amp;&amp;r&lt;=n)&#123; swap(a[i],a[r]); i = r; l=i*2; r=i*2+1; continue; &#125; else return; &#125;&#125;void add(int i)&#123; a[++n] = i; swim(n);&#125;int extract()&#123; int result = a[1]; swap(a[1],a[n]); a[n--]=INF; sink(1); return result;&#125;int head()&#123;return a[1];&#125;// returns the height of a complete binary tree with n nodesint height(int x)&#123; if(x==0) return 1; int digit=0; while(x&gt;0) &#123;x=x&gt;&gt;1; digit++;&#125; return digit;&#125;void print()&#123;for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl;&#125; 0-1 Basedä¸Šé¢æ˜¯ç”¨Binary heapè®¾è®¡ä¸€ä¸ª Max-oriented Priority Queueï¼Œ æ•°ç»„æ˜¯1-basedã€‚ å‡å¦‚é‡åˆ°é¢è¯•å®˜é—®æ€ä¹ˆheapifyæ€ä¹ˆåŠï¼Ÿ ä¸‹é¢æˆ‘ä»¬å°±å¯¹ä¸Šé¢ä»£ç è¿›è¡Œå°‘è®¸æ”¹åŠ¨ï¼Œå˜ä¸º0-basedï¼Œå¯ä»¥ç›´æ¥å¯¹æ•°ç»„è¿›è¡Œmax - heapifyã€‚ heapify()æ–¹æ³•: å¯ä»¥çœ‹å‡ºæˆ‘ä»¬çš„heapifyæ–¹æ³•åŸºæœ¬æ²¡æœ‰å˜åŒ–ï¼Œé™¤äº†æŠŠN / 2å˜æˆäº†æ•°ç»„çš„é•¿åº¦ nums.length / 2 sink()æ–¹æ³• : è¿™é‡Œæˆ‘ä»¬è¦æ³¨æ„ä¸€ä¸‹è¾¹ç•Œæ¡ä»¶ã€‚ å…ˆè®¾ç½®len = nums.lengthï¼Œè¿™é‡Œlenå°±ç›¸å½“äºä¹‹å‰çš„Nï¼Œ ç„¶åå†è¿›è¡Œæ¯”è¾ƒçš„æ—¶å€™ï¼Œæˆ‘ä»¬è¦æŠŠæ¯æ¬¡çš„ j éƒ½å‡1ï¼Œä»1-basedæ”¹å˜ä¸º 0-basedï¼Œå…¶ä»–ä»£ç éƒ½ä¸éœ€è¦æ”¹å˜ 1234567891011121314151617181920212223public static void heapify(int[] nums) &#123; if (nums == null) &#123; return; &#125; for (int k = nums.length / 2; k &gt;= 1; k--) &#123; sink(nums, k); &#125; &#125; private static void sink(int[] nums, int k) &#123; int len = nums.length; while (2 * k &lt;= len) &#123; int j = 2 * k; if (j &lt; len &amp;&amp; nums[j - 1] &lt; nums[j]) &#123; j++; &#125; if (nums[k - 1] &gt; nums[j - 1]) &#123; break; &#125; swap(nums, k - 1, j - 1); k = j; &#125; &#125;","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"19FA","slug":"19FA","permalink":"https://harmonyano.github.io/tags/19FA/"},{"name":"CS2112","slug":"CS2112","permalink":"https://harmonyano.github.io/tags/CS2112/"}]},{"title":"Udacity: Android Basics","slug":"2019-11-23-Android-Basics-User-Interface","date":"2019-11-23T05:00:00.000Z","updated":"2019-12-18T03:02:23.239Z","comments":true,"path":"2019-11-23-Android-Basics-User-Interface/","link":"","permalink":"https://harmonyano.github.io/2019-11-23-Android-Basics-User-Interface/","excerpt":"User InterfaceImages &amp; Texts wrap content: android:layout_height=&quot;wrap_content&quot; dp: density-independent pixel text size: android:textsize=&quot;20sp&quot; sp: scalar-independent pixel background and text color: android:background=&quot;#66ffcc&quot; android:textColor=&quot;66ccff&quot;","text":"User InterfaceImages &amp; Texts wrap content: android:layout_height=&quot;wrap_content&quot; dp: density-independent pixel text size: android:textsize=&quot;20sp&quot; sp: scalar-independent pixel background and text color: android:background=&quot;#66ffcc&quot; android:textColor=&quot;66ccff&quot; View GroupsLinear Layout linear layout: similar to Hbox and Vbox in javaFX, one linear layout can contain many other linear layouts weight values: give different weights to layouts to determine what proportion of the space they should take in the screen Relative Layout relative layout to parent:android:layout_align_Parent(Top/Bottom/Left/Right) = &quot;true/false&quot;; android:layout_center(Horizontal/Vertical)=&quot;true&quot; assigning ID: android:id = &quot;@+id/ben_textview&quot; (used â€œ+â€ because we added a new ID to the library) referring to ID: android:id = &quot;@id/ben_textview&quot; (no longer need the â€œ+â€ here) relative layout to others: android:layout_to(Right/Left)Of=&quot;@id/pic&quot; Multiscreen AppsAdd texts to the Layoutwith List12345678910111213ArrayList&lt;String&gt; words;//findViewById only returns a View, we should downcast it to a LinearLayoutLinearLayout rootView = (LinearLayout) findViewById(R.id.rootView);for(String word:words)&#123; //TextView takes into a context, in this case is &quot;this&quot; TextView wordView = new TextView(this); wordView.setText(word); //add wordView to the this View of List(LinearLayout) rootView.addView(wordView);&#125; However, a LinearLayout is not scrollable and can easily go beyond the screen. Therefore, we should use an ArrayAdapter with ArrayAdapter123ArrayAdapter&lt;Word&gt; itemsAdapter = new WordAdapter(this, words);ListView listView = (ListView) findViewById(R.id.list);listView.setAdapter(itemsAdapter); We have to create two more classes: a Word class, and a customized WordAdapter that extends ArrayAdapter&lt;Word&gt;. We also have to create another XML file to customize the display of one item in the list.","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://harmonyano.github.io/tags/Android/"}]},{"title":"Import Junit and JavaFx into VSCode","slug":"2019-11-21-import-Junit-and-JavaFx-into-VSCode","date":"2019-11-21T05:00:00.000Z","updated":"2019-12-18T03:05:06.747Z","comments":true,"path":"2019-11-21-import-Junit-and-JavaFx-into-VSCode/","link":"","permalink":"https://harmonyano.github.io/2019-11-21-import-Junit-and-JavaFx-into-VSCode/","excerpt":"The import javafx cannot be resolvedI have java 11 installed on my computer. JavaFx was not bundled with Java 11 so I have to first download it from here and put it at the same directory as Java jdk. But VScode still gives me the error â€œThe import javafx cannot be resolvedâ€. This was resolved after I ran Java: Clean the Java Language Server workspace, though I have no idea how VSCode magically found the directory of JavaFx.","text":"The import javafx cannot be resolvedI have java 11 installed on my computer. JavaFx was not bundled with Java 11 so I have to first download it from here and put it at the same directory as Java jdk. But VScode still gives me the error â€œThe import javafx cannot be resolvedâ€. This was resolved after I ran Java: Clean the Java Language Server workspace, though I have no idea how VSCode magically found the directory of JavaFx. The import Junit.Jupiter cannot be resolvedI downloaded Junit.Jupiter.api (the package I used for my tests) from here and put the jar file under workspace\\lib. Then problem was solved. Tests are now runnable.","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"https://harmonyano.github.io/tags/Logistics/"},{"name":"Java","slug":"Java","permalink":"https://harmonyano.github.io/tags/Java/"}]},{"title":"Shortest path algorithm","slug":"2019-11-21-shortest-path-algorithm","date":"2019-11-21T05:00:00.000Z","updated":"2019-12-18T03:24:39.397Z","comments":true,"path":"2019-11-21-shortest-path-algorithm/","link":"","permalink":"https://harmonyano.github.io/2019-11-21-shortest-path-algorithm/","excerpt":"From Lecture: Dijkstraâ€™s shortest path algorithm Dijkstra white: dist == infinity gray: dist &lt; infinity, in queue black: dist &lt; infinity, not in queue","text":"From Lecture: Dijkstraâ€™s shortest path algorithm Dijkstra white: dist == infinity gray: dist &lt; infinity, in queue black: dist &lt; infinity, not in queue 123456789101112131415root.dist = 0; //root is the sourcefrontier.push(root); //root is now greywhile(!frontier.empty())&#123; Node g = frontier.pop(); for (g -&gt; v)&#123; if(v.dist==infinity)&#123; //found a new white node v.dist = g.dist + d; frontier.push(v); &#125; else&#123; // v is grey v.dist = min(v.dist, g.dist+d); &#125; &#125; //g is now black&#125; v1 and v2 is on the best path iff v1.dist+d=v2.dist Therefore, if we want to get the shortest path, we can use this algorithm to walk straight back to the graph from destination. PerformanceTotal: O((V+E)lgV) outer loop: O(V lgV) once per vertex, O(V) iterations finding min element in the queue once: O(lg V) - BST or heap inneer loop: O(E lgV) O(E) iterations time to push/update priority queue: O(lg V) CorrectnessLoop Invariant: For every black node b, gray g: b.dist&lt;=g.dist v.dist is length of shortest interior path to v (or infinity if none) (interior path means it stays in the black region, which means it only uses black nodes) Establishment:no black nodes PostCondition: no gray nodes all the nodes are black -&gt; All paths are interior path -&gt; shortest: interior path is actual answer Preservation:ä¸å†™äº†ï¼ŒğŸ‘´ åé¢çœ‹ä¸æ‡‚äº†ã€‚ Application:if you have something like condition probability which has to be multiplied to produce the correct result. But so you want to know the shortest probability there. You can just take the log of probability. For example, suppose that we had a state machine that transitioned to new states with some given probability on each outgoing edge. The probability of taking a particular path through the graph would then be the product of the probabilities on edges along that path. We can then answer questions such as, â€œWhat is the most likely path that the system will follow in order to arrive at a given state?â€ by solving a shortest path problem in a weighted graph in which the weights are the negative logarithms of the probabilities, since $(âˆ’log a) + (âˆ’log b) = âˆ’log ab$.","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"19FA","slug":"19FA","permalink":"https://harmonyano.github.io/tags/19FA/"},{"name":"CS2112","slug":"CS2112","permalink":"https://harmonyano.github.io/tags/CS2112/"}]},{"title":"Graph (Recitation)","slug":"2019-11-20-Graph-(Recitation)","date":"2019-11-20T05:00:00.000Z","updated":"2019-11-23T17:13:46.747Z","comments":true,"path":"2019-11-20-Graph-(Recitation)/","link":"","permalink":"https://harmonyano.github.io/2019-11-20-Graph-(Recitation)/","excerpt":"From Recitation: Euler paths, planar graphs, and Hamiltonian paths Edge ClassificationWe have an edge e=(v,child), where v is always grey Tree edge: 12if (child.color==white) e = TreeEdge;","text":"From Recitation: Euler paths, planar graphs, and Hamiltonian paths Edge ClassificationWe have an edge e=(v,child), where v is always grey Tree edge: 12if (child.color==white) e = TreeEdge; Back edge: 12if (child.color==grey) e = BackEdge; Forward edge: 12if (child.color==black &amp;&amp; v.timeStamp&lt;child.timeStamp) e = ForwardEdge; Cross edge: 12if (child.color==black &amp;&amp; v.timeStamp &gt; child.timeStamp) e = ForwardEdge;","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"19FA","slug":"19FA","permalink":"https://harmonyano.github.io/tags/19FA/"},{"name":"CS2112","slug":"CS2112","permalink":"https://harmonyano.github.io/tags/CS2112/"}]},{"title":"Graph Traversal","slug":"2019-11-19-Graph-Traversal","date":"2019-11-19T05:00:00.000Z","updated":"2019-11-23T17:13:25.840Z","comments":true,"path":"2019-11-19-Graph-Traversal/","link":"","permalink":"https://harmonyano.github.io/2019-11-19-Graph-Traversal/","excerpt":"From Lecture: Graph traversals Tricolor AlgorithmIt is a general model of many graph traversal algorithms. Invariant: there is no black-&gt;white edge","text":"From Lecture: Graph traversals Tricolor AlgorithmIt is a general model of many graph traversal algorithms. Invariant: there is no black-&gt;white edge 123456781. color all nodes white2. color roots gray3. while(some gray node g)&#123; color g&#x27;s white sucessors grey if (no more white successors)&#123; color g black; &#125;&#125; At the end of this algorithm, there will be no grey nodes in the graph. All reachable nodes are black, while all unreachable nodes are white. Properties unique to different tricolor algorithm: which successor in which order to color grey? whether and when to color g black BFS Gray Frontier: FIFO queue v.distance = length of shortest path from root to v OR infinity if no path yet v.color==black means v.dist!=infinity &amp; v is not in queue set v.distance = infinity for all v set root.distance = 0, queue.push(root) (root.color=gray) ```javawhile(!frontier.empty()){ Node v=frontier.pop(); for (Node v&gt;g) // v is g&#39;s successor if(v.dist==infinity)&#123; // v.color==white v.distance = g.distance+1; frontier.push(v); &#125; //g is now black: g.color = black } 1234567891011121314151617181920212223## DFS- use LIFO stack- OR use recursion### Recursion:```java/** Effect: mark all nodes black that are reachable from v on all white paths. Requires: v is gray. */void visit(Node g) &#123; for (Node v&gt;g)&#123; if(v.color==white)&#123; v.color = gray; visit(v); &#125; &#125; g.color = black;&#125; cycle detection: grey -&gt; grey Therefore, if we reach a gray successor in DFS, we found a cycle DFS therefore gives linear-time cycle detection topological sort: DFS runs in a postorder traversal way: Node finishes after all descendants/dependents finished toposort = reversal postorder traversal","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"19FA","slug":"19FA","permalink":"https://harmonyano.github.io/tags/19FA/"},{"name":"CS2112","slug":"CS2112","permalink":"https://harmonyano.github.io/tags/CS2112/"}]},{"title":"Synchronization","slug":"2019-11-12-synchronization","date":"2019-11-12T05:00:00.000Z","updated":"2019-11-23T17:13:09.990Z","comments":true,"path":"2019-11-12-synchronization/","link":"","permalink":"https://harmonyano.github.io/2019-11-12-synchronization/","excerpt":"From Lecture: Synchronization Monitoridea: object state guarded by its mutex monitor is just a class, whose all public methods â€œsynchronize,â€ which means you canâ€™t access state without holding mutex Principal: let short methods hold the mutex in case it doesnâ€™t affect performance","text":"From Lecture: Synchronization Monitoridea: object state guarded by its mutex monitor is just a class, whose all public methods â€œsynchronize,â€ which means you canâ€™t access state without holding mutex Principal: let short methods hold the mutex in case it doesnâ€™t affect performance 12T1: add(elem)T2: size(); contains(elem); when elem is added, it may not be seen in size. So add should be written as synchronized add (T elem) &#123;&#125; Locks &amp; Deadlock Lock is achieved by a mutex deadlocks happen when all threads end up being blocked by a mutex e.g.123456class a&#123; synchronized f()&#123; b.g();&#125;&#125;class b&#123; synchronized g() &#123; a.f() &#125;&#125; 12T1: a.f() ---&gt; b.g()T2: b.g() ---&gt; a.f() Say we first go into T1, we acquire a; Then before going into b.g() in T1, we acquire b.g() in T2. Then we get into a deadlock cause we canâ€™t get b.g() in a.f() nor vice versa. Thatâ€™s because we wrote a lock acquisition order in cycle Solution: no cycle write an order in which to acquire mutex e.g. a&lt;b: canâ€™t acquire a after b (which makes b.g() illegal) And then write a spec /** Requires: lock level &lt; a */ acquire mutex in the same order (T1: A,B; T2: A,B instead of T2: B,A) Barriersin scientific computation, there are many computations embarrassingly parallel span N threads and wait until they are all done updates before barrier will be seen by all threads after the barrier 123b = new CyclicBarrier(N); // N is the number of threads(without R/W sharing)// after each thread finishes executing, it will wait(), until all threads are done// (the barrier blocks everything until N await() are called) Blocking AbstractionsHow to build your own threads-blocking abstractions? e.g.12345678910111213141516171819202122232425/** computes two threads seperately and then add them together*/class WorkerPair extends Runnable&#123; int done=0; // # threads done (0~2) Object result; WorkerPair()&#123; new Thread(this).start(); new Thread(this).start(); &#125; public void run()&#123; realDoWork(); //TODO implement this synchronized(this)&#123; // Why not put a synchronized around run()? because then only one thread will really realDoWork(); done++; result = something; &#125; &#125; Object getResult()&#123; while(done&lt;2)&#123;...&#125; return result; &#125; &#125; Condition Variables allow you to block things until some condition is true a condition variable is always associated with a mutex every Java object has its own condition variable, which ties to its own mutex A notifyAll() is sent whenever any of the conditions may become true; threads awakened by notifyAll() then test to see if their particular condition has become true; otherwise, they go back to sleep. 12345678/** Effect: blocks thread and releases mutex, wait for some condition to become true(note: why should wait() release mutex? Becuase when the program enters this waiting thread, this thread first acquires mutex, so when it begins to wait, it has to release it so other threads can do their work and finally wake it up after done) Requires: mutex is held*/void wait();/** Effect: return all wait() method (Unblocks/Wake up all threads that are waiting) Requires: mutex held*/void notifyAll(); To block until condition is true: 12345678910111213public void run()&#123; realDoWork(); synchronized(this)&#123; done++; result = something; notifyAll(); &#125;&#125;synchronized Object getResult()&#123; while(done&lt;2) wait(); return result;&#125; while (!condition) wait(); is the most usual way to write a condition variable wait(): wait for some condition to be true, which is determined by other threads notifyAll() called after whatever some of the operations already done can probably wake some method up","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"19FA","slug":"19FA","permalink":"https://harmonyano.github.io/tags/19FA/"},{"name":"CS2112","slug":"CS2112","permalink":"https://harmonyano.github.io/tags/CS2112/"}]},{"title":"Concurrency","slug":"2019-11-07-Concurrency","date":"2019-11-07T05:00:00.000Z","updated":"2019-11-23T17:14:51.488Z","comments":true,"path":"2019-11-07-Concurrency/","link":"","permalink":"https://harmonyano.github.io/2019-11-07-Concurrency/","excerpt":"From Lecture: Concurrency Concurrency and Parallelism Concurrency: multiple threads (java level, can be executed by one core or multiple core) parallelism: multiple cores (hardware level. can execute one thread or multiple thread)","text":"From Lecture: Concurrency Concurrency and Parallelism Concurrency: multiple threads (java level, can be executed by one core or multiple core) parallelism: multiple cores (hardware level. can execute one thread or multiple thread) 123456789import java.lang.Thread;class Thread&#123; /** starts a new thread executing run() */ void start(); /** Effect: anything; but default does nothing*/ void run();&#125; run() é‡Œé¢å°±æ˜¯å†™çš„è¿™ä¸ªthreadåˆ°åº•åº”è¯¥å¹²ä»€ä¹ˆ Threads InterferenceBest approach: most objects owned by 1 thread Read-Only sharing ok Read/Write sharing | Write/Write sharing dangerous 1234567891011class Account &#123; int balance; void withdraw(int n) &#123; int b = balance - n; // R1\u0001 balance = b; // W1\u0001 &#125; void deposit(int n) &#123; int b = balance + n; // R2\u0001 balance = b; // W2\u0001 &#125;&#125; e.g. initial balance: $100, T1 executes witdraw(50), T2 executes deposit(50) (R1, W1, R2, W2) or (R2, W2, R1, W1), the final balance is indeed $100. (R1, R2, W2, W1) destroys $50 -&gt; $50 (R2, R1, W1, W2) creates â€‹$50 -&gt; $150 We therefore want deposit, withdraw method to be (or at least act to be) atomic (indivisible), as if this sentence cannot be influenced by other threads (reading and writing are happening simultaneously) . Mutex(mutual exclusion locks) Threads can acquire them and release them. At most one thread can hold a mutex at a time. While a mutex is being held by a thread, all other threads that try to acquire it will be blocked until it is released, at which point just one waiting thread will manage to acquire it. every write and read to a shared mutable variable, mutex must be held 1234567/** Effect: blocks current thread until mutex is held by another thread then acquires mutex */acquire();/** Effect: release mutex */release(); 12345synchronized(Object o)&#123; //acquire o&#x27;s mutex ... // do some operations //release o&#x27;s mutex&#125; Take deposit &amp; withdraw as an example: 123456789void withdraw(int n) &#123; //do something synchronized(this) &#123; //acquire o&#x27;s mutex balance -= n; //release o&#x27;s mutex &#125; //do something else&#125; Because the pattern of wrapping entire method bodies in synchronized(this) is so common, Java has syntactic sugar for it: 123synchronized void withdraw(int n) &#123; balance -= n;&#125; Whenever mutex is not held, that variable guarded by the mutex will change unpredictably and the invariant will not hold as long as we called synchronized someMethodName() or synchronized(this). Everything in this object/class this will be held mutex (?). So we want to write small methods and small classes. As mentioned previously: Best approach: most objects owned by 1 thread Conclusion avoid unnecessary concurrency: slows down the program limit sharing of mutable state: we donâ€™t have to care about concurrency if its immutable(read only) guard all accesses to shared mutable state with mutexes: in case of thread interference","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"19FA","slug":"19FA","permalink":"https://harmonyano.github.io/tags/19FA/"},{"name":"CS2112","slug":"CS2112","permalink":"https://harmonyano.github.io/tags/CS2112/"}]},{"title":"Designing and documenting interfaces and implementations","slug":"2019-10-17-Designing-and-documenting-interfaces-and-implementations","date":"2019-10-17T04:00:00.000Z","updated":"2019-11-23T17:11:57.725Z","comments":true,"path":"2019-10-17-Designing-and-documenting-interfaces-and-implementations/","link":"","permalink":"https://harmonyano.github.io/2019-10-17-Designing-and-documenting-interfaces-and-implementations/","excerpt":"From Lecture: Designing and documenting interfaces and implementations An Example of Writing Interface1. Overview: what concerns? 12/** An n*n mutable 2048 puzzle. */class Puzzle&#123;&#125;","text":"From Lecture: Designing and documenting interfaces and implementations An Example of Writing Interface1. Overview: what concerns? 12/** An n*n mutable 2048 puzzle. */class Puzzle&#123;&#125; 2. Choose operations creators create objects constructors factory methods (usually static, loose coupling; donâ€™t expose the choice of which class is being constructed) 12public Puzzle(int n)&#123;&#125; public static Puzzle create(int n)&#123;&#125; observers(queries): primary purpose: report the state of object no side effect (doesnâ€™t change anything) mutators (command): primary purpose: side effect on the state of the object only makes sense when the object is mutable should maintain class invariants Command-Query Separation: You have to decide whether this class belongs to command or query, donâ€™t write both of these things in a single method Problem with getters: representation exposure in Mutable Objects (sometimes you directly return the reference to this object and now doing modification to the returned object and unintendedly change the original object) 3. Write Specifications: Returns/Creates: postcondition Requires/Checks: precondition Effects/Modifies: side effects Examples: (as needed) Exceptions: - in return clause: when there is a client error (not programmer error) - in checks clause: when precondition violated 12345678910111213141516/** Returns: the puzzle size n*/int size();/** Effects: adds a random tile to the board*/void addRandomTile();/** Effects: adds a random tile to the board Returns: true if there was room*/boolean addRandomTile();/** Effects: adds a random tile to the board Throws: BoardFull if there is no room*/void addRandomTile() throws BoardFull;/** Effects: shifts the tiles in direction d*/void shiftTile(Direction d); 4. Documenting Impls:Audience: maintainers, not clients Goals: keep impl details out of the spec (abstraction barrier) Represents: an abstraction function: concrete fields -&gt; client view 12345/** A rational number */class Rational &#123; int num,dem; //Represents: the rational number num/dem&#125; Class Invariant: Spec for private/protected methods Algorithms Explanations: (If sometimes the spec is not enough to understand the method(specific algorithm), you should write algorithm explanations inside the method(This would be something client doesnâ€™t have to know but maintainers may want to know so you donâ€™t write them in the spec)) Write paragraphs instead of interleave comments 1234/** revtrieves the greatest common demoninator of x and y*/int gcd(x,y)&#123; /**This method uses Euclid&#x27;s to find the ... */&#125;","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"19FA","slug":"19FA","permalink":"https://harmonyano.github.io/tags/19FA/"},{"name":"CS2112","slug":"CS2112","permalink":"https://harmonyano.github.io/tags/CS2112/"}]},{"title":"Value Representation, Hashing, and Generics","slug":"2019-09-30-Value-Representation,-Hashing,-and-Generics","date":"2019-09-30T04:00:00.000Z","updated":"2019-12-25T05:14:40.128Z","comments":true,"path":"2019-09-30-Value-Representation,-Hashing,-and-Generics/","link":"","permalink":"https://harmonyano.github.io/2019-09-30-Value-Representation,-Hashing,-and-Generics/","excerpt":"From Lecture: representing Java values Generics, more lists Hash tables Download my notes in OneNote here","text":"From Lecture: representing Java values Generics, more lists Hash tables Download my notes in OneNote here Subtyping Like other implements declarations, the declaration above that LList&lt;T&gt; implements Collection&lt;T&gt; generates a subtype relationship: in fact, a family of subtype relationships, because the subtype relationship holds regardless of what actual type T is chosen. The compiler therefore understands that the relationship LList&lt;String&gt; &lt;: Collection&lt;String&gt; holds. What about these other possible relationships? LList&lt;String&gt; &lt;: LList&lt;Object&gt; ? LList&lt;String&gt; &lt;: Collection&lt;Object&gt; ? Both of these look reasonable at first glance. But they are actually unsound, leading to possible run-time type errors. The following example shows the problem: 1234LList&lt;String&gt; ls = new LList&lt;String&gt;();LList&lt;Object&gt; lo = ls;lo.add(2112);String s = ls.head(); // extract data from head of list\u0001 The head element of the list, which is assigned to a variable of type String, is actually an Integer! This is erroneous, so the Java compiler will not allow it. A similar situation arises with arrays, although in that case the error is unfortunately only caught at run time. 1234String[] a = new String[1];Object[] b = a;b[0] = 2112;System.out.println(a[0]); The idea that there can be a subtyping relationship between different instantiations of the same generic type is called variance. Variance is tricky to support in a sound way, so Java does not support variance. Other languages such as Scala do have variance. Wildcards To make up for the lack of variance, Java has a feature called wildcards, in which question marks are used as type arguments. The type LList&lt;?&gt; represents an object that is an LList&lt;T&gt; for some type T, though precisely which type T is not known at compile time (or for that matter, even at run time). A value of type LList&lt;T&gt; (for any T) can be used as if it had type LList&lt;?&gt;, so there is a family of subtyping relationships LList&lt;T&gt; &lt;: LList&lt;?&gt;. This means that a method can provide a caller with a list of any type without the client knowing what is really stored in the list; the client can get elements from the list but cannot change the list: 1234567891011121314LList&lt;?&gt; f() &#123; LList&lt;Integer&gt; i = new LList(); i.add(2); i.add(3); i.add(5); return i;&#125;// in caller\u0001LList&lt;?&gt; lst = f();lst.add(7); // illegal: type ? not known\u0001for (Object o : lst) &#123; println(o);&#125; Note that the type of the elements iterated over is not really known either, but at least we know that the type hidden by ? is a subtype of Object. So it is type-safe to declare the variable o as an Object. If we need to know more about the type hidden by the question mark, it is possible to add an extends clause. For example, suppose we have an interface Animal with two implementing classes Elephant and Rhino. Then the type Collection&lt;? extends Animal&gt; is a supertype of both Collection&lt;Elephant&gt; and Collection&lt;Rhino&gt;, and we can iterate over the collection and extract Animals rather than just Objects. 1234Collection&lt;? extends Animal&gt; c = new LList&lt;Rhino&gt;();for (Animal a : c) &#123; // use a as Animal here\u0001&#125; Limitations The way generics are actually implemented in Java is that all actual type parameters are erased at run time. This implementation choice leads to a number of limitations of the generics mechanism in Java when in a generic context where T is a formal parameter: Constructors of T cannot be used; we cannot write new T(). The workaround for this limitation is to have an object with a factory method for creating T objects. Arrays with T as elements cannot be created, either. We cannot write new T[n] , because the type T is not known at run time and so the type T[] cannot be installed into the objectâ€™s header. The workaround for this limitation is to use an array of type Object[] instead: T[] a = (T[]) new Object[n]; This of course creates an array that could in principle be used to store things other than Tâ€™s, but as long as we use that array through the variable a, we wonâ€™t. The compiler gives us an alarming warning when we use this trick because of the unsafe cast, but this programming idiom is fairly safe. Note that if we need to create an array of T in a context where T is known to be a subtype of some type, then the array that should be created is an array of that type, rather than of Object. Similarly, we canâ€™t create an array whose type includes a parameter type: 1HashSet&lt;String&gt;[] sets = new HashSet&lt;String&gt;[n]; // error: generic array creation\u0001 The workaround is to use a wildcard type to create the array, and dynamically cast it to the desired type: 1HashSet&lt;String&gt;[] sets = new HashSet&lt;?&gt;[n]; We canâ€™t use instanceof to find out what type parameters are, because the object does not contain that information. If, for example, we create an LList&lt;String&gt; object, the objectâ€™s header word only records that it is an LList. So an LList&lt;String&gt; object that is statically typed as an Object can be tested to see if it is some kind of LList, but not whether the actual type parameter is String: 12345678910Object co = new LList&lt;String&gt;();if (co instanceof LList&lt;String&gt;) ... // illegal\u0001if (co instanceof LList&lt;?&gt;) ... // legal\u0001if (co instanceof LList) ... // legal but discouraged\u0001LList&lt;String&gt; ls = (LList&lt;String&gt;) co; // legal but only partly checked\u0001LList&lt;?&gt; ls = (LList&lt;?&gt;) co; // legal\u0001LList&lt;String&gt; ls = (LList&lt;?&gt;) co; // illegal\u0001LList&lt;String&gt; ls = (LList)co; // legal but discouraged\u0001 The last four lines above illustrate how downcasts interoperate with generics. Code can cast to a type with an actual type parameter, but the type parameter is not actually checked at run time; Java takes the programmerâ€™s word that the type parameter is correct. We can cast to a wildcard instantiation, but such a cast is not very useful if we need to use the elements at their actual type. Finally, we can cast to the raw type LList; casting to raw types is unsafe. It is essentially the same as casting to LList&lt;?&gt; except that Java allows a raw type to be used as if it were any particular instantiation. Raw types should be avoided when possible. Accessing type operations What if we want to use methods of T in a generic context where T is a formal parameter? There is more than one way to do this, but in Java the most powerful approach is to provide a separate model object that knows how to perform the operations that are needed. For example, suppose we want to compare objects of type T using the compareTo method. We declare a generic interface Comparator&lt;T&gt;: 123456interface Comparator&lt;T&gt; &#123; /** Compares x and y. Return 0 if x and y are equal, a negative number if x &lt; y, * and a positive number if x &gt; y. */ int compareTo(T x, T y);&#125; Now, a generic method for sorting an array takes an extra comparator parameter: 123456789/** Sort the array a in ascending order using cmp to define the ordering on the * elements. */&lt;T&gt; sort(T[] a, Comparator&lt;T&gt; cmp) &#123; ... if (cmp.compareTo(a[i], a[j]) &gt; 0) &#123; ... &#125; ...&#125; A class can then implement the comparator interface and be used to make the right comparator operation available to the generic code. 123456789class SCmp implements Comparator&lt;String&gt; &#123; @Override public int compareTo(String x, String y) &#123; return x.compareTo(y); &#125;&#125;String[] a = &#123;&quot;z&quot;, &quot;Y&quot;, &quot;x&quot;&#125;;sort(a, new SCmp()); Notice that here we are using Stringâ€˜s own compareTo operation as a model for the comparator, but we donâ€™t have to. For example, we could have used the compareToIgnoreCase method to sort strings while ignoring the difference between upper and lower case. It turns out that we can also use Java 8â€™s new lambda expressions to implement the interface even more compactly. Here is how we would sort the array using a lambda expression while also ignoring case: 1sort(a, (x,y) -&gt; x.compareToIgnoreCase(y)); The lambda expression (x,y) -&gt; x.compareToIgnoreCase(y) is actually just a very convenient syntactic sugar for declaring a class like the one above and instantiating it with new. Generic classes may need to access parameter type operations too. The typical approach is to accept the model object in constructors, then to store it in an instance variable for later use by other methods: 12345678910111213141516class SortedList&lt;T&gt; implements Collection&lt;T&gt; &#123; Comparator&lt;T&gt; comparator; SortedList(Comparator&lt;T&gt; cmp) &#123; comparator = cmp; // save model object\u0001 ... &#125; boolean add(T x) &#123; ... if (comparator.compareTo(x, y)) &#123; // use model object\u0001 ... &#125; ... &#125;&#125;","categories":[],"tags":[{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"19FA","slug":"19FA","permalink":"https://harmonyano.github.io/tags/19FA/"},{"name":"CS2112","slug":"CS2112","permalink":"https://harmonyano.github.io/tags/CS2112/"}]},{"title":"P1162 å¡«æ¶‚é¢œè‰²","slug":"2019-07-07-P1162-å¡«æ¶‚é¢œè‰²","date":"2019-07-07T04:00:00.000Z","updated":"2019-10-06T21:02:29.816Z","comments":true,"path":"2019-07-07-P1162-å¡«æ¶‚é¢œè‰²/","link":"","permalink":"https://harmonyano.github.io/2019-07-07-P1162-%E5%A1%AB%E6%B6%82%E9%A2%9C%E8%89%B2/","excerpt":"é¢˜ç›®æ¥æºï¼šæ´›è°·P1162 å¡«æ¶‚é¢œè‰² å¦‚æœè¢«åŒ…å›´çš„éƒ¨åˆ†æ²¡ä»€ä¹ˆç‰¹ç‚¹ï¼Œé‚£ä¹ˆå°±å¯ä»¥çœ‹çœ‹å…¶ä»–éƒ¨åˆ†æœ‰æ²¡æœ‰ä»€ä¹ˆç‰¹ç‚¹ï¼Œæœ¬é¢˜ä¸­å°±æ˜¯å¯ä»¥ä»å¤–å›´å¼€å§‹æœç´¢ï¼Œæœåˆ°å¢™å°±åœä¸‹ï¼Œæœ€åæ²¡è¢«æœåˆ°çš„éƒ¨åˆ†å°±æ˜¯è¢«å¢™åŒ…å›´çš„éƒ¨åˆ† ä¸ºäº†é˜²æ­¢å¤–å›´èµ·ç‚¹å°±æ˜¯å¢™ï¼Œæˆ–è€…æ˜¯å¤–å›´çš„0è¢«å¢™åˆ†ä¸ºå¥½å‡ éƒ¨åˆ†å¯¼è‡´æˆ‘ä»¬æ— æ³•æœç´¢åˆ°è¢«åˆ†å‰²çš„éƒ¨åˆ†ï¼Œå¯ä»¥å¤šå¼€ä¸€åœˆæ•°ç»„ï¼Œä½¿å¾—å¤–å›´ç›¸äº’è¿æ¥èµ·æ¥ï¼Œç¡®ä¿ä¸è¢«åŒ…å›´çš„0ä¸€å®šå¯ä»¥è¢«æœåˆ°","text":"é¢˜ç›®æ¥æºï¼šæ´›è°·P1162 å¡«æ¶‚é¢œè‰² å¦‚æœè¢«åŒ…å›´çš„éƒ¨åˆ†æ²¡ä»€ä¹ˆç‰¹ç‚¹ï¼Œé‚£ä¹ˆå°±å¯ä»¥çœ‹çœ‹å…¶ä»–éƒ¨åˆ†æœ‰æ²¡æœ‰ä»€ä¹ˆç‰¹ç‚¹ï¼Œæœ¬é¢˜ä¸­å°±æ˜¯å¯ä»¥ä»å¤–å›´å¼€å§‹æœç´¢ï¼Œæœåˆ°å¢™å°±åœä¸‹ï¼Œæœ€åæ²¡è¢«æœåˆ°çš„éƒ¨åˆ†å°±æ˜¯è¢«å¢™åŒ…å›´çš„éƒ¨åˆ† ä¸ºäº†é˜²æ­¢å¤–å›´èµ·ç‚¹å°±æ˜¯å¢™ï¼Œæˆ–è€…æ˜¯å¤–å›´çš„0è¢«å¢™åˆ†ä¸ºå¥½å‡ éƒ¨åˆ†å¯¼è‡´æˆ‘ä»¬æ— æ³•æœç´¢åˆ°è¢«åˆ†å‰²çš„éƒ¨åˆ†ï¼Œå¯ä»¥å¤šå¼€ä¸€åœˆæ•°ç»„ï¼Œä½¿å¾—å¤–å›´ç›¸äº’è¿æ¥èµ·æ¥ï¼Œç¡®ä¿ä¸è¢«åŒ…å›´çš„0ä¸€å®šå¯ä»¥è¢«æœåˆ° 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,dir[4][2]=&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;bool graph[32][32],vis[32][32];///graph è®°å½•è¿™ä¸ªå›¾åŸæ¥æ˜¯0è¿˜æ˜¯1ï¼ˆç©ºè¿˜æ˜¯å¢™ï¼‰ï¼Œvisè®°å½•è¢«æ²¡è¢«è®¿é—®è¿‡///æ³¨æ„è¿™ä¸¤ä¸ªæ•°ç»„éƒ½æ˜¯å¼€çš„32ï¼ˆæ•°æ®æ˜¯1~30ï¼Œæœ¬æ¥å¼€31å°±å¤Ÿäº†ï¼‰ä¿è¯äº†å¤–é¢åˆä¸€åœˆ0ï¼Œä¹Ÿå°±æ˜¯æœ€å¤–é¢çš„ä¸€åœˆéƒ½æ˜¯è”é€šçš„ï¼Œé¿å…äº†ç¬¬ä¸€ä¸ªç‚¹1,1å°±æ˜¯å¢™å¯¼è‡´å¾ªç¯å¾ªç¯ä¸ä¸‹å»çš„æƒ…å†µï¼Œä¹Ÿé¿å…äº†ä¸€å µå¢™æŠŠä¸­é—´å…¨éƒ¨å µæ­»ï¼Œåªæ‰«äº†å¢™å·¦è¾¹çš„0ï¼Œæ²¡æ‰«åŒåœ¨å¢™å¤–ä½†åœ¨å¢™å³è¾¹çš„0çš„æƒ…å†µvoid dfs(int, int);int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) cin&gt;&gt;graph[i][j]; dfs(0,0); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(vis[i][j]) cout&lt;&lt;&quot;0 &quot;;///å¦‚æœè®¿é—®è¿‡ï¼Œé‚£ä¹ˆä¸€å®šæ˜¯å¢™å¤–çš„0 else if(graph[i][j]) cout&lt;&lt;&quot;1 &quot;;///è¾“å…¥æ—¶åŸæœ¬æ˜¯å¢™ï¼Œé‚£ä¹ˆå®ƒè¿˜æ˜¯å¢™ï¼ˆè¿™ä¸€å¥å¯ä»¥å’Œä¸Šé¢é‚£ä¸€å¥äº’æ¢ä½ç½®ï¼‰ else cout&lt;&lt;&quot;2 &quot;;///åŠæ²¡è¢«è®¿é—®è¿‡ï¼Œè¾“å…¥æ—¶ä¹Ÿä¸æ˜¯å¢™ï¼Œé‚£ä¹ˆè‚¯å®šæ˜¯è¢«åŒ…å›´åœ¨é‡Œé¢çš„0 &#125; cout&lt;&lt;endl; &#125; return 0;&#125;void dfs(int x, int y)&#123; if( x&lt;0 | x&gt;n+1 | y&lt;0 | y&gt;n+1 | graph[x][y] | vis[x][y] ) ///å¦‚æœ1.è¶Šç•Œï¼ˆæ³¨æ„æ˜¯ &lt;0|&gt;n+1 è¿™é‡Œå¯ä»¥çœ‹å‡ºæ¥æˆ‘ä»¬å¤šå¼€äº†ä¸€åœˆ0åœ¨åŸè¾“å…¥å¤–é¢ï¼‰ ///2.æ˜¯å¢™|è¢«è®¿é—®è¿‡ é‚£ä¹ˆä¸åšæ“ä½œ return; vis[x][y]=true; for(int i=0;i&lt;4;i++) dfs(x+dir[i][0],y+dir[i][1]);&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"https://harmonyano.github.io/tags/NOI/"}]},{"title":"P1141 01è¿·å®«","slug":"2019-07-04-P1141-01è¿·å®«","date":"2019-07-04T04:00:00.000Z","updated":"2019-10-06T21:02:20.863Z","comments":true,"path":"2019-07-04-P1141-01è¿·å®«/","link":"","permalink":"https://harmonyano.github.io/2019-07-04-P1141-01%E8%BF%B7%E5%AE%AB/","excerpt":"é¢˜ç›®æ¥æºï¼šæ´›è°·P1141 01è¿·å®« BFSæ‰¾è¿é€šå— è¿é€šå—è‚¯å®šè¿˜æ˜¯DFSæ‰¾å¾—å¿«ï¼Œå› ä¸ºä¸€å¼€å§‹ä¸çŸ¥é“ä»€ä¹ˆæ˜¯è¿é€šå—æ‰€ä»¥å†™äº†ä¸ªBFS æœç´¢è¿é€šå—ä¸éœ€è¦è®°å½•ä»æŸä¸€ä¸ªç‚¹å‡ºå‘æœ€è¿œèƒ½åˆ°è¾¾å“ªä¸ªç‚¹ï¼ˆBFSæœç´¢æœ€çŸ­è·ç¦»ï¼‰ï¼Œåªéœ€è¦è®°å½•ä»æŸä¸€ä¸ªç‚¹å‡ºå‘ä¸€å…±ç»è¿‡äº†å¤šå°‘ä¸ªç¬¦åˆæ¡ä»¶çš„ç‚¹å°±è¡Œäº†ï¼ˆBFSæœç´¢è¿é€šå—ï¼‰ï¼Œå› ä¸ºå¦‚æœAå’ŒBè”é€šï¼ŒBå’ŒCè”é€šï¼Œé‚£ä¹ˆAå’ŒCå¿…ç„¶è”é€šï¼Œæ‰€ä»¥ä¸€æ¬¡æœç´¢èƒ½è¾¾åˆ°çš„æ‰€æœ‰ç‚¹å¿…å®šåœ¨åŒä¸€ä¸ªè¿é€šå—å†…","text":"é¢˜ç›®æ¥æºï¼šæ´›è°·P1141 01è¿·å®« BFSæ‰¾è¿é€šå— è¿é€šå—è‚¯å®šè¿˜æ˜¯DFSæ‰¾å¾—å¿«ï¼Œå› ä¸ºä¸€å¼€å§‹ä¸çŸ¥é“ä»€ä¹ˆæ˜¯è¿é€šå—æ‰€ä»¥å†™äº†ä¸ªBFS æœç´¢è¿é€šå—ä¸éœ€è¦è®°å½•ä»æŸä¸€ä¸ªç‚¹å‡ºå‘æœ€è¿œèƒ½åˆ°è¾¾å“ªä¸ªç‚¹ï¼ˆBFSæœç´¢æœ€çŸ­è·ç¦»ï¼‰ï¼Œåªéœ€è¦è®°å½•ä»æŸä¸€ä¸ªç‚¹å‡ºå‘ä¸€å…±ç»è¿‡äº†å¤šå°‘ä¸ªç¬¦åˆæ¡ä»¶çš„ç‚¹å°±è¡Œäº†ï¼ˆBFSæœç´¢è¿é€šå—ï¼‰ï¼Œå› ä¸ºå¦‚æœAå’ŒBè”é€šï¼ŒBå’ŒCè”é€šï¼Œé‚£ä¹ˆAå’ŒCå¿…ç„¶è”é€šï¼Œæ‰€ä»¥ä¸€æ¬¡æœç´¢èƒ½è¾¾åˆ°çš„æ‰€æœ‰ç‚¹å¿…å®šåœ¨åŒä¸€ä¸ªè¿é€šå—å†… å¦‚æœå¯¹äºæ¯ä¸ªæŸ¥è¯¢æˆ‘ä»¬éƒ½æœç´¢ä¸€éçš„è¯è‚¯å®šä¼šè¶…æ—¶ï¼Œæ‰€ä»¥æˆ‘ä»¬ç”¨visæ•°ç»„è®°å½•ä¸‹æ¥ä¸€æ¬¡æœç´¢ä¸­æ‰€æœ‰ç»è¿‡çš„ç‚¹æ‰€åœ¨çš„ï¼ˆå¿…å®šæ˜¯åŒä¸€ä¸ªï¼‰è¿é€šå—çš„åºå·ï¼Œansæ•°ç»„è®°å½•ç›¸åº”åºå·çš„è¿é€šå—ä¸­å…±æœ‰å‡ ä¸ªç‚¹ï¼Œä¸‹æ¬¡å¦‚æœè¯¢é—®çš„ç‚¹å·²ç»è¢«æœç´¢è¿‡å°±å¯ä»¥å…å»æœç´¢ç›´æ¥è¾“å‡ºç­”æ¡ˆäº†ã€‚ ç¨‹åºå‘æœ¬æ¥è¢«å°æ­»çš„åœ°æ–¹èµ°äº†ä¸€æ­¥ï¼Œå¯èƒ½æ˜¯åˆå§‹åŒ–çš„é—®é¢˜ã€‚åˆå§‹åŒ–å°±åˆ«ç”¨é‚£äº›èŠ±é‡Œèƒ¡å“¨çš„å¥å­äº†ï¼Œè¿˜æ˜¯è€è€å®å®å†™forå¾ªç¯å§ï¼Œåæ­£æ—¶é—´ç©ºé—´å¤Ÿç”¨ï¼Œåˆ«çš„å¥å­å¤ªå®¹æ˜“å‡ºé”™ è«åå…¶å¦™è¾“å‡ºæ¥å‡ åä¸‡çš„æ•°æ®ï¼Œä¼°è®¡æ˜¯çˆ†å†…å­˜äº†ï¼Œæ•°ç»„ä¸€å®šè¦æ ¹æ®é¢˜ç›®è¦æ±‚å¼€å¾—è¶³å¤Ÿå¤§ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;struct node&#123; int x,y;&#125;;int m,n,question[100005][2],dir[4][2]=&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;,vis[1003][1003],ans[100005],connect=1; bool maze[1003][1003];///question å­˜å‚¨äº†æ¯ç»„è¯¢é—®çš„èµ·ç‚¹åæ ‡///vis = 0 ä»£è¡¨è¿™ä¸ªç‚¹æ²¡èµ°è¿‡ï¼Œç°åœ¨ä¸åœ¨ä»»ä½•ä¸€ä¸ªè¿é€šå—é‡Œé¢ï¼›vis = x (x&gt;0) ä»£è¡¨è¿™ä¸ªç‚¹èµ°è¿‡äº†ï¼Œå¹¶ä¸”åœ¨xå·è¿é€šå—é‡Œé¢ï¼›è¿™ä¸ªæ•°ç»„ä¸€å®šè¦å¼€å¤§ï¼Œåªå¼€åˆ°1003æ˜¯ä¸è¡Œçš„ï¼Œå¿…é¡»è¦å¼€åˆ°å’Œquestionä¸€ä¸ªæ•°é‡çº§///ans å­˜å‚¨æ¯ä¸ªè¿é€šå—é‡Œé¢å…±æœ‰å‡ ä¸ªç‚¹///maze å­˜å‚¨è¿™ä¸ªè¿·å®«///connect ä»£è¡¨å„ä¸ªè¿é€šå—çš„åºå·int bfs(int, int); bool legal(node, node);int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)&#123; char a; cin&gt;&gt;a; if(a==&#x27;0&#x27;) maze[i][j]=0; else if(a==&#x27;1&#x27;) maze[i][j]=1; &#125;///å› ä¸ºæ¯ä¸ªè¾“å…¥ä¹‹é—´æ˜¯ä¸ç©ºæ ¼çš„ï¼Œæ‰€ä»¥ç”¨charæ¥è¾“å…¥åšä¸€ä¸ªå·§å¦™çš„å¤„ç† for(int i=1;i&lt;=m;i++) cin&gt;&gt;question[i][0]&gt;&gt;question[i][1]; ///åˆå§‹åŒ–æœ€åå‡ºäº†å¾ˆå¤§é—®é¢˜ï¼Œè¿˜æ˜¯ç”¨æœ€ä¿é™©çš„forå¾ªç¯ for(int i=0;i&lt;100005;i++) ans[i]=1; for(int i=0;i&lt;1003;i++) for(int j=0;j&lt;1003;j++) vis[i][j]=0; for(int i=1;i&lt;=m;i++) cout&lt;&lt;bfs(question[i][0],question[i][1])&lt;&lt;endl; return 0;&#125;bool legal(node now, node next)&#123; ///è¿™é‡Œä¸éœ€è¦åˆ†æƒ…å†µè®¨è®ºâ€œå¦‚æœ now==0 åˆ™å¿…é¡» next==1â€ æˆ–ç›¸åï¼Œåªéœ€è¦ç¡®ä¿nowå’Œnextçš„å€¼ä¸åŒå°±è¡Œäº† return maze[now.x][now.y]!=maze[next.x][next.y] &amp;&amp; next.x&gt;=1 &amp;&amp; next.x&lt;=n &amp;&amp; next.y&gt;=1 &amp;&amp; next.y&lt;=n &amp;&amp; vis[next.x][next.y]==0;&#125;int bfs(int x, int y)&#123; queue &lt;node&gt; q; node start; start.x = x; start.y = y; if(vis[start.x][start.y]==0)&#123;///å¦‚æœè¿™ä¸ªç‚¹ä¸åœ¨ç°æœ‰çš„ä»»ä½•ä¸€ä¸ªè¿é€šå—å†…ï¼Œåˆ™è¿›å…¥é˜Ÿåˆ—ï¼Œå¼€å§‹bfs vis[start.x][start.y] = connect; q.push(start); &#125; else return ans[vis[start.x][start.y]];///å¦‚æœè¿™ä¸ªç‚¹åœ¨æŸä¸ªè¿é€šå—å†…ï¼Œåˆ™ç›´æ¥è¾“å‡ºæ­¤è¿é€šå—å¯¹åº”çš„ç»“æœ while(!q.empty())&#123; node now = q.front(); q.pop(); for(int i=0;i&lt;4;i++)&#123; node next; next.x = now.x + dir[i][0]; next.y = now.y + dir[i][1]; if(legal(now,next))&#123; vis[next.x][next.y] = connect;///è®°å½•ä¸‹æ¥ç‚¹nextå±äºè¿é€šå—connect ans[connect]++;///è¿é€šå—connectä¸­æ€»ç‚¹æ•°+1 q.push(next); &#125; &#125; &#125; return ans[connect++];///æ‰€æœ‰å±äºconnectçš„ç‚¹éƒ½æœå®Œäº†ï¼Œè¿”å›ç­”æ¡ˆï¼Œå¹¶ä½¿connect++ï¼Œè¡¨ç¤ºæ¥ä¸‹æ¥è¦æ‰«çš„æ˜¯æ–°çš„è¿é€šå—&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"https://harmonyano.github.io/tags/NOI/"}]},{"title":"P1118 Backward Digital Sums","slug":"2019-07-02-P1118-Backward-Digital-Sums","date":"2019-07-02T04:00:00.000Z","updated":"2019-10-06T21:02:06.301Z","comments":true,"path":"2019-07-02-P1118-Backward-Digital-Sums/","link":"","permalink":"https://harmonyano.github.io/2019-07-02-P1118-Backward-Digital-Sums/","excerpt":"é¢˜ç›®æ¥æºï¼šæ´›è°·P1118 æ•°å­—ä¸‰è§’å½¢ æš´åŠ›æœç´¢çœ‹åˆ°é¢˜ç›®çš„ç¬¬ä¸€çœ¼æƒ³çš„å°±æ˜¯ç›´æ¥æœï¼Œå‘ç°ä¸å°‘TLEï¼Œæˆ‘è¿˜å‡äº†ä¸å°‘æâ€¦ è¶…æ—¶ï¼Œåªæœ‰20åˆ†ï¼Œé€šè¿‡å‡ ä¸ªè¿è¡Œç»“æœæ¥çœ‹ï¼Œå†™æ³•åº”è¯¥å¯¹äº†ï¼Œåªæ˜¯å…¨éƒ½TLEè€Œå·²","text":"é¢˜ç›®æ¥æºï¼šæ´›è°·P1118 æ•°å­—ä¸‰è§’å½¢ æš´åŠ›æœç´¢çœ‹åˆ°é¢˜ç›®çš„ç¬¬ä¸€çœ¼æƒ³çš„å°±æ˜¯ç›´æ¥æœï¼Œå‘ç°ä¸å°‘TLEï¼Œæˆ‘è¿˜å‡äº†ä¸å°‘æâ€¦ è¶…æ—¶ï¼Œåªæœ‰20åˆ†ï¼Œé€šè¿‡å‡ ä¸ªè¿è¡Œç»“æœæ¥çœ‹ï¼Œå†™æ³•åº”è¯¥å¯¹äº†ï¼Œåªæ˜¯å…¨éƒ½TLEè€Œå·² ^åœ¨c++ä¸­ä¸æ˜¯å¹‚è¿ç®—ï¼Œæ˜¯å¼‚æˆ–ï¼ˆå¦‚æœä¸¤ä¸ªç›¸åº”ä½ä¸ºâ€œå¼‚â€ï¼ˆå€¼ä¸åŒï¼‰ï¼Œåˆ™è¯¥ä½ç»“æœä¸º1ï¼Œå¦åˆ™ä¸º0ã€‚0^0=0; 0^1=1; 1^0=1; 1^1=0ï¼‰ã€‚å¹‚è¿ç®—ç”¨pow(base,power) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;int n,tri[13][13],ans[13]; bool flag=true;void dfs(int);int main()&#123; int start; cin&gt;&gt;n&gt;&gt;start; tri[n][1]=start; dfs(n-1); if(!flag) for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;; return 0;&#125;void dfs(int level)&#123; if(flag)&#123; int lbound=pow(2,level-1),ubound=tri[level+1][1]-lbound;///lbound(lower_bound)æ˜¯å‡è®¾ç¬¬ä¸€è¡Œå…¨æ˜¯1ï¼Œå¾—å‡ºçš„åç»­å‡ è¡Œçš„æœ€å°å€¼ for(int i=lbound;i&lt;=ubound;i++)&#123; if(!flag) continue; tri[level][1]=i; bool jump=false; for(int j=1;j&lt;=n-level;j++)&#123; tri[level][j+1]=tri[level+1][j]-tri[level][j]; ///å¯ä»¥åŠ ä¸€ä¸ªåˆ¤å®šæ¡ä»¶ï¼Œå¦‚æœå°äºXXXï¼Œå°±åœæ­¢æœ¬æ¬¡æœç´¢ if(tri[level][j+1]&lt;lbound) &#123;jump=true; break;&#125;///ä¸å‰é¢çš„lboundå®šä¹‰ä¸€æ ·ï¼Œå¦‚æœä¸€ä¸ä¸‹å¿ƒæœå‡ºæ¥0æˆ–è€…-1é‚£ä¹ˆè‚¯å®šä¸å¯¹ if(tri[level][j+1]==tri[level][j]) &#123;jump=true; break;&#125;///è‡ªå·±å‘ç°çš„è§„å¾‹ï¼Œç›¸é‚»ä¸¤é¡¹ä¸å¯èƒ½ç›¸ç­‰ï¼Œå› ä¸ºç›¸é‚»çš„ä¸¤é¡¹ç›¸ç­‰ä¼šå¯¼è‡´å†ä¸Šé¢ä¸€å±‚ä¹Ÿæœ‰ä¸¤é¡¹ç›¸ç­‰ï¼Œç›´åˆ°ç¬¬ä¸€å±‚æœ‰ä¸¤é¡¹ç›¸ç­‰ï¼Œæ„å‘³ç€ç­”æ¡ˆä¸ç¬¦åˆæ¡ä»¶ &#125; if(jump) continue; for(int j=1;j&lt;=n-level+1;j++)&#123; cout&lt;&lt;tri[level][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; if(level==1)&#123; int sum=0; for(int i=1;i&lt;=n;i++)&#123; sum+=pow(2,tri[1][i]); sum-=pow(2,i); &#125;///è¿™ä¸ªåœ°æ–¹ç”¨äº†ä¸€ä¸ªäºŒè¿›åˆ¶çš„æ€§è´¨ç®—æˆ‘ä»¬çš„ç­”æ¡ˆç¬¬ä¸€è¡Œæ˜¯å¦æ˜¯1~Nçš„æ•°å­—ä¸”äº’ä¸ç›¸åŒ(æ¯ä¸ª1~Nçš„æ•°éƒ½æœ‰ä¸¤ç§çŠ¶æ€ï¼Œåœ¨ç­”æ¡ˆé‡Œæœ‰æˆ–è€…æ²¡æœ‰) if(sum==0)&#123;///sum==0 ä»£è¡¨sum(pow(2,tri[1][i]))==sum(pow(2,i)) for(int i=1;i&lt;=n;i++) ans[i]=tri[1][i]; flag=false; &#125; /// åœæ­¢æ‰€æœ‰æœç´¢ï¼Œå·²æ‰¾åˆ°ç­”æ¡ˆ &#125; if(level&gt;1&amp;&amp;flag==true) dfs(level-1); &#125; &#125;&#125; æ¨è¾‰ä¸‰è§’ä»¥ä¸‹ä¸ºæ¨è¾‰ä¸‰è§’ä¸€ç»´dfsï¼Œåªæœ‰70åˆ†ï¼Œè¿˜æ˜¯éœ€è¦å‰ªæ é¦–å…ˆè¦ææ¸…æ¥šè¿™ä¸ªæ•°å­—ä¸‰è§’å½¢ç©¶ç«Ÿæ˜¯ä»€ä¹ˆå§ã€‚å¤§å®¶å¯ä»¥è‡ªå·±åœ¨è‰ç¨¿çº¸ä¸Šå†™ä¸€ä¸‹ï¼Œå‡è®¾nä¸ºä¸€ä¸ªæ¯”è¾ƒå°çš„æ•°(æ¯”å¦‚ï¼ŒæŒ‰æ ·ä¾‹ï¼Œ4)ï¼Œè®¾ç¬¬ä¸€è¡Œçš„nä¸ªæ•°åˆ†åˆ«ä¸ºa,b,c,â€¦(æˆ‘è¿™é‡Œæ˜¯a,b,c,d)ï¼Œç„¶åæ¨¡æ‹ŸåŠ ä¸€ä¸‹ï¼Œå°±ä¼šå‘ç°sumæ˜¯â€¦â€¦ å¦‚æœnä¸º4ï¼Œé‚£ä¹ˆsumæ˜¯a+3b+3c+dã€‚ å¦‚æœnä¸º5ï¼Œé‚£ä¹ˆsumæ˜¯a+4b+6c+4d+eã€‚ å¦‚æœnä¸º6ï¼Œé‚£ä¹ˆsumæ˜¯a+5b+10c+10d+5e+fã€‚ è§‚å¯Ÿå„é¡¹çš„ç³»æ•°ï¼Œä½ å‘ç°äº†ä»€ä¹ˆï¼Ÿ å¦‚æœä½ æœ‰æ•é”çš„æ•°å­¦çœ¼å…‰ï¼Œä½ ä¼šå‘ç°ï¼Œå„é¡¹ç³»æ•°æ°ä¸æ¨è¾‰ä¸‰è§’æœ‰å…³ï¼ é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥æšä¸¾æ¯ä¸ªa,b,c,â€¦ï¼Œé€ä¸€ä¸sumæ¯”è¾ƒï¼Œå°±å¯ä»¥å¾—å‡ºç­”æ¡ˆäº†ã€‚~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int yanghui[13][13],ans[13],n,sum; bool vis[13];int compute();void dfs(int);int main()&#123; cin&gt;&gt;n&gt;&gt;sum; memset(vis,true,sizeof(vis)); ///åˆå§‹åŒ–æ¨è¾‰ä¸‰è§’ yanghui[1][1]=1;yanghui[2][1]=1;yanghui[2][2]=1; for(int i=3;i&lt;=n;i++)&#123; yanghui[i][1]=1; for(int j=2;j&lt;=i;j++) yanghui[i][j]=yanghui[i-1][j-1]+yanghui[i-1][j]; &#125; dfs(1);///ä»ç¬¬ä¸€ä¸ªä½ç½®å¼€å§‹æœç´¢ return 0;&#125;int compute()///å½“å·²ç»æšä¸¾åˆ°äº†æœ€åä¸€ä½æ—¶ï¼Œå¯ä»¥è®¡ç®—ç°åœ¨ç­”æ¡ˆçš„å€¼æ˜¯å¦çœŸçš„ç­‰äºæˆ‘ä»¬è¾“å…¥çš„sum&#123; int temp=0; for(int i=1;i&lt;=n;i++) temp+=ans[i]*yanghui[n][i]; return temp;&#125;void dfs(int pointer)&#123; for(int i=1;i&lt;=n;i++)&#123; if(vis[i])&#123; ans[pointer]=i; vis[i]=false; if(pointer==n&amp;&amp;compute()==sum) &#123; for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;; break; &#125; if(pointer&lt;n) dfs(pointer+1); ans[pointer]=0; vis[i]=true; &#125; &#125;&#125; äºŒç»´DFSä¸Šé¢æ–¹æ³•çš„é—®é¢˜åœ¨äºï¼šåªåœ¨æ‰€æœ‰ä½ç½®éƒ½é€‰å®Œçš„æ—¶å€™æ‰åˆ¤å®šæ˜¯å¦ç¬¦åˆæ¡ä»¶(sum=sum_to_find|(åœ¨è¿™ä¸ªç¨‹åºä¸­)sum=compute())ï¼Œä½†æ˜¯æœ‰å¾ˆå¤šæƒ…å†µä¸‹åœ¨æˆ‘ä»¬æ²¡é€‰å®Œçš„æ—¶å€™å°±å·²ç»ä¸ç¬¦åˆæ¡ä»¶äº†(sum&gt;sum_to_find)ã€‚æˆ‘ä»¬å¿…é¡»è¦æ’é™¤è¿™ç§æƒ…å†µï¼Œè¿™æ ·çš„è¯å°±å¿…é¡»åœ¨æœç´¢çš„åŒæ—¶è®°å½•ç°åœ¨çŠ¶æ€ä¸‹åˆ(sum)çš„å¤§å°ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±éœ€è¦å†™ä¸€ä¸ªäºŒç»´çš„dfs ~~å®åœ¨å¤ªè ¢äº†ï¼ŒæŠŠæ‰€æœ‰è¦åˆ¤å®šçš„åœ°æ–¹éƒ½åŠ ä¸Š&amp;flagè¿è¡Œæ—¶é—´ç›´æ¥ä»1500msæåˆ°äº†101ms ~~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int yanghui[13][13],ans[13],n,sum_to_find; bool vis[13],flag=true;int compute();void dfs(int,int);int main()&#123; cin&gt;&gt;n&gt;&gt;sum_to_find; memset(vis,true,sizeof(vis)); ///åˆå§‹åŒ–æ¨è¾‰ä¸‰è§’ yanghui[1][1]=1;yanghui[2][1]=1;yanghui[2][2]=1; for(int i=3;i&lt;=n;i++)&#123; yanghui[i][1]=1; for(int j=2;j&lt;=i;j++) yanghui[i][j]=yanghui[i-1][j-1]+yanghui[i-1][j]; &#125; dfs(1,0); return 0;&#125;void dfs(int pointer,int sum)&#123; if(flag)&#123;///è¿™ä¸ªåœ°æ–¹ä»£ç è¿™ä¹ˆä¸‘æ˜¯å› ä¸ºæˆ‘æŠŠæ‰€æœ‰è¦åˆ¤å®šçš„åœ°æ–¹éƒ½åŠ ä¸Š&amp;flagï¼Œä¸ç„¶TLE for(int i=1;i&lt;=n;i++)&#123; if(vis[i]&amp;&amp;flag)&#123; ans[pointer]=i; vis[i]=false; sum+=ans[pointer]*yanghui[n][pointer]; if(pointer==n&amp;&amp;sum==sum_to_find&amp;&amp;flag) &#123; for(int i=1;i&lt;=n;i++) &#123;cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;; flag=false;&#125; break; &#125; if(pointer&lt;n&amp;&amp;sum&lt;sum_to_find&amp;&amp;flag) dfs(pointer+1,sum); sum-=ans[pointer]*yanghui[n][pointer]; ans[pointer]=0;///è¿™ä¸¤å¥çš„é¡ºåºå¯ä¸èƒ½ææ··äº†ï¼Œè¦å…ˆè¿˜åŸsumå€¼ï¼Œå†è¿˜åŸanså€¼ï¼Œå› ä¸ºsumå€¼å’Œanså€¼æœ‰å…³ vis[i]=true; &#125; &#125;&#125;&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"https://harmonyano.github.io/tags/NOI/"}]},{"title":"P1019 å•è¯æ¥é¾™","slug":"P1019 å•è¯æ¥é¾™","date":"2019-06-26T04:00:00.000Z","updated":"2019-06-27T12:39:41.866Z","comments":true,"path":"P1019 å•è¯æ¥é¾™/","link":"","permalink":"https://harmonyano.github.io/P1019%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/","excerpt":"é¢˜ç›®æ¥æºï¼šæ´›è°·P1019 å•è¯æ¥é¾™ è°ƒäº†å¥½å‡ å¤©ï¼Œæœ€åè¯·æ•™äº†é†‰ç¥(@magolor)ï¼Œååˆ†é’Ÿç»™æˆ‘è°ƒå¥½äº†â€¦ è¿™ä¸ªç¨‹åºä¸€ä¸ªé—®é¢˜å°±æ˜¯å¾ªç¯æ ¹æœ¬å°±ä¸ä¼šå§dictå…¨å¾ªç¯ä¸€éï¼Œé‚£å¯èƒ½å°±æ˜¯åˆå§‹åŒ–å‡ºäº†é—®é¢˜ï¼š m=pointer çš„ä½ç½®ï¼Œå½“æ—¶è®°å¾—åº”è¯¥å†™ä¸€ä¸ªå‰¯æœ¬ m ä»£æ›¿ pointer è¢«æ”¹å˜ï¼Œä½†æ˜¯å†™ç€å†™ç€å¿˜äº† m å…·ä½“åº”è¯¥åœ¨å“ªè¢«åˆå§‹åŒ–äº†ï¼Œé—®é¢˜å°±å‡ºç°åœ¨è¿™ å›æº¯çš„çŠ¶æ€ï¼šä¸€å®šè¦æ˜ç¡®å›æº¯åº”å½“å›æº¯åˆ°å…·ä½“é‚£ä¸ªçŠ¶æ€ï¼Œæ˜¯ans_tempå·²ç»è¢«æ”¹å˜çš„çŠ¶æ€å—ï¼Ÿè¿˜æ˜¯æœªæ”¹å˜çš„çŠ¶æ€ï¼Ÿæœ¬é¢˜ä¸­æ˜¯ans_tempæœªæ”¹å˜çš„çŠ¶æ€","text":"é¢˜ç›®æ¥æºï¼šæ´›è°·P1019 å•è¯æ¥é¾™ è°ƒäº†å¥½å‡ å¤©ï¼Œæœ€åè¯·æ•™äº†é†‰ç¥(@magolor)ï¼Œååˆ†é’Ÿç»™æˆ‘è°ƒå¥½äº†â€¦ è¿™ä¸ªç¨‹åºä¸€ä¸ªé—®é¢˜å°±æ˜¯å¾ªç¯æ ¹æœ¬å°±ä¸ä¼šå§dictå…¨å¾ªç¯ä¸€éï¼Œé‚£å¯èƒ½å°±æ˜¯åˆå§‹åŒ–å‡ºäº†é—®é¢˜ï¼š m=pointer çš„ä½ç½®ï¼Œå½“æ—¶è®°å¾—åº”è¯¥å†™ä¸€ä¸ªå‰¯æœ¬ m ä»£æ›¿ pointer è¢«æ”¹å˜ï¼Œä½†æ˜¯å†™ç€å†™ç€å¿˜äº† m å…·ä½“åº”è¯¥åœ¨å“ªè¢«åˆå§‹åŒ–äº†ï¼Œé—®é¢˜å°±å‡ºç°åœ¨è¿™ å›æº¯çš„çŠ¶æ€ï¼šä¸€å®šè¦æ˜ç¡®å›æº¯åº”å½“å›æº¯åˆ°å…·ä½“é‚£ä¸ªçŠ¶æ€ï¼Œæ˜¯ans_tempå·²ç»è¢«æ”¹å˜çš„çŠ¶æ€å—ï¼Ÿè¿˜æ˜¯æœªæ”¹å˜çš„çŠ¶æ€ï¼Ÿæœ¬é¢˜ä¸­æ˜¯ans_tempæœªæ”¹å˜çš„çŠ¶æ€ æˆ‘çš„è§£ä¸æ ‡è§£ è·Ÿæˆ‘çš„åšæ³•ä¸€æ ·ï¼ŒåŒºåˆ«åªæ˜¯æ ‡è§£ç”¨forå¾ªç¯æšä¸¾jè€Œä¸æ˜¯è·Ÿæˆ‘ä¸€æ ·ç”¨ç›´æ¥ç”¨dfså‡½æ•° ä¸‹é¢æ˜¯æˆ‘çš„ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;char dict[21][30],ans[500]; int n,vis[21],ans_max=0,ans_temp=0;void dfs(int,int);int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;dict[i]; for(int i=1;i&lt;=n;i++) vis[i]=2; cin&gt;&gt;dict[0][0];///å¼€å¤´çš„å­—æ¯ dfs(0,0); cout&lt;&lt;ans_max; return 0;&#125;void dfs(int word,int pointer)&#123; if(pointer&lt;strlen(dict[word]))&#123; ans_temp++; int ans_mark=ans_temp; ans_max=max(ans_max,ans_temp); dfs(word,pointer+1);///è¿™å¥è¯ä»¥ä¸Šæ˜¯å°†æœ¬å•è¯ä¸­çš„ä¸‹ä¸€ä¸ªå­—æ¯åŠ å…¥ç­”æ¡ˆå­—ç¬¦ä¸²ä¸­ï¼Œä»¥ä¸‹æ˜¯å°†æŸ¥çœ‹ä»¥è¿™ä¸ªå­—æ¯ä¸ºåŸºå‡†ï¼Œèƒ½ä¸èƒ½æ¥ä¸Šå…¶ä»–å•è¯çš„é¾™ ans_temp=ans_mark; &#125; int m; for(int i=1;i&lt;=n;i++)&#123;///æšä¸¾nä¸ªè¯ä¸­å“ªä¸ªè¯çš„é¦–å­—æ¯å¯ä»¥å’Œç°åœ¨å­—ç¬¦ä¸²çš„æœ€åä¸€ä¸ªç›¸åŒ if(vis[i]&gt;0)&#123; int j=0; ///!!! m=pointer; ///!!!å…¶ä»–äººçš„åšæ³•æ˜¯ç›´æ¥æšä¸¾å•è¯ word ä¸­çš„æ‰€æœ‰å­—æ¯ï¼Œä¸åƒæˆ‘æ˜¯é€šè¿‡ dfs(word,pointer+1)æ¥æšä¸¾ï¼Œæ‰€ä»¥ä¸éœ€è¦è€ƒè™‘pointerå¦‚ä½•å¦‚ä½•ï¼Œæˆ‘ä»¬è¿™é‡Œå¦‚æœå¯¹ pointer åé¢çš„å­—æ¯(pointer+1,pointer+2,...)ä¸€ä¸ªä¸ªè¿›è¡Œæ¯”å¯¹ï¼Œå¿…ç„¶ä¼šæ”¹å˜pointerçš„å€¼ï¼Œæ‰€ä»¥ç”¨äº†ä¸€ä¸ªå‰¯æœ¬ m è¿›è¡Œæ¯”å¯¹ï¼Œä¿è¯pointerå€¼ä¸å˜ if(dict[word][m]==dict[i][j])&#123;///å¦‚æœå¤´ä¸€ä¸ªå­—æ¯ç›¸åŒ bool flag=true; while(m&lt;strlen(dict[word]))&#123;///ä¸€ç›´æ¯”å¯¹åˆ°æœ€åä¸€ä¸ªå­—æ¯ï¼Œå¹¶ä¸”è¿™é‡Œåˆ¤æ–­äº†â€œç›¸é‚»çš„ä¸¤éƒ¨åˆ†ä¸èƒ½å­˜åœ¨åŒ…å«å…³ç³»â€è¿™ä¸€æ¡ä»¶ if(dict[word][m]!=dict[i][j]) flag=false; m++; j++; &#125; if(flag)&#123;///å¦‚æœæ¯ä¸ªå­—æ¯éƒ½ä¸€æ · ///!!! int ans_mark=ans_temp;///è®°å½•ä¸€ä¸‹ç°åœ¨çš„é•¿åº¦ï¼Œå› ä¸ºå†è¿›è¡Œå…¶ä»–çš„dfsï¼Œans_tempä¼šè¢«æ›´æ–° ans_temp+=j-1;///ç­”æ¡ˆå­—ç¬¦ä¸²çš„é•¿åº¦å°±å¯ä»¥åŠ ä¸Šæ–°åŠ å…¥çš„å•è¯çš„é•¿åº¦ ///!!!æ³¨æ„è¿™ä¸ªåœ°æ–¹è¿™ä¸¤å¥è¯åº”è¯¥æ˜¯å…ˆè®°å½• ans_temp å†æ›´æ–° ans_temp ï¼Œå› ä¸ºæˆ‘ä»¬æœ€åå›æº¯çš„æ—¶å€™æ˜¯è¦å›æº¯åˆ°æ²¡æœ‰æ¥é¾™æ¥ä¸Šå½“å‰å•è¯çš„çŠ¶æ€ï¼Œæ‰€ä»¥åº”è¯¥æ˜¯å…ˆè®°å½•ï¼Œåæ›´æ–° ans_max=max(ans_max,ans_temp); vis[i]--; dfs(i,j); vis[i]++; ans_temp=ans_mark;///æŠŠans_tempæ›´æ–°å›æ¥ &#125; &#125; &#125; &#125;&#125; å…ˆé¢„å¤„ç†å¾—åˆ°ä¸¤ä¸¤å•è¯é—´çš„æœ€çŸ­é‡åˆéƒ¨åˆ†ï¼Œç„¶åæœç´¢å¾—åˆ°ç­”æ¡ˆ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;string dict[31]; int ans_now=1,ans_max=0,n,vis[31],overlap[31][31];///è¿™ä¸ªåœ°æ–¹æŠŠ ans_now è®¾ä¸º1ï¼Œæ˜¯å› ä¸ºç¬¬ä¸€ä¸ªå¼€å¤´çš„å­—æ¯ä¸ä¼šè¢«ç®—åœ¨é•¿åº¦å†…ï¼Œä¸ºäº†æŠŠè¿™ä¸ªå¼€å¤´çš„å­—æ¯ç®—è¿›å»ï¼Œans_now ä»1å¼€å§‹int find_overlap(string,string);///å¯»æ‰¾ä¸¤ä¸ªå•è¯çš„æœ€å°é‡åˆéƒ¨åˆ†void dfs(int);int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;dict[i]; for(int i=1;i&lt;=n;i++) vis[i]=2; cin&gt;&gt;dict[0];///å¼€å¤´çš„å­—æ¯ memset(overlap,0,sizeof(overlap)); for(int i=0;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) overlap[i][j]=find_overlap(dict[i],dict[j]); dfs(0); cout&lt;&lt;ans_max; return 0;&#125;int find_overlap(string a, string b)///å…¶ä¸­ï¼Œaæ˜¯å°†è¦è¢«åˆ«äººæ¥ä¸Šå»çš„å­—ç¬¦ä¸²ï¼Œbæ˜¯æƒ³è¦æ¥ä¸Šå»çš„å­—ç¬¦ä¸²&#123; for(int i=a.size()-1;i&gt;=0;i--)&#123;///å€’åºå¯»æ‰¾æœ€å°é‡åˆéƒ¨åˆ†çš„å¤§å° int ja=i,jb=0; bool flag=true; while(ja&lt;a.size())&#123;///æ­£åºçœ‹çœ‹è¿™ä¸ªéƒ¨åˆ†æ˜¯å¦é‡åˆ if(a[ja]!=b[jb]) &#123;flag=false; break;&#125; ja++; jb++; &#125; if(flag)&#123; int ans_overlap=a.size()-i; ///å¾—åˆ°é‡å éƒ¨åˆ†çš„å¤§å° if(ans_overlap!=a.size()&amp;&amp;ans_overlap!=b.size()) return ans_overlap; ///åˆ¤æ–­é‡å éƒ¨åˆ†æ˜¯ä¸æ˜¯åŒ…å«éƒ¨åˆ†ï¼Œå¦‚æœä¸æ˜¯å°±è¿”å›ç­”æ¡ˆ else if(a.size()==1) return ans_overlap; ///å¦‚æœæ˜¯å¼€å¤´çš„å­—æ¯(cin&gt;&gt;dict[0])ï¼Œæ°¸è¿œæœ‰ ans_overlap==a.size()==0 é‚£ä¹ˆä¸ç®¡ans_overlap!=a.size()æ˜¯å¦æˆç«‹ï¼Œæˆ‘ä»¬éƒ½è¦è¿”å›ç­”æ¡ˆ else return 0;///å…¶ä»–çš„æƒ…å†µä¸‹ï¼Œé‡å éƒ¨åˆ†æ˜¯åŒ…å«éƒ¨åˆ†ï¼Œä¸èƒ½æ¥é¾™ï¼Œæ‰€ä»¥è¿”å›0 &#125; &#125; return 0;///æ²¡æ‰¾åˆ°é‡å éƒ¨åˆ†&#125;void dfs(int word)&#123; for(int i=1;i&lt;=n;i++)&#123; if(overlap[word][i]&gt;0 &amp;&amp; vis[i]&gt;0)&#123; ans_now+=dict[i].size()-overlap[word][i];///æ¥ä¸Šçš„å­—ç¬¦ä¸²çš„é•¿åº¦ ans_max=max(ans_max,ans_now); vis[i]--; dfs(i); vis[i]++; ans_now-=dict[i].size()-overlap[word][i]; &#125; &#125;&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"https://harmonyano.github.io/tags/NOI/"}]},{"title":"P1101 å•è¯æ–¹é˜µ","slug":"P1101 å•è¯æ–¹é˜µ","date":"2019-06-17T04:00:00.000Z","updated":"2019-06-27T12:38:11.330Z","comments":true,"path":"P1101 å•è¯æ–¹é˜µ/","link":"","permalink":"https://harmonyano.github.io/P1101%20%E5%8D%95%E8%AF%8D%E6%96%B9%E9%98%B5/","excerpt":"é¢˜ç›®æ¥æºï¼šæ´›è°·P1101 å•è¯æ–¹é˜µ dir è¿™ä¸ªæ•°ç»„æ˜¯å¾ˆå¥½ç”¨çš„ï¼Œä¸éœ€è¦ä¸º8ä¸ªæ–¹å‘ç‰¹æ„å†™8ä¸ªä¸åŒçš„å‡½æ•°ï¼Œåªéœ€è¦å†™ä¸€ä¸ªå‡½æ•°ä½†æ˜¯æ”¹å˜å–å“ªä¸€ä¸ªdir[i]æ¥åˆ¤å®šå“ªä¸€ä¸ªæ–¹å‘ç¬¦åˆæ¡ä»¶å°±è¡Œäº†","text":"é¢˜ç›®æ¥æºï¼šæ´›è°·P1101 å•è¯æ–¹é˜µ dir è¿™ä¸ªæ•°ç»„æ˜¯å¾ˆå¥½ç”¨çš„ï¼Œä¸éœ€è¦ä¸º8ä¸ªæ–¹å‘ç‰¹æ„å†™8ä¸ªä¸åŒçš„å‡½æ•°ï¼Œåªéœ€è¦å†™ä¸€ä¸ªå‡½æ•°ä½†æ˜¯æ”¹å˜å–å“ªä¸€ä¸ªdir[i]æ¥åˆ¤å®šå“ªä¸€ä¸ªæ–¹å‘ç¬¦åˆæ¡ä»¶å°±è¡Œäº† 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;char matrix[103][103], yizhong[8]=&quot;yizhong&quot;; bool mark[103][103];/// matrix å­˜å‚¨æ¯ä¸ªä½ç½®çš„å­—æ¯ï¼Œyizhong å­˜å‚¨æˆ‘ä»¬è¦æ‰¾çš„å­—ç¬¦ä¸² &quot;yizhong&quot;ï¼Œmarkå­˜å‚¨è¿™ä¸ªä½ç½®ç¬¦ä¸ç¬¦åˆè¦æ±‚ï¼Œæœ€åè¦ä¸è¦è¢«å˜æˆ &quot;*&quot; è¾“å‡ºint dir[8][2]=&#123;&#123;0,1&#125;,&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;,&#123;0,-1&#125;,&#123;-1,-1&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;&#125;;/// dir[8] å­˜å‚¨äº†8ä¸ªæ–¹å‘ï¼Œdir[i][0] æ˜¯xè½´åæ ‡ï¼Œdir[i][1] æ˜¯yè½´åæ ‡void dfs(int,int); /// è¿™ä¸ªé¢˜è™½ç„¶æ”¾åœ¨dfsé‡Œé¢ä½†æ˜¯å› ä¸ºè¿™ä¸ªå­—ç¬¦ä¸²çš„æ–¹å‘æ˜¯å›ºå®šçš„ï¼Œä¸ä¼šæ‹å¼¯æŠ¹è§’ï¼Œæ‰€ä»¥å¥½åƒå’Œdfsæ²¡ä»€ä¹ˆå…³ç³»int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) cin&gt;&gt;matrix[i][j]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dfs(i,j); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(mark[i][j]) cout&lt;&lt;matrix[i][j]; else cout&lt;&lt;&quot;*&quot;; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;void dfs(int x, int y)&#123; for(int i=0;i&lt;8;i++)&#123; ///å¯¹äºä»»æ„ä¸€ä¸ªç‚¹ï¼Œæˆ‘ä»¬éƒ½çœ‹çœ‹å®ƒå‘¨å›´å…«ä¸ªæ–¹å‘å„è‡ªç¬¦ä¸ç¬¦åˆæ¡ä»¶ int j=0;bool flag=true; while(j&lt;7)&#123; ///åˆ†åˆ«æ£€è§†æ¯ä¸€ä¸ªå­—ç¬¦ ä¸ yizhong æ˜¯å¦åŒ¹é… if(matrix[x+j*dir[i][0]][y+j*dir[i][1]] != yizhong[j])&#123; ///éå¸¸ç²¾é«“ flag=false; break; /// ä¸åŒ¹é…ï¼Œflag=false &#125; j++; &#125; if(flag)&#123; ///åŒ¹é…çš„è¯å°±è®°å½•ä¸‹æ¥å®ƒä»¬æ˜¯ç¬¦åˆè¦æ±‚çš„ï¼Œæœ€åç›´æ¥è¾“å‡ºå½“å‰ä½ç½®çš„å­—ç¬¦ for(int j=0;j&lt;7;j++) mark[x+j*dir[i][0]][y+j*dir[i][1]]=true; &#125; &#125;&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"https://harmonyano.github.io/tags/NOI/"}]},{"title":"P1219 å…«çš‡å","slug":"P1219 å…«çš‡å","date":"2019-06-16T04:00:00.000Z","updated":"2019-06-27T12:35:50.676Z","comments":true,"path":"P1219 å…«çš‡å/","link":"","permalink":"https://harmonyano.github.io/P1219%20%E5%85%AB%E7%9A%87%E5%90%8E/","excerpt":"é¢˜ç›®æ¥æºï¼šæ´›è°·P1219 å…«çš‡å æˆ‘çš„è§£æ³•è‡ªå·±çš„ç¨‹åºå‡ºç°çš„å‡ ä¸ªé—®é¢˜ï¼š å¯¹è§’çº¿è¡¨è¾¾å¼å¤ªè¿‡å¤æ‚ï¼Œå„å±‚ç»å¯¹å€¼éƒ½å¯ä»¥ç®€åŒ–ï¼Œåº”è¯¥ç›¸ä¿¡å¤§éƒ¨åˆ†æƒ…å†µä¸‹å¤æ‚çš„éƒ½æ˜¯é”™è¯¯çš„ ä¸éœ€è¦è®°å½•è¿™ä¸€è¡Œæ”¾æ²¡æ”¾è¿‡æ£‹å­ï¼Œå› ä¸ºæˆ‘ä»¬æ˜¯æŒ‰ç…§ä¸€è¡Œä¸€è¡Œçš„é¡ºåºæ”¾è¿‡æ¥çš„ï¼Œä¸Šä¸€è¡Œå¿…å®šæœ‰æ£‹å­ï¼Œä¸‹ä¸€è¡Œå¿…å®šæ— æ£‹å­","text":"é¢˜ç›®æ¥æºï¼šæ´›è°·P1219 å…«çš‡å æˆ‘çš„è§£æ³•è‡ªå·±çš„ç¨‹åºå‡ºç°çš„å‡ ä¸ªé—®é¢˜ï¼š å¯¹è§’çº¿è¡¨è¾¾å¼å¤ªè¿‡å¤æ‚ï¼Œå„å±‚ç»å¯¹å€¼éƒ½å¯ä»¥ç®€åŒ–ï¼Œåº”è¯¥ç›¸ä¿¡å¤§éƒ¨åˆ†æƒ…å†µä¸‹å¤æ‚çš„éƒ½æ˜¯é”™è¯¯çš„ ä¸éœ€è¦è®°å½•è¿™ä¸€è¡Œæ”¾æ²¡æ”¾è¿‡æ£‹å­ï¼Œå› ä¸ºæˆ‘ä»¬æ˜¯æŒ‰ç…§ä¸€è¡Œä¸€è¡Œçš„é¡ºåºæ”¾è¿‡æ¥çš„ï¼Œä¸Šä¸€è¡Œå¿…å®šæœ‰æ£‹å­ï¼Œä¸‹ä¸€è¡Œå¿…å®šæ— æ£‹å­ æ³¨æ„åˆå§‹åŒ–çš„éƒ¨åˆ†ï¼Œä¸€å¼€å§‹å°±æ˜¯æŠŠå¾ªç¯è¯­å¥é‡Œå†™æˆäº† NE_SW[i]=true; NE_SW[i+1]=true å¯¼è‡´äº†é”™è¯¯è€Œä¸”ä¸€ç›´æ²¡æ£€æŸ¥å‡ºæ¥ æœ€åé‚£ä¸ªå­˜å‚¨ solution çš„åœ°æ–¹è¿˜æ˜¯æœ‰é—®é¢˜ï¼Œå¦‚æœæ‰¾åˆ°äº†æŸä¸€è¡Œçš„ä¸€ä¸ªè§£å¹¶ä¸”ç»§ç»­å‘ä¸‹æœå¯»è¿™ä¸€è¡Œçš„å…¶ä»–è§£çš„è¯ï¼Œä¼šå‡ºç°ä¸å­˜å‚¨å‰é¢å‡ è¡Œæ£‹å­ä½ç½®çš„é—®é¢˜ï¼Œæ²¡æƒ³åˆ°è§£å†³æ–¹æ³•åªèƒ½åœ¨è¾“å‡ºçš„åœ°æ–¹åšäº†äº›æ“ä½œ å¤§éƒ¨åˆ†æ ‡è§£ä¸­dfsåªæœ‰ä¸€ä¸ªå‚æ•°å°±æ˜¯è¡Œæ•°xç„¶åå¯¹äºæ¯ä¸ªxè¿›è¡Œforå¾ªç¯æšä¸¾çºµåæ ‡yï¼Œæˆ‘è¿™æ ·çš„åšæ³•ä¹Ÿå¯ä»¥ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;bool board[14][14],col[14],line[14],NE_SW[26],NW_SE[26]; int n,ans,solution[3][15];bool flag(int, int);void dfs(int, int);int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123;col[i]=true; line[i]=true; NE_SW[i]=true; NW_SE[i]=true; NE_SW[i+n]=true; NW_SE[i+n]=true;&#125;/// è¿™ä¸ªåœ°æ–¹åˆå§‹åŒ–ä¸€å®šè¦æ³¨æ„ dfs(1,1); for(int i=0;i&lt;3;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(solution[i][j]==0) solution[i][j]=solution[i-1][j]; cout&lt;&lt;solution[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;ans;&#125;bool flag(int x,int y)///åˆ¤å®šè¿™ä¸ªç‚¹èƒ½ä¸èƒ½æ”¾æ£‹å­&#123; if(col[x]&amp;&amp;line[y])&#123;if(NE_SW[x+y-1])&#123; if( y&lt;=x &amp;&amp; NW_SE[n-int(abs(x-y))] ) return true; else if( y&gt;x &amp;&amp; NW_SE[n+int(abs(x-y))] ) return true; //cout&lt;&lt;&quot;æœ€åä¸€ä¸ªå¯¹è§’çº¿å‡ºäº†é—®é¢˜&quot;&lt;&lt;endl; &#125;//cout&lt;&lt;&quot;ç¬¬ä¸€ä¸ªå¯¹è§’çº¿å‡ºäº†é—®é¢˜&quot;&lt;&lt;endl; &#125; //cout&lt;&lt;&quot;x,yæœ‰é—®é¢˜&quot;&lt;&lt;endl; return false;&#125;void dfs(int x,int y)&#123; ///cout&lt;&lt;&quot;function called at&quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl; if(flag(x,y))&#123; //if(x==n) ans++; if(ans&lt;=3) solution[ans][x]=y; ///cout&lt;&lt;endl&lt;&lt;&quot;one unit placed at&quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl&lt;&lt;endl; col[x]=false; line[y]=false; if(y&lt;=7-x) NE_SW[x+y-1]=false; ///å·¦ä¸Šè§’éƒ¨åˆ†çš„ å³ä¸Š-å·¦ä¸‹å¯¹è§’çº¿ else NE_SW[x+y-1]=false; /// å³ä¸‹è§’éƒ¨åˆ†çš„ å³ä¸Š-å·¦ä¸‹å¯¹è§’çº¿ if(y&lt;=x) NW_SE[n-int(abs(x-y))]=false; ///å³ä¸Šè§’éƒ¨åˆ†çš„ å·¦ä¸Š-å³ä¸‹å¯¹è§’çº¿ else NW_SE[n+int(abs(x-y))]=false; ///å·¦ä¸‹è§’éƒ¨åˆ† å·¦ä¸Š-å³ä¸‹å¯¹è§’çº¿ if(x==n) &#123;ans++;&#125; ///cout&lt;&lt;&quot;-------------&quot;&lt;&lt;endl&lt;&lt;&quot;one solution found, total solution is now &quot;&lt;&lt;ans&lt;&lt;endl&lt;&lt;&quot;-------------&quot;&lt;&lt;endl;&#125; else dfs(x+1,1); col[x]=true; line[y]=true; if(y&lt;=7-x) NE_SW[x+y-1]=true; ///å·¦ä¸Šè§’éƒ¨åˆ†çš„ å³ä¸Š-å·¦ä¸‹å¯¹è§’çº¿ else NE_SW[x+y-1]=true; /// å³ä¸‹è§’éƒ¨åˆ†çš„ å³ä¸Š-å·¦ä¸‹å¯¹è§’çº¿ if(y&lt;=x) NW_SE[n-int(abs(x-y))]=true; ///å³ä¸Šè§’éƒ¨åˆ†çš„ å·¦ä¸Š-å³ä¸‹å¯¹è§’çº¿ else NW_SE[n+int(abs(x-y))]=true; ///å·¦ä¸‹è§’éƒ¨åˆ† å·¦ä¸Š-å³ä¸‹å¯¹è§’çº¿ ///cout&lt;&lt;&quot;value changed back at&quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl; &#125; if(y&lt;n) dfs(x,y+1);&#125; æ›´å¯è¯»çš„ä»£ç ä»¥åŠé—®é¢˜ä¼˜åŒ– ä¼˜åŒ–äº†å¯¹è§’çº¿çš„è¡¨è¾¾ ä¼˜åŒ–äº†ç­”æ¡ˆä½ç½®çš„è®°å½• 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;bool col[14],line[14],NE_SW[26],NW_SE[26]; int n,ans=0,solution[14]; /// col[x] line[y]/// NE_SW å³ä¸Šå‘å·¦ä¸‹æ–¹å‘çš„å¯¹è§’çº¿ï¼Œä»å·¦ä¸Šè§’(1,1)ä¸ºç¬¬ä¸€æ¡ï¼Œç¬¬äºŒæ¡æ˜¯(2,1)-(1,2)/// NW_SE å·¦ä¸Šåˆ°å³ä¸‹æ–¹å‘çš„å¯¹è§’çº¿ï¼Œä»å³ä¸Šè§’(1,n)ä¸ºç¬¬ä¸€æ¡ï¼Œç¬¬äºŒæ¡æ˜¯(n-1,1)-(n,2)void dfs(int,int);bool flag(int,int);int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123;col[i]=true; line[i]=true; NE_SW[i]=true; NW_SE[i]=true; NE_SW[i+n]=true; NW_SE[i+n]=true;&#125; dfs(1,1); cout&lt;&lt;ans; return 0;&#125;bool flag(int x,int y)&#123; return col[x]&amp;&amp;line[y]&amp;&amp;NE_SW[x+y]&amp;&amp;NW_SE[n+y-x];&#125;void dfs(int x,int y)&#123; if(flag(x,y))&#123; solution[x]=y;///æ³¨æ„è¿™ä¸ªåœ°æ–¹ç‰¹åˆ«ç²¾é«“ï¼Œå› ä¸ºå¦‚æœæˆ‘ä»¬æ¯ä¸ªç­”æ¡ˆéƒ½å¼€æ–°çš„ä¸€è¡Œæ•°ç»„è®°å½•çš„è¯æœ‰å¯èƒ½ä¼šå‡ºç°ä¸Šé¢é—®é¢˜4è¯´çš„æƒ…å†µï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦æ¯æ¬¡è¦†ç›–è®°å½•å°±å¥½äº†ï¼Œåæ­£xæ°¸è¿œæ˜¯æŒ‰ä»ä¸Šåˆ°ä¸‹çš„é¡ºåºæ¥çš„ //col[x]=false; line[y]=false; NE_SW[x+y]=false; NW_SE[n+y-x]=false; col[x]=!col[x]; line[y]=!line[y]; NE_SW[x+y]=!NE_SW[x+y]; NW_SE[n+y-x]=!NW_SE[n+y-x]; ///æ³¨æ„ !col[x] åªæ˜¯è¡¨è¾¾ col[x] å–åçš„ä¸€ä¸ªå€¼ï¼Œåªæœ‰ col[x]=!col[x] æ‰èƒ½ç»™åŸæ³¢å°”å€¼èµ‹å€¼ä¸ºå®ƒçš„å if(x==n)&#123;///æœ€åä¸€è¡Œä¹Ÿè¢«å¡«å¥½äº†ï¼Œæˆ‘ä»¬å¾—åˆ°ä¸€ä¸ªè§£ ans++; if(ans&lt;=3)&#123; for(int i=1;i&lt;=n;i++) cout&lt;&lt;solution[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; &#125; else dfs(x+1,1);///è¿˜ä¸åˆ°æœ€åä¸€è¡Œçš„è¯å°±æ¥ç€å»æ‰¾ä¸‹ä¸€è¡Œ ///å›æº¯ï¼šæ‹¿èµ°åˆšåˆšæ”¾ä¸‹çš„æ£‹å­ //col[x]=true; line[y]=true; NE_SW[x+y]=true; NW_SE[n+y-x]=true; col[x]=!col[x]; line[y]=!line[y]; NE_SW[x+y]=!NE_SW[x+y]; NW_SE[n+y-x]=!NW_SE[n+y-x]; &#125; ///å¦‚æœè¿™ä¸ªä½ç½®ä¸ç¬¦åˆæ¡ä»¶(flag(x,y)==false)/è¿™ä¸ªä½ç½®ç¬¦åˆæ¡ä»¶çš„æƒ…å†µå·²ç»è¢«å…¨éƒ¨æšä¸¾äº†(flag(x,y)==true) é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥å»æ‰¾æœ¬è¡Œçš„ä¸‹ä¸€ä¸ªä½ç½®æ˜¯å¦æ»¡è¶³æ¡ä»¶ if(y&lt;n) dfs(x,y+1);&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"https://harmonyano.github.io/tags/NOI/"}]},{"title":"P1031 å‡åˆ†çº¸ç‰Œ","slug":"P1031 å‡åˆ†çº¸ç‰Œ","date":"2019-06-04T04:00:00.000Z","updated":"2019-06-27T12:40:49.788Z","comments":true,"path":"P1031 å‡åˆ†çº¸ç‰Œ/","link":"","permalink":"https://harmonyano.github.io/P1031%20%E5%9D%87%E5%88%86%E7%BA%B8%E7%89%8C/","excerpt":"é¢˜ç›®æ¥æºï¼šæ´›è°·P1031 å‡åˆ†çº¸ç‰Œ æ ‡è§£æ³¨æ„æœ¬é¢˜ä¸­å¹³å‡æ•°çš„è¿ç”¨ é¦–å…ˆï¼Œä¸€å®šè¦æƒ³åˆ°æ¯å †æ’çš„å¼ æ•°å‡å»å¹³å‡å¼ æ•°ï¼Œè¿™æ ·ï¼Œé¢˜ç›®å°±å˜æˆäº†ç§»åŠ¨æ­£æ•°ï¼ŒåŠ åˆ°è´Ÿæ•°ä¸­ï¼Œæ˜¯å¤§å®¶éƒ½å˜æˆäº†0ï¼Œè¿™å°±æ„å‘³ç€æˆåŠŸäº†60%ï¼ï¼ï¼ï¼ï¼ˆå…³é”®ï¼‰ã€‚ä»¥ä¾‹é¢˜æ¥è¯´ï¼Œå¹³å‡å¼ æ•°ä¸º10ï¼ŒåŸå¼ æ•°å˜ä¸º-1ï¼Œ-2,+7ï¼Œ-4ï¼Œå› ä¸ºæ²¡æœ‰ä¸º0çš„æ•°ï¼Œæ‰€ä»¥ä»æœ€å·¦è¾¹å‡ºå‘ï¼Œå°†-1ç§»åŠ¨åˆ°-2ä¸­ï¼Œå˜ä¸º0ï¼Œ-3ï¼Œ+7,4ï¼Œå†è®²-3å‘å³ç§»åŠ¨â€¦â€¦ä¸€æ¬¡ç±»æ¨ï¼Œç›´åˆ°å…¨ä¸º0ä¸ºæ­¢ã€‚æ²¡ç§»åŠ¨ä¸€æ¬¡ï¼Œæ­¥æ•°ä¾¿åŠ 1ã€‚å…³é”®æ˜¯ï¼Œè´Ÿæ•°æ€ä¹ˆç§»åŠ¨ï¼Œå…¶å®ï¼Œç§»åŠ¨-xå¼ ç‰Œï¼Œå…¶å®å°±æ˜¯ä»å¦ä¸€å †ä¸­ç§»åŠ¨xå¼ ç‰Œï¼Œæ­¥æ•°ç›¸åŒã€‚è¿˜æœ‰å°±æ˜¯è¦è¿‡æ»¤0ï¼Œå¦‚æ’æ•°ä¸º4ï¼Œ4,2,6ï¼Œåˆ™å‡å»å¹³å‡æ•°åä¸º0,0ï¼Œ-2,2ï¼Œå°±è¦ä»ç¬¬ä¸‰å¯¹å¼€å§‹ç§»åŠ¨ã€‚æ³¨æ„æœ‰äº›0æ˜¯ä¸èƒ½è¿‡æ»¤çš„ï¼Œå¦‚1,0,1ï¼Œ-2ä¸­çš„0ã€‚è¿˜æœ‰å°±æ˜¯æ¯æ¬¡ç§»åŠ¨å¥½éƒ½è¦è¿‡æ»¤ã€‚å¦‚-2ï¼Œ2,1,3ï¼Œ-4ï¼Œç¬¬ä¸€æ­¥åå˜ä¸º0,0,1,3ï¼Œ-4ï¼Œå¯ä»¥çœç•¥ç¬¬äºŒå †çš„ç§»åŠ¨ã€‚","text":"é¢˜ç›®æ¥æºï¼šæ´›è°·P1031 å‡åˆ†çº¸ç‰Œ æ ‡è§£æ³¨æ„æœ¬é¢˜ä¸­å¹³å‡æ•°çš„è¿ç”¨ é¦–å…ˆï¼Œä¸€å®šè¦æƒ³åˆ°æ¯å †æ’çš„å¼ æ•°å‡å»å¹³å‡å¼ æ•°ï¼Œè¿™æ ·ï¼Œé¢˜ç›®å°±å˜æˆäº†ç§»åŠ¨æ­£æ•°ï¼ŒåŠ åˆ°è´Ÿæ•°ä¸­ï¼Œæ˜¯å¤§å®¶éƒ½å˜æˆäº†0ï¼Œè¿™å°±æ„å‘³ç€æˆåŠŸäº†60%ï¼ï¼ï¼ï¼ï¼ˆå…³é”®ï¼‰ã€‚ä»¥ä¾‹é¢˜æ¥è¯´ï¼Œå¹³å‡å¼ æ•°ä¸º10ï¼ŒåŸå¼ æ•°å˜ä¸º-1ï¼Œ-2,+7ï¼Œ-4ï¼Œå› ä¸ºæ²¡æœ‰ä¸º0çš„æ•°ï¼Œæ‰€ä»¥ä»æœ€å·¦è¾¹å‡ºå‘ï¼Œå°†-1ç§»åŠ¨åˆ°-2ä¸­ï¼Œå˜ä¸º0ï¼Œ-3ï¼Œ+7,4ï¼Œå†è®²-3å‘å³ç§»åŠ¨â€¦â€¦ä¸€æ¬¡ç±»æ¨ï¼Œç›´åˆ°å…¨ä¸º0ä¸ºæ­¢ã€‚æ²¡ç§»åŠ¨ä¸€æ¬¡ï¼Œæ­¥æ•°ä¾¿åŠ 1ã€‚å…³é”®æ˜¯ï¼Œè´Ÿæ•°æ€ä¹ˆç§»åŠ¨ï¼Œå…¶å®ï¼Œç§»åŠ¨-xå¼ ç‰Œï¼Œå…¶å®å°±æ˜¯ä»å¦ä¸€å †ä¸­ç§»åŠ¨xå¼ ç‰Œï¼Œæ­¥æ•°ç›¸åŒã€‚è¿˜æœ‰å°±æ˜¯è¦è¿‡æ»¤0ï¼Œå¦‚æ’æ•°ä¸º4ï¼Œ4,2,6ï¼Œåˆ™å‡å»å¹³å‡æ•°åä¸º0,0ï¼Œ-2,2ï¼Œå°±è¦ä»ç¬¬ä¸‰å¯¹å¼€å§‹ç§»åŠ¨ã€‚æ³¨æ„æœ‰äº›0æ˜¯ä¸èƒ½è¿‡æ»¤çš„ï¼Œå¦‚1,0,1ï¼Œ-2ä¸­çš„0ã€‚è¿˜æœ‰å°±æ˜¯æ¯æ¬¡ç§»åŠ¨å¥½éƒ½è¦è¿‡æ»¤ã€‚å¦‚-2ï¼Œ2,1,3ï¼Œ-4ï¼Œç¬¬ä¸€æ­¥åå˜ä¸º0,0,1,3ï¼Œ-4ï¼Œå¯ä»¥çœç•¥ç¬¬äºŒå †çš„ç§»åŠ¨ã€‚ 1234567891011#include &lt;iostream&gt; using namespace std; int main() &#123; int a,p=0,js=0; cin &gt;&gt;a;int q[a]; for (int y=0;y&lt;a;y++)&#123;cin &gt;&gt;q[y]; p+=q[y];&#125; p/=a; for (int y=0;y&lt;a;y++)q[y]-=p; for (int y=0;y&lt;a;y++) &#123;if (q[y]==0)continue; q[y+1]+=q[y]; js++; &#125; cout &lt;&lt;js; return 0;&#125; æˆ‘çš„è§£æ³•1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int sum=0,card[103],num,mean,no_count=0; cin&gt;&gt;num; for(int i=1;i&lt;=num;i++) &#123;cin&gt;&gt;card[i]; sum+=card[i];&#125; mean=sum/num; int pointer=0,local_sum=0; for(int i=1;i&lt;=num;i++)&#123; local_sum+=card[i]; pointer++;///æˆ‘çš„æ€è·¯æ˜¯è®°å½•æœ‰æ²¡æœ‰ä¸€ä¸ª local_max==local_sumï¼Œå¦‚æœæœ‰ local_sumï¼Œå³pointeræ‰€æŒ‡çš„é‚£ä¸€å †ï¼Œä¹‹å‰çš„å°±å…¨éƒ¨æ’å¥½äº†ï¼Œä¸éœ€è¦å†æ“å¿ƒäº† if(pointer==1 &amp;&amp; card[i]==mean) &#123;pointer=1; no_count++;&#125; ///ç›´æ¥ç­‰äºå¹³å‡æ•°çš„å †è¦æ‹¿å‡ºæ¥ç‰¹æ®Šè®¨è®ºï¼Œå› ä¸ºä»–ä»¬åªæœ‰è·Ÿåœ¨å·²ç»æ’å¥½åºçš„å †åé¢çš„æ—¶å€™æ‰ä¸éœ€è¦å†ç»è¿‡ä¸€æ¬¡ç§»åŠ¨ï¼Œè€Œå‰é¢çš„å †å·²ç»æ’å¥½åºçš„æ ‡å¿—å°±æ˜¯ pointer==1ï¼Œè¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬å¯ä»¥å°‘ç§»åŠ¨ä¸€ä¸ªï¼Œå¹¶ä¸”é‡æ–°è®¾ç½® pointer==1 ä»£è¡¨å‰é¢çš„å †éƒ½æœ‰åº if(local_sum==pointer*mean &amp;&amp; pointer!=1)&#123; /// local_sum==pointer*mean æ­¤æ—¶æˆ‘ä»¬æ‰¾åˆ°ä¸€ä¸ªå †ï¼Œå¯ä»¥ä½¿å‰é¢çš„æ‰€æœ‰å †è·å¾—ç¬¦åˆè¦æ±‚çš„è§£ï¼Œå¹¶ä¸”ä»–åªéœ€è¦å‘åˆ«äººè¾“é€ç‰Œï¼Œè‡ªå·±ä¸éœ€è¦æ¥å—ï¼Œæ‰€ä»¥æœ‰ä¸€ä¸ª no_count++ /// pointer!=1 è¿™æ˜¯ local_sum å°±æ˜¯ä»–æœ¬èº«ï¼Œå¿…ç„¶ç›¸ç­‰ no_count++; pointer=0; local_sum=0; &#125; &#125; cout&lt;&lt;num-no_count;&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"https://harmonyano.github.io/tags/NOI/"}]},{"title":"P2678 è·³çŸ³å¤´","slug":"P2678 è·³çŸ³å¤´","date":"2019-06-03T04:00:00.000Z","updated":"2019-06-27T12:27:21.150Z","comments":true,"path":"P2678 è·³çŸ³å¤´/","link":"","permalink":"https://harmonyano.github.io/P2678%20%E8%B7%B3%E7%9F%B3%E5%A4%B4/","excerpt":"é¢˜ç›®æ¥æºï¼šæ´›è°·P2678 è·³çŸ³å¤´ è¿™æ˜¯ä¸€é“æ ‡å‡†çš„ â€œæœ€å¤§å€¼æœ€å°â€æˆ–â€œæœ€å°å€¼æœ€å¤§â€œ çš„é¢˜ï¼Œé‡åˆ°è¿™ç§é¢˜ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨ è´ªå¿ƒ+äºŒåˆ†æŸ¥æ‰¾ çš„æ–¹æ³•æ¥åš äºŒåˆ†ç­”æ¡ˆ/äºŒåˆ†æŸ¥æ‰¾æœ‰åºï¼ˆå•è°ƒï¼‰çš„ï¼Œæœ‰ç•Œçš„å°±å¯ä»¥ç”¨äºŒåˆ†æ³•æŸ¥æ‰¾ã€‚","text":"é¢˜ç›®æ¥æºï¼šæ´›è°·P2678 è·³çŸ³å¤´ è¿™æ˜¯ä¸€é“æ ‡å‡†çš„ â€œæœ€å¤§å€¼æœ€å°â€æˆ–â€œæœ€å°å€¼æœ€å¤§â€œ çš„é¢˜ï¼Œé‡åˆ°è¿™ç§é¢˜ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨ è´ªå¿ƒ+äºŒåˆ†æŸ¥æ‰¾ çš„æ–¹æ³•æ¥åš äºŒåˆ†ç­”æ¡ˆ/äºŒåˆ†æŸ¥æ‰¾æœ‰åºï¼ˆå•è°ƒï¼‰çš„ï¼Œæœ‰ç•Œçš„å°±å¯ä»¥ç”¨äºŒåˆ†æ³•æŸ¥æ‰¾ã€‚ æœ‰ç•Œï¼šå¯¹äºæœ¬é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œè¿™ä¸ªæ‰€è°“çš„æœ€çŸ­è·³è·ƒè·ç¦»æ˜¾ç„¶ä¸èƒ½è¶…è¿‡ä¸€ä¸ªèŒƒå›´ï¼ˆè·³ä¸€æ¬¡ä»å¤´è·³åˆ°å°¾ï¼‰ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œç­”æ¡ˆæ˜¯æœ‰ä¸€ä¸ªç¡®å®šçš„èŒƒå›´é™åˆ¶çš„ï¼ˆå¼€å¤´åˆ°ç»“å°¾çš„è·ç¦»å†…ï¼‰ï¼Œæˆ‘ä»¬å°±å¯ä»¥è€ƒè™‘ä¸€ç§å¦å¤–çš„æ–¹æ³•å»è§£å†³â€”â€”æšä¸¾ç­”æ¡ˆï¼Œå¹¶å»éªŒè¯ç­”æ¡ˆæ˜¯å¦å¯è¡Œï¼Œè¿™å®é™…ä¸Šæ˜¯ä¸€ç§å€’æ¨ äºŒåˆ†ï¼šé‚£ä¹ˆå¦‚ä½•ç¡®ä¿æˆ‘ä»¬å¯ä»¥æœ€å¿«çš„æ‰¾åˆ°ç­”æ¡ˆå‘¢ï¼ŸäºŒåˆ†æ˜¯æœ€å¥½é€‰æ‹© å•è°ƒï¼šäºŒåˆ†çš„å‰ææ¡ä»¶æ˜¯ä»€ä¹ˆï¼Ÿæ˜¯ç­”æ¡ˆåŒºé—´æ˜¯æ•´ä½“æœ‰åºçš„ã€‚æˆ‘ä»¬åªè€ƒè™‘åˆæ³•è§£ï¼Œå¹¶ç§°ä¹‹ä¸ºå¯è¡Œè§£ã€‚è€ƒè™‘æ‰€æœ‰å¯è¡Œè§£ï¼Œæˆ‘ä»¬è‚¯å®šæ˜¯è¦ä»è¿™äº›å¯è¡Œè§£ä¸­æ‰¾åˆ°ä¸€ä¸ªæœ€å¥½çš„ä½œä¸ºæˆ‘ä»¬çš„ç­”æ¡ˆï¼Œ è¿™ä¸ªç­”æ¡ˆæˆ‘ä»¬ç§°ä¹‹ä¸ºæœ€ä¼˜è§£ã€‚æœ€ä¼˜è§£ä¸€å®šå¯è¡Œï¼Œä½†å¯è¡Œè§£ä¸ä¸€å®šæœ€ä¼˜ã€‚ æˆ‘ä»¬å‡è®¾æ•´ä¸ªåºåˆ—å…·æœ‰å•è°ƒæ€§ï¼Œä¸”ä¸€ä¸ªæ•°xä¸ºå¯è¡Œè§£ï¼Œé‚£ä¹ˆä¸€èˆ¬çš„ï¼Œæ‰€æœ‰çš„xâ€™(xâ€™&lt;x)éƒ½æ˜¯å¯è¡Œè§£ã€‚ å¹¶ä¸”ï¼Œå¦‚æœæœ‰ä¸€ä¸ªæ•°yæ˜¯éæ³•è§£ï¼Œé‚£ä¹ˆä¸€èˆ¬çš„ï¼Œæ‰€æœ‰çš„yâ€™(yâ€™&gt;y)éƒ½æ˜¯éæ³•è§£ã€‚ æ€»ç»“æ¥è¯´ï¼Œå¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾çš„æ¡ä»¶ï¼šè§£çš„ä¸Šä¸‹ç•Œç¡®å®š(l=0,r=L),å¯ä»¥å†™å‡ºåˆ¤æ–­æ¡ä»¶(f(x)&lt;=m),è§£å…·æœ‰åŒºé—´å•è°ƒæ€§(åœ¨æŸä¸ªå€¼ä¹‹å‰æ¡ä»¶éƒ½æˆç«‹ï¼Œä¹‹åéƒ½ä¸æˆç«‹) æœ¬é¢˜å’Œ P2855 River Hopscotch æ˜¯åŒä¸€é“é¢˜ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int rocks[50003],ending,num,removed,result;void finding(int,int);int main()&#123; cin&gt;&gt;ending&gt;&gt;num&gt;&gt;removed; for(int i=1;i&lt;=num;i++) cin&gt;&gt;rocks[i]; rocks[0]=0; rocks[num+1]=ending; sort(rocks+1,rocks+num+1); finding(0,ending); cout&lt;&lt;result; return 0;&#125;void finding(int m, int n)&#123; int mid=(m+n)/2, removing=0; int now=0,pointer=0;///now è¡¨ç¤ºæˆ‘ä»¬ç°åœ¨æ‰€åœ¨çš„ä½ç½®ï¼Œpointer è¡¨ç¤ºä¸‹ä¸€ä¸ªå¯ä»¥è·³åˆ°çš„ä½ç½® while(pointer&lt;num)&#123;///äººå®¶è¿™ä¸ªæ–¹æ³•ç›´æ¥ä¸€æ­¥å­è¿ˆè¿‡å»äº†ï¼Œæ ¹æœ¬ä¸éœ€è¦è®°å½•å“ªä¸ªçŸ³å¤´è¢«æ‹¿æ‰äº†ï¼Œæˆ–è€…åˆ¤å®šä¸€ä¸ªåŸæœ¬æœ‰çŸ³å¤´çš„åœ°æ–¹è¢«æ²¡è¢«æ‹¿æ‰ï¼Œæ¯•ç«Ÿé¢˜ç›®æœ¬èº«å°±å«è·³çŸ³å¤´ï¼Œä¸ºä»€ä¹ˆè¦ä¸€ä¸ªä¸ªçŸ³å¤´çœ‹å‘¢ï¼Œç›´æ¥è·³ä¸å°±å¥½äº† pointer++; if(rocks[pointer]-rocks[now]&lt;mid)///æˆ‘ä»¬è®¤ä¸ºmidæ˜¯æœ€çŸ­è·³è·ƒè·ç¦»ï¼Œå¦‚æœæœ‰æŸç§æƒ…å†µä½¿å¾—è·³è·ƒè·ç¦»æ¯”è¿™ä¸ªæœ€çŸ­çš„è¿˜çŸ­ï¼Œæˆ‘ä»¬å°±éœ€è¦æ‹¿èµ°è¿™å—çŸ³å¤´æ¥å¢å¤§è¿™ä¸ªåœ°æ–¹çš„è·³è·ƒè·ç¦»ï¼Œä½¿å…¶å¤§äºæœ€çŸ­è·³è·ƒè·ç¦» removing++; else//å¦‚æœæ¯”æœ€çŸ­è·ç¦»é•¿çš„è¯ï¼Œæˆ‘ä»¬å°±å¯ä»¥è·³è¿‡å» now=pointer; &#125; if(m&lt;=n)&#123; ///è¿™ä¸ªåœ°æ–¹æˆ‘å†™ m&lt;n æˆ–è€… m&lt;=n æœ‰åŒºåˆ«å—ï¼Ÿæˆ‘çš„måˆ°æœ€åçš„æ—¶å€™åªèƒ½é€šè¿‡mid+1è¿™ä¸€ç§æ–¹å¼æ›´æ–°ï¼Œ+1åˆä¸å½±å“/2ä»¥åmidçš„å€¼ï¼Œæ‰€ä»¥è¿™ä¸¤ä¸ªåˆ¤å®šä¸æ˜¯ä¸€æ ·çš„å—ï¼Ÿ ///ç¡®å®åˆ¤å®šçš„æ—¶å€™æ²¡ä»€ä¹ˆåŒºåˆ«ï¼Œæœ€åéƒ½ä¼šæ›´æ–°åˆ°m=4 n=4 mid=4ï¼Œä½†æ˜¯ m&lt;n è¿è¡Œåˆ° m=4 n=4 mid=4 ä¼šå‘ç° m!&lt;n æ‰€ä»¥ä¸ä¼šæ›´æ–° result if(removing&gt;removed) finding(m,mid-1); ///å¦‚æœæˆ‘ä»¬ä»¥midä¸ºæœ€å°è·ç¦»çš„æƒ…å†µä¸‹ç§»åŠ¨çš„çŸ³å—æ¯”æˆ‘ä»¬æœ¬åº”è¯¥ç§»åŠ¨çš„çŸ³å—å¤šçš„è¯ï¼Œè¯´æ˜è¿™ä¸ªç­”æ¡ˆæ˜¯ä¸åˆæ³•çš„ï¼Œå¹¶ä¸”æ‰€æœ‰å¤§äºmidçš„éƒ½ä¸åˆæ³•ï¼ˆè¶Šå¤§äºmidç§»åŠ¨çš„çŸ³å—åªä¼šè¶Šæ¥è¶Šå¤šï¼‰ï¼Œæ‰€ä»¥å‡å°‘ æœ€å°ç§»åŠ¨è·ç¦» ä½¿å¾—æˆ‘ä»¬ä¸è¦ç§»åŠ¨é‚£ä¹ˆå¤šçŸ³å— else if(removing&lt;=removed) &#123; result=mid; finding(mid+1,n);&#125; ///å¦‚æœä»¥midä¸ºæœ€å°è·ç¦»çš„æƒ…å†µä¸‹ç§»åŠ¨çš„çŸ³å—æ¯”æˆ‘ä»¬æœ¬åº”è¯¥ç§»åŠ¨çš„çŸ³å—å¤šçš„è¯ï¼Œè¯´æ˜è¿™ä¸ªç­”æ¡ˆåˆæ³•ï¼Œä½†æ˜¯å› ä¸ºæˆ‘ä»¬è¦å¯»æ‰¾æœ€å¤§çš„æœ€å°å€¼ï¼Œæ‰€ä»¥å¢å¤§ æœ€å°è·ç¦» çœ‹çœ‹æœ‰æ²¡æœ‰æ›´ä¼˜çš„è§£ &#125;&#125;/*25 5 2 2111417 21*/ äºŒåˆ†æŸ¥æ‰¾æ¨¡æ¿éé€’å½’å½¢å¼çš„äºŒåˆ†æŸ¥æ‰¾æ¨¡æ¿ 123456789101112int l=1,r=ll;/// 1 æ˜¯ç­”æ¡ˆçš„æœ€å°å€¼ï¼Œllæ˜¯ç­”æ¡ˆçš„æœ€å¤§å€¼ while(l&lt;=r) &#123; ///å½“å·¦å³è¾¹ç•Œé‡åˆçš„æ—¶å€™å°±æ˜¯ç­”æ¡ˆï¼Œé€€å‡ºå¾ªç¯ int mid=(l+r)&gt;&gt;1,q=check(mid);//â€œ&gt;&gt;1â€ç›¸å½“äºâ€œ/2â€ if(check) ///å½“è¯¥è·ç¦»æ»¡è¶³æ¡ä»¶çš„æ—¶å€™ &#123; ///å»å¯»æ‰¾å³åŠéƒ¨åˆ†ï¼Œçœ‹çœ‹è¿˜æœ‰æ²¡æœ‰ç¬¦åˆæ¡ä»¶çš„æ›´å¤§çš„å€¼ ll=mid+1;///llä¸Šmidå³è¾¹ï¼Œæ‰¾å³åŠéƒ¨åˆ† ans=mid;///è®°å½•ç­”æ¡ˆï¼ˆæ›´æ–°ä¸­ï¼‰ &#125; else l=mid+1;///è‹¥è¿™ä¸ªå€¼ä¸æ»¡è¶³ï¼Œå°±æ‰¾å·¦éƒ¨åˆ†&#125; ä¸‹é¢æ˜¯ä¸€ä¸ªäºŒåˆ†æŸ¥æ‰¾çš„æ ·ä¾‹ P1824 Aggressive Cows12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int stall[100005],cow_num,stall_num,ans;void finding(int,int);int main()&#123; cin&gt;&gt;stall_num&gt;&gt;cow_num; for(int i=1;i&lt;=stall_num;i++) cin&gt;&gt;stall[i]; sort(stall+1,stall+stall_num+1); finding(1,stall[stall_num]); cout&lt;&lt;ans; return 0;&#125;void finding(int m, int n)//çœ‹åˆ°ä¸€ä¸ªç¬¦åˆè¦æ±‚çš„å°±å¡«è¿›å»ï¼Œæœ€åçœ‹å¡«è¿›å»çš„cowå’Œä¸€å…±æœ‰çš„æ˜¯å¤šæ˜¯å°‘&#123; int mid=(m+n)/2,now=1,pointer=1,cow_mid=1;///cow_mid ä»1å¼€å§‹ï¼Œå¦‚æœä»0å¼€å§‹å®é™…ä¸Šç®—çš„æ˜¯é—´è·ï¼Œn+1æ‰æ˜¯ç‰›çš„æ•°é‡ while(pointer&lt;stall_num)&#123; pointer++; if(stall[pointer]-stall[now]&gt;=mid)&#123;///è¿™é‡Œæ³¨æ„æ˜¯ &gt;= åªè¦æ¯”æœ€çŸ­çš„è·ç¦»(mid)å¤§ï¼Œæˆ‘ä»¬å°±å¯ä»¥æ”¾ä¸€å¤´å¥¶ç‰›åœ¨è¿™é‡Œ cow_mid++; now=pointer;&#125; &#125; if(m&lt;=n)&#123; if(cow_mid&gt;=cow_num) &#123;ans=mid; finding(mid+1,n);&#125; ///å¦‚æœè¿™æ¬¡æ”¾çš„æ¯”æˆ‘ä»¬éœ€è¦æ”¾çš„å¤šï¼Œè¯´æ˜æˆ‘ä»¬çš„æœ€çŸ­é—´è·å¤ªå°äº†ï¼Œæ‰€ä»¥è¦å¢å¤§æœ€çŸ­é—´è· else finding(m,mid-1); &#125;&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"https://harmonyano.github.io/tags/NOI/"}]},{"title":"P1309 ç‘å£«è½®","slug":"P1309 ç‘å£«è½®","date":"2019-05-30T04:00:00.000Z","updated":"2019-06-27T12:26:55.045Z","comments":true,"path":"P1309 ç‘å£«è½®/","link":"","permalink":"https://harmonyano.github.io/P1309%20%E7%91%9E%E5%A3%AB%E8%BD%AE/","excerpt":"é¢˜ç›®æ¥æºï¼šæ´›è°·P1309 ç‘å£«è½® èƒœè€…ç»„å’Œè´¥è€…ç»„åˆ†åˆ«æ˜¯æœ‰åºçš„ï¼Œä½¿ç”¨ mergesort å°†ä¸¤ä¸ªæœ‰åºåŒå‘æ•°ç»„è¿›è¡Œå½’å¹¶ï¼ˆä¸¥æ ¼ä¸Šæ¥è¯´ä¸æ˜¯å½’å¹¶æ’åºï¼‰ï¼Œå¤§å¤§é™ä½äº†æ—¶é—´å¤æ‚åº¦ = O(n)ã€‚å¦‚æœæˆ‘ä»¬ä½¿ç”¨ quicksortï¼Œåˆ™é»˜è®¤æ•´ä¸ªæ•°æ®æ˜¯æ— åºçš„ï¼Œå¯¹æ¯ä¸ªæ•°æ®éƒ½é‡æ–°æ’åºæ‰€ä»¥ä¼šè¶…æ—¶","text":"é¢˜ç›®æ¥æºï¼šæ´›è°·P1309 ç‘å£«è½® èƒœè€…ç»„å’Œè´¥è€…ç»„åˆ†åˆ«æ˜¯æœ‰åºçš„ï¼Œä½¿ç”¨ mergesort å°†ä¸¤ä¸ªæœ‰åºåŒå‘æ•°ç»„è¿›è¡Œå½’å¹¶ï¼ˆä¸¥æ ¼ä¸Šæ¥è¯´ä¸æ˜¯å½’å¹¶æ’åºï¼‰ï¼Œå¤§å¤§é™ä½äº†æ—¶é—´å¤æ‚åº¦ = O(n)ã€‚å¦‚æœæˆ‘ä»¬ä½¿ç”¨ quicksortï¼Œåˆ™é»˜è®¤æ•´ä¸ªæ•°æ®æ˜¯æ— åºçš„ï¼Œå¯¹æ¯ä¸ªæ•°æ®éƒ½é‡æ–°æ’åºæ‰€ä»¥ä¼šè¶…æ—¶ ä¸€ç§å¯ä»¥æ›¿ä»£ç»“æ„ä½“çš„æ–¹æ³•ï¼šæ’åçš„æ—¶å€™æˆ‘ä»¬å¯ä»¥åªå¯¹æ¯ä¸ªé€‰æ‰‹çš„åºå·è¿›è¡Œæ’åºï¼Œè¿™æ ·åšæ—¢å¯ä»¥ä¿è¯æˆ‘ä»¬æœ‰å„ä¸ªäººçš„æ’åºï¼Œåˆå¯ä»¥ä¿è¯ä»–ä»¬çš„æˆç»©å’Œå®åŠ›å¾—åˆ°è®°å½•ï¼ˆåºå·å¯¹åº”ç€æˆç»©å’Œå®åŠ›ï¼Œåœ¨å¯¹åºå·æ ¹æ®å®åŠ›æ’åºçš„åŒæ—¶ï¼Œæ¯ä¸ªåºå·å¯¹åº”çš„æˆç»©å’Œå®åŠ›çš„é¡ºåºæ˜¯ä¸å˜çš„ï¼‰ sort å‡½æ•°ä¸­ cmp çš„ä½¿ç”¨æ–¹æ³• 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int num,round,inquiry,score[200005],power[200005],No[200005],winner[100005],loser[100005];///å…¶ä¸­ï¼ŒNoé‡Œæ¯ä¸ªä¸‹æ ‡ä»£è¡¨é€‰æ‰‹çš„æ’åï¼Œpower &amp; score çš„ä¸‹æ ‡ä»£è¡¨é€‰æ‰‹çš„åºå·bool cmp(int, int);void mergesort();void compete();int main()&#123; cin&gt;&gt;num&gt;&gt;round&gt;&gt;inquiry; for(int i=1;i&lt;=2*num;i++) cin&gt;&gt;score[i]; for(int i=1;i&lt;=2*num;i++) cin&gt;&gt;power[i]; for(int i=1;i&lt;=2*num;i++) No[i]=i; //for(int i=1;i&lt;=2*num;i++) cout&lt;&lt;No[i]&lt;&lt;&quot; &quot;&lt;&lt;score[i]&lt;&lt;endl; sort(No+1,No+1+2*num,cmp); //for(int i=1;i&lt;=2*num;i++) cout&lt;&lt;No[i]&lt;&lt;&quot; &quot;&lt;&lt;score[i]&lt;&lt;endl; for(int i=1;i&lt;=round;i++) &#123; compete(); mergesort(); &#125; cout&lt;&lt;No[inquiry]; //while(true); return 0;&#125;bool cmp(int m, int n)&#123; ///cmpå‡½æ•°ä½¿ç”¨èŒƒä¾‹ if(score[m]==score[n]) return m&lt;n; else return score[m]&gt;score[n];&#125;void compete()&#123; for(int i=1;i&lt;=2*num;i=i+2) &#123; if(power[No[i]]&gt;power[No[i+1]]) &#123; score[No[i]]++; winner[i/2+1]=No[i]; loser[i/2+1]=No[i+1]; &#125; else if(power[No[i]]&lt;power[No[i+1]]) &#123; score[No[i+1]]++; winner[i/2+1]=No[i+1]; loser[i/2+1]=No[i]; &#125; &#125; /*cout&lt;&lt;&quot;compete&quot;&lt;&lt;endl; for(int i=1;i&lt;=num;i++) cout&lt;&lt;winner[i]&lt;&lt;&quot; &quot;&lt;&lt;loser[i]&lt;&lt;endl; cout&lt;&lt;endl;*/&#125;void mergesort()&#123; int i=1,j=1; while(i&lt;=num &amp;&amp; j&lt;=num) &#123; //if(score[winner[i]]&gt;score[loser[j]]) if(cmp(winner[i],loser[j])) ///å®Œå…¨æ— æ³•ç†è§£è¿™ä¸ªåœ°æ–¹åªå†™ä¸€ä¸ªcmpæ˜¯æ€ä¹ˆè¿‡çš„ï¼Œéš¾é“ä¸ä¼šæœ‰ä½äºåé¢çš„ç›¸ç­‰scoreé¡¹å®é™…æ¯”å‰é¢çš„ç›¸ç­‰scoreé¡¹åºå·æ›´å°è¿™ç§æƒ…å†µå— &#123; No[i+j-1]=winner[i]; i++; &#125; //else if(score[loser[j]]&gt;score[winner[i]]) else &#123; No[i+j-1]=loser[j]; j++; &#125; /*else if(score[loser[j]]==score[winner[i]]) &#123; int k=0,temp[200005]; while(score[winner[i]]==score[winner[i+1]]) temp[++k]=winner[i++]; while(score[loser[j]]==score[loser[j]]) temp[++k]=loser[j++]; sort(temp,temp+k); for(int a=1;a&lt;=k;a++) No[a+i+j-1]=temp[a]; &#125;*/ &#125; while(i&lt;=num) &#123; No[i+num]=winner[i]; i++; &#125; while(j&lt;=num) &#123; No[j+num]=loser[j]; j++; &#125; /*cout&lt;&lt;&quot;mergesort&quot;; for(int i=1;i&lt;=num*2;i++) cout&lt;&lt;No[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl;*/&#125;/*2 4 17 6 6 710 5 20 15*/","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"https://harmonyano.github.io/tags/NOI/"}]},{"title":"P1090 åˆå¹¶æœå­","slug":"P1090 åˆå¹¶æœå­","date":"2019-05-30T04:00:00.000Z","updated":"2019-06-27T12:31:58.850Z","comments":true,"path":"P1090 åˆå¹¶æœå­/","link":"","permalink":"https://harmonyano.github.io/P1090%20%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90/","excerpt":"é¢˜ç›®æ¥æºï¼š æ´›è°·P1090 åˆå¹¶æœå­ ä¸€ç»´æ•°ç»„åšæ³•æœ¬é¢˜æ˜¯ä¸€ä¸ªç®€å•çš„ Huffmanæ ‘ã€‚Huffmanç¼–ç  åœ¨ UTF-8 &amp; Unicode ä¸­éƒ½æœ‰å®ƒæ€æƒ³çš„ä½“ç°ï¼Œå³å‡ºç°é¢‘ç‡é«˜çš„ç¼–ç é•¿åº¦çŸ­ï¼Œå‡ºç°é¢‘ç‡ä½çš„ç¼–ç é•¿åº¦é•¿ï¼Œç”¨ä»¥ç¼©çŸ­æ•´ä½“ç¼–ç é•¿åº¦ è¿™é‡Œæˆ‘ä¹Ÿè¿ç”¨äº†å‰é¢ P1309 çš„æ€æƒ³ï¼šå› ä¸ºæ¯æ¬¡éœ€è¦é‡æ–°æ’åºçš„æ—¶å€™åªæœ‰ä¸€ä¸ªæ•°æ®éœ€è¦è¢«æ’å…¥æ•´ä¸ªæ•°åˆ—å½“ä¸­,æ‰€ä»¥å¹¶ä¸éœ€è¦å‡å®šæ•°æ®æ— åºçš„ quick sortï¼Œåè€Œæ˜¯çº¿æ€§çš„æ’åºæ›´å¿«","text":"é¢˜ç›®æ¥æºï¼š æ´›è°·P1090 åˆå¹¶æœå­ ä¸€ç»´æ•°ç»„åšæ³•æœ¬é¢˜æ˜¯ä¸€ä¸ªç®€å•çš„ Huffmanæ ‘ã€‚Huffmanç¼–ç  åœ¨ UTF-8 &amp; Unicode ä¸­éƒ½æœ‰å®ƒæ€æƒ³çš„ä½“ç°ï¼Œå³å‡ºç°é¢‘ç‡é«˜çš„ç¼–ç é•¿åº¦çŸ­ï¼Œå‡ºç°é¢‘ç‡ä½çš„ç¼–ç é•¿åº¦é•¿ï¼Œç”¨ä»¥ç¼©çŸ­æ•´ä½“ç¼–ç é•¿åº¦ è¿™é‡Œæˆ‘ä¹Ÿè¿ç”¨äº†å‰é¢ P1309 çš„æ€æƒ³ï¼šå› ä¸ºæ¯æ¬¡éœ€è¦é‡æ–°æ’åºçš„æ—¶å€™åªæœ‰ä¸€ä¸ªæ•°æ®éœ€è¦è¢«æ’å…¥æ•´ä¸ªæ•°åˆ—å½“ä¸­,æ‰€ä»¥å¹¶ä¸éœ€è¦å‡å®šæ•°æ®æ— åºçš„ quick sortï¼Œåè€Œæ˜¯çº¿æ€§çš„æ’åºæ›´å¿« 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n,berry[10005];long long ans=0; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;berry[i]; sort(berry+1,berry+1+n); for(int i=1;i&lt;=n-1;i++)&#123; berry[i+1]=berry[i]+berry[i+1];///è®¡ç®—æ¯ä¸ªæœå †çš„é‡é‡ ans+=berry[i+1];///ç­”æ¡ˆæ˜¯æ¯æ¬¡æ¬çš„æœå †çš„é‡é‡ä¹‹å’Œ if(berry[i+1]&gt;berry[i+2])&#123;///è§£å†³å‰ä¸¤ä¸ªæ•°ä¹‹å’Œå¤§äºç¬¬ä¸‰/å››ä¸ªæ•°çš„æƒ…å†µï¼ˆæ¯”å¦‚æœ‰ 1 1 1 1ï¼‰æœ€ä¼˜è§£ä¸º4è€Œä¸æ˜¯7 for(int j=i+1;j&lt;=n-1;j++)&#123; if(berry[j]&gt;berry[j+1]) swap(berry[j],berry[j+1]);///çº¿æ€§æ’åº &#125; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; å½’å¹¶åšæ³• æ®è¯´æ˜¯ç¦»æ•£åŒ–ç®—æ³• å°±æ˜¯å…ˆæŠŠåŸæœ¬çš„ä»å°åˆ°å¤§æ’åºæ’å¥½ã€‚ç„¶åç”¨ä¸¤ä¸ªé˜Ÿåˆ—ï¼Œä¸€ä¸ªæ˜¯å­˜å‚¨åŸæœ¬çš„ï¼Œå¦ä¸€ä¸ªæ˜¯å­˜å‚¨åˆæˆçš„ï¼ˆç”±äºåŸæœ¬çš„æ˜¯ä»å°åˆ°å¤§æ‰€æœ‰æ–°å¼€çš„ä¹Ÿæ˜¯ä»å°åˆ°å¤§ï¼‰ã€‚ç„¶ååœ¨ä¸¤ä¸ªé˜Ÿåˆ—çš„å¤´å–æœ€å°çš„ï¼Œæ‰§è¡Œä¸¤æ¬¡ç„¶åæŠŠè¿™ä¸¤ä¸ªåˆå¹¶åŠ å…¥ç¬¬äºŒä¸ªé˜Ÿåˆ—ä¸­ã€‚ ç„¶åç”±äºè¾“å…¥ï¼š (1â‰¤aiâ‰¤20000)(1â‰¤aiâ‰¤20000)(1â‰¤aiâ‰¤20000) ï¼Œæ‰€ä»¥ç”¨æ¡¶æ’åºå°±å¯ä»¥ O(n)O(n)O(n) æ—¶é—´å¤æ‚åº¦ è¦ä¹‰æ˜¯å‚¨å­˜åŸæœ¬æœå †çš„a1æ˜¯æŒ‰é¡ºåºæ’åˆ—çš„ï¼Œæ‰€ä»¥å­˜å‚¨ä¸¤ä¸¤åˆæˆçš„æ–°æœå †çš„a2ä¹Ÿæ˜¯æŒ‰é¡ºåºæ’åˆ—çš„ã€‚å–è¿™ä¸¤ä¸ªæœå †åºåˆ—ä¸­æœ€å°çš„ä¸¤ä¸ªæœå †ï¼Œå¿…å®šè·å¾—è¿™ä¸€æ­¥èƒ½è·å¾—çš„æœ€å°çš„æœå †ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int k,x,num,n1,n2,a1[30001],a2[30001],t[20001],w,sum;int main()&#123; scanf(&quot;%d&quot;,&amp;num); memset(a1,127/3,sizeof(a1)); memset(a2,127/3,sizeof(a2)); for (int i=1;i&lt;=num;i++) &#123; scanf(&quot;%d&quot;,&amp;x); t[x]++;//æ¡¶ &#125; for (int i=1;i&lt;=20000;i++) &#123; while (t[i])//é€šæ’åº &#123; t[i]--; a1[++n1]=i; &#125; &#125; int i=1,j=1; k=1; while (k&lt;num) &#123; if (a1[i]&lt;a2[j])//å–æœ€å°å€¼ &#123; w=a1[i]; i++; &#125; else &#123; w=a2[j]; j++; &#125; if (a1[i]&lt;a2[j])//å–ç¬¬äºŒæ¬¡ &#123; w+=a1[i]; i++; &#125; else &#123; w+=a2[j]; j++; &#125; a2[++n2]=w;//åŠ å…¥ç¬¬äºŒä¸ªé˜Ÿåˆ— k++;//è®¡ç®—åˆå¹¶æ¬¡æ•° sum+=w;//è®¡ç®—ä»·å€¼ &#125; printf(&quot;%d&quot;,sum);&#125; äºŒå‰ï¼ˆå°æ ¹ï¼‰å †s ä»£è¡¨ son, p ä»£è¡¨ parent, size ä»£è¡¨æ•´ä¸ªäºŒå‰å †ä¸­å­˜å‚¨çš„æ•°æ®æ•°é‡ å®Œç¾äºŒå‰æ ‘, å®Œå…¨äºŒå‰æ ‘å’Œå®Œæ»¡äºŒå‰æ ‘çš„åŒºåˆ† 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=10000+10;int n,heap[maxn],size=0;void up(int p) //äºŒå‰å°æ ¹å †å‘ä¸Šè°ƒæ•´ï¼ˆå­èŠ‚ç‚¹å°äºçˆ¶èŠ‚ç‚¹å°±è°ƒæ•´ï¼‰&#123; while(p&gt;1) &#123; if(heap[p]&lt;heap[p/2]) &#123; swap(heap[p],heap[p/2]); p/=2; &#125; else break; &#125;&#125;void insert(int val) //äºŒå‰å †æ’å…¥ï¼Œæ–°å…ƒç´ æ”¾åœ¨å †åº•ï¼Œå‘ä¸Šè°ƒæ•´&#123; heap[++size]=val; up(size);&#125;void down(int p) //äºŒå‰å°æ ¹å †å‘ä¸‹è°ƒæ•´&#123; int s=p*2; while(s&lt;=size) &#123; //ä¸‹é¢è¿™å¥è¯æ˜¯ä»å·¦å³å„¿å­ä¸­é€‰ä¸€ä¸ªæ›´å°çš„åšäº¤æ¢ if(s&lt;size&amp;&amp;heap[s+1]&lt;heap[s]) s++; if(heap[s]&lt;heap[p]) &#123; swap(heap[s],heap[p]); p=s; s=p*2; &#125; else break; &#125;&#125;void extract() //äºŒå‰å †åˆ é™¤å †é¡¶&#123; heap[1]=heap[size--]; //å°†å †åº•ç§»è‡³å †é¡¶ï¼Œå‘ä¸‹è°ƒæ•´ down(1);&#125;int gettop() //è¿”å›å †é¡¶çš„å€¼&#123; return heap[1];&#125;int main()&#123; cin&gt;&gt;n; for(int i=1; i&lt;=n; i++) &#123; int a; cin&gt;&gt;a; insert(a); //å»ºç«‹äºŒå‰å † &#125; long long ans=0; //å…¶å®è¿™é‡Œä¸ä¼šè¶Šç•Œï¼Œä½†å¥½åƒåŸé¢˜æ•°æ®æ˜¯3ä¸‡ while(size&gt;=2) //å¦‚æœè¿˜å¯åˆå¹¶ &#123; int top1=gettop(); //å–å‡ºå †é¡¶ï¼ˆå †ä¸­æœ€å°å€¼ï¼‰ååˆ é™¤å †é¡¶ extract(); int top2=gettop(); //åŒä¸Š extract(); ans+=(top1+top2); insert(top1+top2); //å°†ä¸¤æ•°ä¹‹å’ŒåŠ å…¥äºŒå‰å †ï¼Œé‡å¤è¿ç®— &#125; cout&lt;&lt;ans&lt;&lt;endl; //è¾“å‡ºç­”æ¡ˆ return 0;&#125;","categories":[],"tags":[{"name":"NOI","slug":"NOI","permalink":"https://harmonyano.github.io/tags/NOI/"}]},{"title":"Introduction to Git Command","slug":"Intro-to-Git-Command","date":"2019-02-10T05:00:00.000Z","updated":"2021-08-31T00:22:57.002Z","comments":true,"path":"Intro-to-Git-Command/","link":"","permalink":"https://harmonyano.github.io/Intro-to-Git-Command/","excerpt":"Creating repository git init: create a repository git add File_Name: add â€œFile_Nameâ€ to repository git add . : add all files git commit -m &quot;message&quot;: commit changes and tell others what changes have been made","text":"Creating repository git init: create a repository git add File_Name: add â€œFile_Nameâ€ to repository git add . : add all files git commit -m &quot;message&quot;: commit changes and tell others what changes have been made Way-back Machine git status: tell you which files have been changed git diff: check what content exactly has been changed in each file Time Travelling commitID: git uses commit ID, a hex number calculated by SHA1 to record your commit history HEAD: HEAD is the current version, HEAD^ is the previous, HEAD^^ is the one before the previous, HEAD~100 is the last 100. git log: check the commit history git reflog: check the command history git reset --hard CommitID : Going back to the â€œCommit IDâ€ version (e.g. git reset --hard HEAD^ : going back to the previous version) When you go back, the â€œfuture versionâ€ will no longer appear in â€œgit logâ€œ. However, you can use â€œgit reflogâ€œ to trace â€œcommit IDâ€ from the future Undo Changes messed up with working directory: use git checkout -- File_Name to discard changes in working directory and make â€œFile_Nameâ€ to go back to the latest â€œcommittedâ€ or â€œaddedâ€ version messed up with working directory but donâ€™t want to delete all the changes: git stash saves your local modifications away and reverts the working directory to match the HEAD commit. messed up with working directory and added it to stage: use git reset HEAD File_Name to discard changes in stage but keep â€œFile_Nameâ€ in working directory changed, therefore going back to situation 1 committed the mess to master branch: use the Time Traveling technique in the previous section Deleting FilesIf you want to delete files that are already committed to the master branch: delete the file in working directory: rm File_Name delete the file from git / restore the file delete the file from git: git rm File_Name &amp; git commit restore the file: git checkout -- File_Name Managing BranchCreating and Deleting Branch æŸ¥çœ‹åˆ†æ”¯ï¼šgit branch åˆ›å»ºåˆ†æ”¯ï¼šgit branch &lt;name&gt; åˆ‡æ¢åˆ†æ”¯ï¼šgit checkout &lt;name&gt; åˆå¹¶æŸåˆ†æ”¯åˆ°å½“å‰åˆ†æ”¯ï¼šgit merge &lt;name&gt; åˆ é™¤åˆ†æ”¯ï¼šgit branch -d &lt;name&gt; Solving Conflicts","categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"https://harmonyano.github.io/tags/Logistics/"},{"name":"Git","slug":"Git","permalink":"https://harmonyano.github.io/tags/Git/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-02-09T05:00:00.000Z","updated":"2020-08-04T09:29:47.857Z","comments":true,"path":"hello-world/","link":"","permalink":"https://harmonyano.github.io/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Real Startå®é™…ä¸Šä½ åº”è¯¥ä½¿ç”¨ npx hexo &lt;command&gt; æ¥è¿è¡Œ hexo.","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://harmonyano.github.io/tags/Hexo/"}]}],"categories":[],"tags":[{"name":"Logistics","slug":"Logistics","permalink":"https://harmonyano.github.io/tags/Logistics/"},{"name":"Linux","slug":"Linux","permalink":"https://harmonyano.github.io/tags/Linux/"},{"name":"Reading","slug":"Reading","permalink":"https://harmonyano.github.io/tags/Reading/"},{"name":"20FA","slug":"20FA","permalink":"https://harmonyano.github.io/tags/20FA/"},{"name":"Tsinghua","slug":"Tsinghua","permalink":"https://harmonyano.github.io/tags/Tsinghua/"},{"name":"Cornell","slug":"Cornell","permalink":"https://harmonyano.github.io/tags/Cornell/"},{"name":"C++","slug":"C","permalink":"https://harmonyano.github.io/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://harmonyano.github.io/tags/Python/"},{"name":"Latex","slug":"Latex","permalink":"https://harmonyano.github.io/tags/Latex/"},{"name":"CS4820","slug":"CS4820","permalink":"https://harmonyano.github.io/tags/CS4820/"},{"name":"CS2024","slug":"CS2024","permalink":"https://harmonyano.github.io/tags/CS2024/"},{"name":"CS4320","slug":"CS4320","permalink":"https://harmonyano.github.io/tags/CS4320/"},{"name":"Game","slug":"Game","permalink":"https://harmonyano.github.io/tags/Game/"},{"name":"ç½‘ç»œæ—¥å¿—","slug":"ç½‘ç»œæ—¥å¿—","permalink":"https://harmonyano.github.io/tags/%E7%BD%91%E7%BB%9C%E6%97%A5%E5%BF%97/"},{"name":"20SP","slug":"20SP","permalink":"https://harmonyano.github.io/tags/20SP/"},{"name":"CS3110","slug":"CS3110","permalink":"https://harmonyano.github.io/tags/CS3110/"},{"name":"CS2043","slug":"CS2043","permalink":"https://harmonyano.github.io/tags/CS2043/"},{"name":"19FA","slug":"19FA","permalink":"https://harmonyano.github.io/tags/19FA/"},{"name":"Hexo","slug":"Hexo","permalink":"https://harmonyano.github.io/tags/Hexo/"},{"name":"CS2112","slug":"CS2112","permalink":"https://harmonyano.github.io/tags/CS2112/"},{"name":"Android","slug":"Android","permalink":"https://harmonyano.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://harmonyano.github.io/tags/Java/"},{"name":"NOI","slug":"NOI","permalink":"https://harmonyano.github.io/tags/NOI/"},{"name":"Git","slug":"Git","permalink":"https://harmonyano.github.io/tags/Git/"}]}